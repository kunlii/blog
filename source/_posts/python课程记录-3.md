---
title: python课程记录-3
date: 2020-03-11 09:38:20
tags: python
category: 课程笔记
---
### 知识点记录

这次上课有一些是以前不太了解的知识点。

<!--more-->

##### 序列

包括字符串、列表、元组、字节序列。

1. 索引访问：

   有`n`个元素的数组，索引范围是`[0, n-1]`或`[-n, -1]`，也就是说，除了常规的类似其他语言中数组的下标索引方式，我们还可以通过`-1`来逆序访问。这在某些时候是很方便的一个操作，比如判断回文字符串。

2. 遍历访问：

   遍历也是用`for`循环，不过和其他语言不同的是，这里`for`循环中的`i`类型很随意，可以是`1, 2, 3, ...`也可以是元组、字符等，例如：

   ```python
   for c in 'hello':
   	print(c)
   ```

   这里的`c`是字符，最终会把`h`, `e`, `l`, `l`, `o` 逐行输出。

   ```python
   for t in [(1,2),(3,4),(5,6)]
   	print(t,t[0],t[1])
   ```

   这里的`t`是元组，最终输出是：

   ```python
   (1,2) 1 2
   (3,4) 3 4
   (5,6) 5 6
   ```

3. 切片

   序列`s`可以通过`s[i:j:k]`来截取其中的一部分，`i`是起点，`j`是终点，`k`是步长，注意这里的起点终点都可以是负数，结合上文可知，`s[::-1]`实际上就是序列的逆序。注意这个切片并不会改变序列`s`。想要将切片的下标信息保存下来，我们可以使用`slice(i:j:k)`函数。这里如果越界了也不会报错。

4. 连接和重复

   连接`+`：`s1+s2 `

   重复`*`：`s*n` 或者 `n*s`

   增量赋值：`+=`和`*=`

   元组不可以`+=`序列，但是反过来序列`+=`元组是没问题的。

5. 成员关系操作

   `in`和`not in`可以判断一个元素是否在序列中。

   `s.count(value)`可以统计`value`在序列`s`中出现的次数。

   `s.index(value, [start, [stop]]) `查找value在序列指定范围 `[start,stop)`中第一次出现的下标。

6. 序列内置函数

   `len` 单纯求序列长度

   `sorted`对序列排序并返回排序后的列表，不改变原始序列

   `reversed`逆序，不改动原序列，返回反向迭代器

   `max`和`min`求最大值和最小值，要求元素类型都一样

   `sum`序列求和，要求不能有非数字

   `enumerate`返回元素为`元组(计数，元素)` 的迭代器

   `zip`拼接多个对象`iter1、iter2…`的元素， 返回一个迭代器，其元素为各对象元素组成的元组。

   `all`和`any`判断序列的元素是否全部和部分为True

7. 序列类型转换

   `str` `list` `tuple` `bytes` `bytearray`可以从字面意义看出是转成什么类型。

8. 的

9. 序列拆分

   `变量1,变量2,…,变量n = 序列`这样的赋值语句，可以把序列中的元素拆开赋值给前面的变量，不过类型要统一，比如序列中有元组，那前面对应位置的变量也要写成元组的形式。

   `*变量`的形式，可以把多个元素打包赋值给一个变量，但是只能出现一次。

   可以用临时变量`_`来占位从而将指定位置的元素赋值给某个变量，例如`_, b, _ = (1, 2, 3)`就是把`2`赋值给`b`。

##### 列表

1. `del`删除元素，赋值修改元素

2. `s.append(x)` 把`x`追加到`s`末尾

3. `s.clear()` 删除所有元素

4. `s.copy()` 复制

5. `s.extend(t)` 和上面的`s.append(x)`是一样的，区别在于，`append`把`x`作为一个整体加到末尾，而`extend`把`x`作为一个新的列表合并到`s`的末尾。

6. `s.insert(i,x)`插入

7. `s.pop([i])`返回并移除下标为`i`的元素，`i`省略时默认为最后一个元素

8. `s.remove(x)`移除列表中第一次出现的`x`

9. `s.reverse()`列表反转

10. `s.sort()`列表排序

11. 列表解析表达式：处理可迭代对象并生成结果列表，具体格式为`[express for i_1 in 可迭代对象1…for i_N in 可迭代对象N [if condition] ]`

    例如：

    ```python
    [i for i in range(10)]
    [i**2 for i in range(10) if i%2==0]
    [(x+y,x*y) for x in range(2) for y in range(2,4)]
    
    # 列表解析生成字典和集合
    a = [('小黑','领导',30000),('小白','职员',10000),('小蓝','职员',5000)]
    {i[0]:i[2] for i in a}
    # output: {'小黑': 30000, '小白': 10000, '小蓝': 5000}
    {i[0] for i in a if i[2]>=10000}
    # output: {'小白', '小黑'}
    ```

### 课堂练习

1. 已知一选手的各评委得分`score = [95, 85, 89, 88, 86, 95, 89, 98, 85, 75, 80]`，运用序列的各项操作求该选手的得分，计算规则：去掉一个最高分和一个最低分，剩下的分数计算平均分。

   最直接的思路就是整体求和然后减去最大的和最小的再算平均值，也就是：

   ```python
   score = [95, 85, 89, 88, 86, 95, 89, 98, 85, 75, 80]
   s = (sum(score) - max(score) - min(score)) / (len(score) - 2)
   print(s)
   ```

2. 判断一个字符串是否是回文串：`a = 'abcdcba'  b = 'abcdefg'`

   这个题有很多思路，最快的办法就是用前面提到的`s[::-1]`来实现逆序，即：

   ```python
   def is_palindromic4(num):
       return num == num[::-1]
   a = 'abcdcba'
   b = 'abcdefg'
   print(is_palindromic4(b))
   ```

   也可以选择把字符串转成`list`或者`tuple`然后使用`reverse`函数来实现逆序。即：

   ```python
   list(a)==list(reverse(a))
   tuple(a)==tuple(reverse(a))
   ```

3. 下面代码执行后的`s`是（）

   ```python
   s = ['a', 'b']
   s.append([1, 2])
   s.extend('34')
   s.extend([5, 6])
   s.insert(1, 7)
   s.insert(10, 8)
   s.pop(2)
   s.remove('a')
   s[4:] = []
   s.reverse()
   ```

   对照每个函数的作用可以很容易判断出最后的结果是`['4','3',[1,2],7]`

### 作业

1. 使用`+`,`-`,`*`,`/`,`**`运算符和数字`2`,`3`,`4`,`5`，构造一个表达式，该表达式中上述4个数字和3种不同运算符各用一次，使得表达式的结果为24，打印出满足条件的表达式。

   提示：

   (1)构建表达式字符串，然后用内置函数`eval`计算该字符串 ，例如`eval('3*4/2+5')`返回`11.0`； 

   (2)两字符串可通过”+”连接成一个字符串，如`’he’+’llo’`会 得到`’hello’`； 

   (3)本题关键在于求排列，排列有多种实现方式，例如循环。

   根据提示很容易想到一个思路：把数字的全排列和运算符的取3个排列分别列出来，然后逐一组合成字符串，使用`eval`计算结果，如果是24，就输出。查找资料后发现`python`有一个算排列的库函数`itertools.permutations(s, n)`，该函数返回列表`s`中取`n`个元素的排列结果，该结果也是一个列表，也就是说我们可以通过该函数得到数字和运算符的排列结果，并`for`循环遍历，将它们组成计算表达式并求结果，然后输出。代码如下：

   ```python
   import itertools
   op = ['+', '-', '*', '/', '**']
   num = ['2', '3', '4', '5']
   for i in itertools.permutations(num, 4):
       for j in itertools.permutations(op, 3):
           s = i[0] + j[0] + i[1] + j[1] + i[2] + j[2] + i[3]
           if float(eval(s)) == 24.0:
               print(s)
   ```

   此外，`python`中完成24点游戏的思路还有很多很多，复杂一些的办法可以是构造二叉树，然后遍历节点。

2. 输入一个列表，然后删除该列表中的重复的元素，要求删除重复元素后还保持原排序，最后输出结果。例如，输入列表 `[0, 1, 1, 1, 3, 0, 3, 2]`，输出 `[0, 1, 3, 2]`。

   这个题也有很多思路，比如逐个比较等。有一种很便捷的方法是，对输入列表生成字典，这样就按顺序去掉了重复元素，再将字典的`key`转成列表即可，代码如下：

   ```python
   list1 = eval(input('请输入一个列表：'))
   list2 = dict.fromkeys(list1)
   list3 = list(list2.keys())
   print(list3)
   ```