<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023年2月1日-6月30日预算</title>
    <url>/2023/01/16/2023%E5%B9%B42%E6%9C%881%E6%97%A5-6%E6%9C%8830%E6%97%A5%E9%A2%84%E7%AE%97/</url>
    <content><![CDATA[<h1 id="2023年2月1日-6月30日预算"><a href="#2023年2月1日-6月30日预算" class="headerlink" title="2023年2月1日-6月30日预算"></a>2023年2月1日-6月30日预算</h1><h2 id="预算表"><a href="#预算表" class="headerlink" title="预算表"></a>预算表</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">科目</th>
<th style="text-align:center">金额（单位：元）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">餐饮</td>
<td style="text-align:center">7200</td>
</tr>
<tr>
<td style="text-align:center">会员费</td>
<td style="text-align:center">115</td>
</tr>
<tr>
<td style="text-align:center">游戏</td>
<td style="text-align:center">600</td>
</tr>
<tr>
<td style="text-align:center">生活用品</td>
<td style="text-align:center">300</td>
</tr>
<tr>
<td style="text-align:center">服饰相关</td>
<td style="text-align:center">500</td>
</tr>
<tr>
<td style="text-align:center">其他支出</td>
<td style="text-align:center">1285</td>
</tr>
</tbody>
</table>
</div>
<h2 id="测算依据"><a href="#测算依据" class="headerlink" title="测算依据"></a>测算依据</h2><p>从2月1日到6月30日共5个月，20周，150天，合计预算10000。</p>
<ol>
<li>餐饮：平均一日三餐合计30元，每日牛奶+酸奶合计10元，每周水果10元，每月外出聚餐+零食+饮料等按总共200计算，合计$(30+10)\times150+10\times20+200\times5=7200$。</li>
<li>各类会员：网易云每月8元，B站每月15元，合计$23\times5=115$。</li>
<li>游戏：原神每月98，合计490，FF14和其他游戏关联费用暂定110，合计600。</li>
<li>生活用品：由于2022年双十一买了一批东西，因此上半年应该不用买太多，按每个月50算，再凑个整暂定300。</li>
<li>服饰相关：应该不会买什么，暂定500。</li>
<li>其他：考虑到一些临时性的额外支出等，凑个整算1285。</li>
</ol>
]]></content>
      <categories>
        <category>账本</category>
      </categories>
      <tags>
        <tag>预算</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-A Robust Bayesian Truth Serum for Small Populations</title>
    <url>/2023/01/02/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-A%20Robust%20Bayesian%20Truth%20Serum%20for%20Small%20Populations/</url>
    <content><![CDATA[<h1 id="A-Robust-Bayesian-Truth-Serum-for-Small-Populations"><a href="#A-Robust-Bayesian-Truth-Serum-for-Small-Populations" class="headerlink" title="A Robust Bayesian Truth Serum for Small Populations"></a>A Robust Bayesian Truth Serum for Small Populations</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>对等预测机制允许在真实的世界状态方面真实地引出私人信号（例如，经验或意见），而这个基础真相是不可观察的。最初的对等预测方法对于任意数量大于2的实体而言都是激励相容的，但依赖于所有实体共享的公共先验和机制。而贝叶斯吐真剂BTS则放宽了这个假设。BTS仍然假设代理共享同一个公共先验，但机制不需要知道该先验。然而，BTS仅在实体数量足够大的时候才激励相容，且需要的确切实体数量并不确定，而是取决于私有先验。本文提出了针对二值信息的稳定BTS，它对于任意实体数量大于3的场景都激励相容，利用二次函数评分规则的一个特性。RBTS是第一个针对$n \geq 3$的场景提供了严格激励相容而无需知道公共先验的对等预测机制。此外，与原始的BTS不同，我们的机制在数字上是稳健的，而且事后是个体理性的（<em>ex post</em> individually rational）。</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>先略</p>
<h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>先略</p>
<h2 id="The-Setting"><a href="#The-Setting" class="headerlink" title="The Setting"></a>The Setting</h2><p>存在数量大于等于3的理性且风险中立的代理，其目标是最大化自己的期望收益。他们都共享同一个概率统计信念系统，该系统由两部分组成：状态和信号。状态$T$是一个随机遍历，取值$\lbrace 1,…,m\rbrace,m\geq 2$，代表了世界的真实状态。每一个实体$i$观察一个信号，记作随机变量$S_i$，是取值在$\lbrace 0,1 \rbrace$的二值变量，有时也记作$\lbrace l,h \rbrace$分别表示低和高。信号可以看作是代表了实体的经验或者意见。一个普通的信号用随机变量$S$表示。所有实体都有公共先验，由$Pr(T=t)$和$Pr(S=h|T=t)$组成，指给定任意可能状态$t$会观察到高级信号的条件概率。我们要求先验是可接受的：</p>
<p><strong>定义</strong>1：如果公共先验满足以下属性，那么它就是可接受的：</p>
<ol>
<li>有两个或更多的状态，即$m\geq 2$。</li>
<li>每一个状态都有正概率出现，即对于所有$t\in\lbrace 1,…,m \rbrace$来说，$Pr(T=t)&gt;0$。</li>
<li>状态之间是不同的，对于任意$t\neq t’$，都有$Pr(S=h|T=t)\neq Pr(S=h|T=t’)$。所有状态都按惯例排序，即$Pr(S=h|T=1)&lt;…&lt;Pr(S=h|T=m)$。我们把这称为同种异构的特性。</li>
<li>以状态为条件的信号信念是完全混合的，对于所有$t$，$0&lt;Pr(S=h|T=t)&lt;1$。</li>
</ol>
<p>可接受性是一个弱要求。尤其要注意的是，任何先验都可以转化为可接受的先验，因为(1)对于具有正概率的状态，所有以状态为条件的信号信念是完全混合的；(2)对于至少两个具有正概率的状态，以状态为条件的信号信念是不同的。任何两个具有相同信号信念概率的状态都可以合并成一个新的状态，而概率为零的状态可以被放弃。该机制不需要任何关于可接受性以外的先验知识。</p>
<p>给定实体$i$的信号$s_i$，它可以更新自己关于另一个实体$j$会收到高级信号的概率的后验信念$P(S_j=h|S_i=s_i)$。因为公共先验，我们可以用$p_h=Pr(S_j=h|S_i=h)$和$p_l=Pr(S_j=h|S_i=l)$来分别表示一个普通实体在自己持有高和低信号的条件下对其他实体会持有高级信号的后验信念。我们将之称为一阶信号后验，且：</p>
<script type="math/tex; mode=display">
p_{\{h\}}=\sum_{t=1}^m \operatorname{Pr}\left(S_j=h \mid T=t\right) \operatorname{Pr}\left(T=t \mid S_i=s_i\right)</script><p>【个人理解】这个式子是指一个普通实体自己持有高信号的情况下，认为其他实体也持有高信号的概率。具体计算起来，就是自己持有信号$s_i$的情况下状态是$T=t$的条件概率，乘以状态是$T=t$的情况下，实体$j$持有高信号的概率，然后对所有可能的$t$求和，得到的总概率就是$p_h$。我其实觉得末尾的$S_i=s_i$应该是$S_i=h$，这样才能说得通。</p>
<p>其中关于状态的后验可以用通常的方式从贝叶斯规则中确定，等于</p>
<script type="math/tex; mode=display">
\operatorname{Pr}\left(T=t \mid S_i=s_i\right)=\frac{\operatorname{Pr}\left(S_i=s_i \mid T=t\right) \operatorname{Pr}(T=t)}{\operatorname{Pr}\left(S_i=s_i\right)}</script><p>而分母则是：</p>
<script type="math/tex; mode=display">
\operatorname{Pr}\left(S_i=s_i\right)=\sum_{t=1}^m \operatorname{Pr}\left(S_i=s_i \mid T=t\right) \operatorname{Pr}(T=t)</script><p>这些信号后验可以在实体知道两个信号的情况下进行类似的计算。我们扩展了这个符号，因此$p_{\lbrace h,l \rbrace}$表示在知道一个高信号和一个低信号之后的二阶后验。例如，对于实体$i$，我们可知对于任意不同的$j,k\neq i$，都有$p_{\lbrace h,l \rbrace}=\operatorname{Pr}\left(S_k=h \mid S_i=h, S_j=l\right)$。在这种情况下，实体$i$首先更新关于状态$T$的后验，即$Pr(T=t|S_i=s_i)$，这成为信念，以便进行第二轮的贝叶斯更新。</p>
<h2 id="The-Bayesian-Truth-Serum"><a href="#The-Bayesian-Truth-Serum" class="headerlink" title="The Bayesian Truth Serum"></a>The Bayesian Truth Serum</h2><p>在这一节中，我们解释了Prelc（2004）的原始贝叶斯真理血清（BTS）。虽然我们介绍的是这个机制的二进制版本，但BTS是针对任意数量的信号而定义的。</p>
<p>在BTS中，每一个实体$i$都需要提供两个报告：</p>
<ol>
<li>信息报告：$x_i\in\lbrace 0,1 \rbrace$表示实体$i$报告的信号</li>
<li>预测报告：$y_i\in[0,1]$表示实体$i$对人群中高信号出现的频率的预测</li>
</ol>
<p>BTS中实体$i$的分数包括以下3步：</p>
<ol>
<li>对于任意实体$j\neq i$，计算除了$i$和$j$以外，所有实体报告信号的算术平均：<script type="math/tex; mode=display">
\bar{x}_{-i j}=\frac{1}{n}\left(\left(\sum_{k \neq i, j} x_k\right)+1\right)</script></li>
<li>对于任意实体$j\neq i$，计算除了$i$和$j$以外，所有实体对高低两种信号频率的预测的几何平均：<script type="math/tex; mode=display">
\bar{y}_{-i j}=\left(\prod_{k \neq i, j} y_k\right)^{\frac{1}{n-2}}, \quad \bar{y}_{-i j}^{\prime}=\left(\prod_{k \neq i, j}\left(1-y_k\right)\right)^{\frac{1}{n-2}}</script></li>
<li>计算实体$i$的BTS评分：<script type="math/tex; mode=display">
\begin{aligned}
& u_i=\underbrace{\sum_{j \neq i}\left(x_i \ln \left(\frac{\bar{x}_{-i j}}{\bar{y}_{-i j}}\right)+\left(1-x_i\right) \ln \left(\frac{1-\bar{x}_{-i j}}{\bar{y}_{-i j}^{\prime}}\right)\right)}_{\text {information score }} \\
& +\underbrace{\sum_{j \neq i}\left(\bar{x}_{-i j} \ln \left(\frac{y_i}{\bar{x}_{-i j}}\right)+\left(1-\bar{x}_{-i j}\right) \ln \left(\frac{1-y_i}{1-\bar{x}_{-i j}}\right)\right)}_{\text {prediction score }}
\end{aligned}</script>这里注释提到，BTS有两种，一种是无限数量的实体，一种是有限数量的实体，这篇论文关注的是后者。此外BTS使用了拉普拉斯平滑来避免出现为0的概率。</li>
</ol>
<p>此外，这里和我之前理解的不那么一样，具体来说，之前我以为是直接计算所有人的算术平均和几何平均，但是从这个论文来看，它是分别计算了去掉每一个实体以后的平均值并求和。在人很多的时候，去掉一个人对均值也没影响，而人很少的时候，这个均值就会有波动了，进而导致激励相容不一定成立。</p>
<p>这对$n \rightarrow \infty$来说很简单，因为公式中对$j\neq i$的求和可以用只用一个随机选择的$j\neq i$计算的信息分和预测分来代替。</p>
<p>如果所有代理人（1）报告他们的真实信号和（2）预测人口中高信号的频率是他们的信号后验，则BTS机制是严格的贝叶斯-纳什激励相容。</p>
<p><strong>定理</strong>1：当$n\rightarrow \infty$且所有先验可接受时，BTS是严格贝叶斯纳什激励相容的。</p>
<p>Prelec评论说，这个结果对于适当大的、有限的$n$也是成立的，实际的门槛取决于共同的先验。然而，BTS不需要为小群体的实体调整激励。此外，对于小群体来说，它不需要满足临时个体理性（interim IR），也就是说，实体的期望收益可以是负的。</p>
<p><strong>定理</strong>2：当$n=3$时，BTS并不满足贝叶斯纳什激励相容或个体理性。</p>
<p>BTS的这种局限性可以从Prelec对BTS的处理中得到理解。一般来说，BTS兼容Bayes-Nash激励所需的代理数量取决于先验，而且很难确定。尽管如此，不同地方对BTS的讨论仍然没有注意到这个重要的注意事项，例如（Jurca和Faltings 2008；Chen和Pennock 2010）。出于这个原因，我们提供一个具体的例子。这个例子不是唯一的，也不依赖于$n=3$。</p>
<p><strong>例</strong>1：（BTS且$n=3$）考虑三个代理人共享以下先验，$m=2$（两个状态）：$Pr(T=2)=0.7, Pr(S=h|T=2)=0.8, Pr(S=h|T=1)=0.1$。基于此，后验信号信念分别是$p_{\{h\}}=\operatorname{Pr}\left(S_j=h \mid S_i=h\right)=0.764$和$p_{\{l\}}=\operatorname{Pr}\left(S_j=h \mid S_i=l\right)=0.339$。</p>
<p>【个人理解】$P(T=2)=0.7,P(T=1)=0.3,P(S=h|T=2)=0.8,P(S=h|T=1)=0.1$</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(S_i=h)&=\sum_{t=1}^m P\left(S_i=h \mid T=t\right) P(T=t)\\
&=P(S_i=h|T=1)P(T=1)+P(S_i=h|T=2)P(T=2)\\
&=0.1*0.3+0.8*0.7\\
&=0.59
\end{aligned}</script><script type="math/tex; mode=display">
P(T=1|S_i=h)=\frac{P(S_i=h|T=1)P(T=1)}{P(S_i=h)}=\frac{0.1*0.3}{0.59}=0.0508</script><script type="math/tex; mode=display">
P(T=2|S_i=h)=\frac{P(S_i=h|T=2)P(T=2)}{P(S_i=h)}=\frac{0.8*0.7}{0.59}=0.9491</script><script type="math/tex; mode=display">
\begin{aligned}
P(S_j=h|S_i=h)&=\sum_{t=1}^m \operatorname{Pr}\left(S_j=h \mid T=t\right) \operatorname{Pr}\left(T=t \mid S_i=h\right) \\
&=P(S_j=h|T=1)P(T=1|S_i=h)+P(S_j=h|T=2)P(T=2|S_i=h)\\
&=0.1*0.0508+0.8*0.9491=0.764
\end{aligned}</script><p>由此$p_{\{h\}}=\operatorname{Pr}\left(S_j=h \mid S_i=h\right)=0.764$，$p_{\{l\}}=\operatorname{Pr}\left(S_j=h \mid S_i=l\right)=0.339$也是类似的算法。</p>
<p>根据上面这个计算，可以认为，一个自己持有高信号的实体，认为其他人也持有高信号的概率是0.764；而一个自己持有低信号的实体，认为其他人持有高信号的概率是0.339。</p>
<p>考虑实体$i=1$，假设实体2和3都说真话。假设$S_1=h$，即实体1真实的报告是$x_1=1,y_1=0.764$。则当实体1说真话时，对应着实体$j=2$的评分公式计算的期望分数应该是：</p>
<script type="math/tex; mode=display">
E\left[\ln \left(\frac{\bar{X}_{-12}}{\bar{Y}_{-12}}\right)+\bar{X}_{-12} \ln \left(\frac{0.764}{\bar{X}_{-12}}\right)+\left(1-\bar{X}_{-12}\right) \ln \left(\frac{1-0.764}{1-\bar{X}_{-12}}\right)\right]</script><p>该期望值是相对随机变量$\bar{X}_{-12}$和$\bar{Y}_{-12}$而言的。当概率$p_{\{h\}}=0.764$时，实体1会认为$\bar{x}_{-12}=(1+1)/3=2/3$且$\bar{y}_{-12}=0.764$，同时概率$1-p_{\{h\}}=0.236$，可得$\bar{x}_{-12}=(0+1)/3=1/3$且$\bar{y}_{-12}=p_{\{l\}}=0.339$。给定上述内容，我们可以得到期望信息分是$0.764ln(\frac{2/3}{0.764})+0.236ln(\frac{1/3}{0.339})=-0.108$，而期望预测分是$0.764((2/3)ln(\frac{0.764}{2/3})+(1/3)ln(\frac{0.236}{1/3}))+0.236((1/3)ln(\frac{0.764}{1/3})+(2/3)ln(\frac{0.236}{2/3})=-0.117$，由此可得期望分是-0.225。而当公式中的$j=3$时，用同样的方法计算得到的实体1说真话对应的分数是-0.450，因此BTS不满足个体理性。</p>
<p>如果实体1谎报，且$x_1=0$，而仍然报告$y_1=0.764$，则期望信息分（$j=2$）会是$E[ln(\frac{1-\bar{X}_{-13}}{\bar{Y}’_{-13}})]=0.764ln(\frac{1/3}{0.236})+0.236ln(\frac{2/3}{0.661})=0.266$，预测分是0.149，类似的，考虑$j=3$可得总期望分是0.298，也就是说实体1谎报更好。</p>
<p><strong>例</strong>2：（BTS且$n\rightarrow \infty$）考虑相同的先验但是数量更多的实体。在极限的情况下，关注实体1的信念，随机变量$\bar{X}_{-ij},\bar{Y}_{-ij},\bar{Y}’_{-ij}$以1的概率各自取值：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\bar{X}_{-1 j} & =\lim _{n \rightarrow \infty} \frac{1}{n}\left((n-2) p_{\{h\}}+1\right)=p_{\{h\}} \\
\bar{Y}_{-1 j} & =\lim _{n \rightarrow \infty}\left(\left(p_{\{h\}}^{(n-2) p_{\{h\}}}\right)\left(p_{\{l\}}^{(n-2)\left(1-p_{\{h\}}\right)}\right)\right)^{1 /(n-2)} \\
& =\left(p_{\{h\}}^{p_{\{h\}}}\right)\left(p_{\{l\}}^{1-p_{\{h\}}}\right)=0.631, \\
\bar{Y}_{-1 j}^{\prime} & =\left(1-p_{\{h\}}\right)^{p_{\{h\}}}\left(1-p_{\{l\}}\right)^{1-p_{\{h\}}}=0.301 .
\end{aligned}</script><p>如果实体1如实报告（$x_1=1,y_1=0.764$），则它的期望信息分是$ln(\frac{0.764}{0.631})=0.191$，期望预测分是$0.764ln(0.764/0.764)+(1-0.764)ln(\frac{1-0.764}{1-0.764})=0$，即总分0.191。谎报$x_1=0$则会得到期望信息分为-0.243。在这个例子中，$n$足够大，取极限时BTS是贝叶斯纳什激励相容的。</p>
<p>在证明了BTS中取值较小的$n$的激励调整和临时IR的失败后，我们还对其数字上的稳健性做了如下观察：</p>
<p><strong>定理</strong>3：对后验报告$y_i\in\lbrace0,1 \rbrace$而言BTS的分数是无界负数。</p>
<h2 id="Robust-Bayesian-Truth-Serum"><a href="#Robust-Bayesian-Truth-Serum" class="headerlink" title="Robust Bayesian Truth Serum"></a>Robust Bayesian Truth Serum</h2><p>在本节中，我们介绍了稳健贝叶斯真理血清（RBTS）。RBTS对于每一个$n\geq 3$来说都是激励相容的，事后个体理性的（意味着对于任何结果，没有实体的收益是负的），并且在数字上是稳健的。我们首先介绍正确计分规则（不太确定这里的proper怎么翻译）。</p>
<p><strong>正确计分规则</strong>是可以用于激励理性的实体如实宣称自己关于对未来事件的可能性的私人信念的函数。</p>
<p><strong>定义</strong>2：（二值计分规则）给定可能的结果$\Omega=\{0,1\}$和关于结果$\omega=1$的概率的报告$y\in[0,1]$，一个二值计分规则$R(y,\omega)$根据报告$y$和发生的结果$\omega$分配一个分数。</p>
<p>首先，实体需要回答自己的信念报告$y\in[0,1]$。其次，事件$\omega\in\{0,1\}$发生了（由机制来观察）。最后，实体收到报酬$R(y,\omega)$。</p>
<p><strong>定义</strong>3：（严格正确计分规则）如果一个二值计分规则能使得一个实体在如实报告自己信念$p\in[0,1]$时最大化自己的期望得分，则该规则是正确的。且如果一个实体仅在如实报告时才能最大化期望得分，则该规则是严格正确的。</p>
<p>一个严格正确计分规则的例子是二值二次函数计分规则$R_q$，经过归一化处理，给出的分数在0和1之间：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& R_q(y, \omega=1)=2 y-y^2 \\
& R_q(y, \omega=0)=1-y^2 .
\end{aligned}</script><p><strong>定理</strong>4：（例，Selten，1998）二值二次计分规则$R_q$是严格正确的。</p>
<p>请注意，如果人们对正确计分规则进行正负变换，该规则仍然是正确的。关于一般的适当得分规则的更详细讨论，我们参考Gneiting和Raftery（2007）的文章。</p>
<h3 id="The-RBTS-Mechanism"><a href="#The-RBTS-Mechanism" class="headerlink" title="The RBTS Mechanism"></a>The RBTS Mechanism</h3><p>首先，每一个实体$i$都需要提供两个报告：</p>
<ol>
<li>信息报告</li>
<li>预测报告</li>
</ol>
<p>在第二步，针对每个实体$i$，选择一个参考实体$j=i+1$（模数$n$，这里没看懂）和一个对等实体$k=i+2$（模数$n$）并计算</p>
<script type="math/tex; mode=display">
y_i^{\prime}=\left\{\begin{array}{lll}
y_j+\delta, & \text { if } & x_i=1 \\
y_j-\delta, & \text { if } & x_i=0
\end{array}\right.</script><p>其中$\delta=min(y_j,1-y_j)$。实体$i$的RBTS分数为：</p>
<script type="math/tex; mode=display">
u_i=\underbrace{R_q\left(y_i^{\prime}, x_k\right)}_{\text {information score }}+\underbrace{R_q\left(y_i, x_k\right)}_{\text {prediction score }}</script><p><strong>例</strong>3：（RBTS且$n=3$）我们使用和例1中一样的设定来解释RBTS，即$p_{\{h\}}=0.764,p_{\{l\}}=0.339$。此外，我们可以注意到$p_{\{h,h\}}=0.795$且$p_{\{l,h\}}=0.664$。考虑实体1的视角，令实体2和3扮演参考$j$和对等$k$的角色。假设实体2和3都说真话。首先解释$S_1=h,S_2=l,S_3=l$时的计算。如果实体1说真话，因为$y_2=0.339$且$\delta=0.339$，可得$y’=y_2+\delta=0.339+0.339=0.678$。因为$x_3=1$，实体1的信息分是$2y_1’-y_1’^2=2(0.678)-0.678^2=0.896$。因为$y_1=0.764$且$x_3=1$，预测分是$2(0.764)-0.764^2=0.944$。总分是1.84.</p>
<p>为了确定当$S_1=h$时实体1说真话是最优解，我们需要考虑期望得分，进而考虑实体2和3的信号的分布。针对预测报告，因为$R_q(y_1,x_3)$是严格正确的，所以一定是真实的。实体1的期望预测分是$0.764(2(0.764)-0.764^2)+0.236(2(0.236)-0.236^2)=0.820$。针对期望信息分，首先考虑如实报告$x_1=1$。在这种情况下，$y_1’$是由实体2的实际预测报告向上取整的，实体1的期望信息分是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \operatorname{Pr}\left(S_2=h \mid S_1=h\right) \\
& \quad\left[\quad \operatorname{Pr}\left(S_3=h \mid S_1=h, S_2=h\right) R_q(0.764+0.236,1)\right. \\
& \left.\quad+\operatorname{Pr}\left(S_3=l \mid S_1=h, S_2=h\right) R_q(0.764+0.236,0)\right] \\
& +\operatorname{Pr}\left(S_2=l \mid S_1=h\right) \\
& {\left[\quad \operatorname{Pr}\left(S_3=h \mid S_1=h, S_2=l\right) R_q(0.339+0.339,1)\right.} \\
& \left.\quad+\operatorname{Pr}\left(S_3=l \mid S_1=h, S_2=l\right) R_q(0.339+0.339,0)\right] \\
& =\quad p_{\{h\}}\left[p_{\{h, h\}}\left(2(1)-1^2\right)+\left(1-p_{\{h, h\}}\right)\left(1-1^2\right)\right] \\
& \quad+\left(1-p_{\{h\}}\right)\left[p_{\{h, l\}}\left(2(0.678)-0.678^2\right)\right. \\
& \left.+\left(1-p_{\{h, l\}}\right)\left(1-0.678^2\right)\right]=0.79 .
\end{aligned}</script><p>针对报告$x_1=0$，期望信息分是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& p_{\{h\}}\left[\quad p_{\{h, h\}} R_q(0.764-0.236,1)\right. \\
& \left.+\left(1-p_{\{h, h\}}\right) R_q(0.764-0.236,0)\right] \\
& +\left(1-p_{\{h\}}\right)\left[\quad p_{\{h, l\}} R_q(0.339-0.339,1)\right. \\
& \left.+\left(1-p_{\{h, l\}}\right) R_q(0.339-0.339,0)\right]=0.664 \\
&
\end{aligned}</script><p>实体1说真话时期望信息分最高。</p>
<p>注意，对于任意$n\geq 3$，RBTS是严格贝叶斯纳什激励相容且可接受先验的。我们会在下一部分证明这一点。</p>
<h2 id="IC（激励相容）"><a href="#IC（激励相容）" class="headerlink" title="IC（激励相容）"></a>IC（激励相容）</h2><p>在建立RBTS的激励相容性时，我们首先提出了一些技术性的定理。第一个定理还建立了随机相关性，因此，对于不同的信号观测，信号后验是不同的。然后，我们介绍了一个适当的评分规则，用于诱导信号而不是信念报告，并将其作为分析RBTS的基础部分。</p>
<p><strong>引理</strong>5：对于所有可接受先验，$1&gt;p_{\{h\}}&gt;Pr(S_j=h)&gt;p_{\{l\}}&gt;0$都成立。</p>
<p>证明：可接受先验的完全混合属性确保先验总是内部的，且$1&gt;p_{\{h\}}&gt;0$以及$1&gt;p_{\{l\}}&gt;0$。此外，如果$p_{\{h\}}&gt;Pr(S_j=h)$，则这意味着$Pr(S_j=h)&gt;p_{\{l\}}$，因为</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\operatorname{Pr}\left(S_j=h\right)=  p_{\{h\}} \operatorname{Pr}\left(S_i=h\right) +\operatorname{Pr}\left(S_j=h \mid S_i=l\right) \operatorname{Pr}\left(S_i=l\right) \\
&\Leftrightarrow \quad  \operatorname{Pr}\left(S_j=h\right)\left(1-p_{\{h\}}\right)=p_{\{l\}}\left(1-\operatorname{Pr}\left(S_j=h\right)\right) \\
&\underbrace{\Rightarrow}_{p_{\{h\}}>\operatorname{Pr}\left(S_j=h\right)}  \operatorname{Pr}\left(S_j=h\right)>p_{\{l\}} .
\end{aligned}</script><p>剩下的就是给定可接受先验的情况下证明$p_{\{h\}}&gt;Pr(S_j=h)$。证明的剩余部分由3步组成：</p>
<p>首先，将每一个状态与$H$和$L$这两个组中的一个联系起来。</p>
<h3 id="A-Proper-Scoring-Rule-for-Eliciting-Signals-The-“Shadowing”-Method"><a href="#A-Proper-Scoring-Rule-for-Eliciting-Signals-The-“Shadowing”-Method" class="headerlink" title="A Proper Scoring Rule for Eliciting Signals: The “Shadowing” Method"></a>A Proper Scoring Rule for Eliciting Signals: The “Shadowing” Method</h3><h2 id="Other-Properties-and-Discussion"><a href="#Other-Properties-and-Discussion" class="headerlink" title="Other Properties and Discussion"></a>Other Properties and Discussion</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>trustworthiness</tag>
        <tag>BTS</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Peer Prediction-Based Trustworthiness Evaluation and Trustworthy Service Rating in Social Networks</title>
    <url>/2022/11/10/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Peer%20Prediction-Based%20Trustworthiness%20Evaluation%20and%20Trustworthy%20Service%20Rating%20in%20Social%20Networks/</url>
    <content><![CDATA[<h1 id="Peer-Prediction-Based-Trustworthiness-Evaluation-and-Trustworthy-Service-Rating-in-Social-Networks"><a href="#Peer-Prediction-Based-Trustworthiness-Evaluation-and-Trustworthy-Service-Rating-in-Social-Networks" class="headerlink" title="Peer Prediction-Based Trustworthiness Evaluation and Trustworthy Service Rating in Social Networks"></a>Peer Prediction-Based Trustworthiness Evaluation and Trustworthy Service Rating in Social Networks</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>随着基于社交网络的在线应用的发展，出现了许多不同的方法来评估这些应用所提供的服务。终端用户就消费者的体验或意见所做的报告通常被用来评价不同的在线服务的质量。因此，确保用户报告的真实性，以及检测恶意用户的不诚实报告，都成为实现此类服务评级准确性的重要问题。在本文中，我们提出并评估了一个基于私人先验的同伴预测的可信服务评级系统，该系统要求用户报告他们对其同伴是否会报告高质量的服务意见的先验和后验信念。这些报告被送到一个数据处理中心，该中心通过应用严格恰当的评分规则来评估用户的可信度，并删除从可信度等级低的用户那里收到的报告。这种同行预测方法与激励用户诚实报告的激励措施相兼容。此外，还提出了一个不可靠指数，以识别恶意用户，以及在对质量进行判断时有高错误率的故障或不可靠的用户。因此，具有高不可靠值的报告也将被排除在服务评级系统之外。通过结合可信度和不可靠度，恶意用户面临的困境是，当他们的报告是虚假的，他们不能同时获得高可信度和低不可靠度的评级。仿真结果表明，所提出的基于同伴预测的可信服务评级能够有效地识别恶意行为和不可靠行为，并激励用户如实报告，而且所提出的系统能够达到比较高的服务评级准确率。</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>研究背景：</p>
<ol>
<li>互联网服务发展很好</li>
<li>对互联网服务进行质量评级是一种常用的帮助用户进行选择的方法</li>
<li>现阶段质量评级的公平性和实用性受恶意用户的影响很大，有必要进行信任评估并激励用户输出真实反馈</li>
</ol>
<p>本文：基于对等预测的社会网络可信服务评级系统<br>假设：服务质量是一个独立于用户主观判断的客观评价</p>
<h3 id="相关研究"><a href="#相关研究" class="headerlink" title="相关研究"></a>相关研究</h3><p>略</p>
<h3 id="贡献与组织"><a href="#贡献与组织" class="headerlink" title="贡献与组织"></a>贡献与组织</h3><p>贡献：</p>
<ol>
<li>我们在社交网络的服务评级系统中引入了私有先验对等预测。通过某些严格恰当的打分规则获得的用户信任度被制定出来，以激励用户如实地报告。我们分析了基本对等预测机制在判断和报告的误报和漏报概率方面的激励兼容性。</li>
<li>我们提出了一个不可靠指数来消除服务评级系统中不可靠的报告。通过应用不可靠指数，恶意用户面临着一个困境，即他们在提供虚假报告时不能同时获得高可信度和低不可靠度。然而，诚实的用户的最佳选择仍然是如实报告，即使是功能差的，判断错误率高的。</li>
<li>基于提出的用户可信度和不可靠指数，我们设计了一个服务评级框架。在这个框架中，信任度被用来评估主体用户的报告是否不诚实，用户是否是恶意的。另一方面，不可靠指数被引入以确定报告是否可靠，但不考虑用户的类型，即诚实或恶意。通过从最终的评级程序中去除不可靠度高的反馈报告和从可信度低的用户那里收到的报告，可以实现准确和可信的服务评级。</li>
</ol>
<h2 id="基于用户报告融合的服务评级的数学模型"><a href="#基于用户报告融合的服务评级的数学模型" class="headerlink" title="基于用户报告融合的服务评级的数学模型"></a>基于用户报告融合的服务评级的数学模型</h2><p>重复了intro中的内容，表示本文设计了这样那样的机制</p>
<h3 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h3><p>场景：$N$个用户分布在社交网络中，共用一个服务平台。服务质量$Q$是一个二元评价，低质量和高质量分别用$\lbrace l,h\rbrace$表示，且服务质量是一个客观事实，即所有诚实的用户会给出相同的评价，而不受他们个人主观标准的影响。如图1所示，每个用户$i$收到服务$m$，然后决定他们对$m$的质量评价记作$S_i=s_i\in\lbrace l,h \rbrace$。用户同样会把服务评级上报到云，这些数据会有数据处理中心（DPC）处理。例如，意见报告$x_i\in \lbrace 0,1 \rbrace$是通过应用报告策略$r_i:S_i\rightarrow \lbrace 0,1 \rbrace$生成的。如果用户是诚实的，则当$S_i=h$时，用户$i$会向云报告$x_i=1$，当$S_i=l$时，用户会报告$x_i=0$。我们假设$x_i$是云发布到社会服务评估平台半公开信息，并且可以被与用户$i$有着好友关系的DPC和其他用户通过社交网络观察到。此外，$S_i$是只有用户$i$知道的私有或本地信息，其他用户甚至云都无法得到它。</p>
<p><img src="https://github.com/likun1208/image/blob/master/PeerPrediction-1.png?raw=true" alt="图1"></p>
<h3 id="基于用户报告融合的服务评级"><a href="#基于用户报告融合的服务评级" class="headerlink" title="基于用户报告融合的服务评级"></a>基于用户报告融合的服务评级</h3><p>判断的错误：实际是高质量的服务被错误的判定为低质量</p>
<p>用户$i$判断错误的概率：$P_{fa,i}=P(S_i=l|Q=h)$，简化记作$P_{fa}$.</p>
<p>判断的漏检：实际是低质量的服务被认为是高质量</p>
<p>判断漏检的概率：$P_{md,i}=P(S_i=h|Q=l)$，简化记作$P_{md}$</p>
<p>如前所述，质量是一个客观事实，因此诚实和恶意用户对它的判断都是相似的。因此我们假设判断错误和漏检的概率都小于0.5（就是说判断与实际不符的概率比随便猜一个要低）。</p>
<p>报告的错误：实际是高质量的服务被错误的报告为低质量（也许是判断错了，也许是故意的）</p>
<p>报告错误的概率：$P_{f,i}=P(x_i=0|Q=h)$，简化记作$P_f$</p>
<p>报告的漏检：实际是低质量的服务被错误地报告为高质量（同样，也许是判断错了，也许是故意的）</p>
<p>报告漏检的概率：$P_{m,i}=P(x_i=1|Q=l)$，简化记作$P_m$</p>
<p>用户类型$\theta_i \in \lbrace 0,1 \rbrace$，0表示诚实，1表示恶意，恶意用户的判断是高但故意报告低的概率为$P_{f,i}^c\in[0,1]$，判断是低但故意报告高的概率为$P_{m,i}^c\in [0,1]$</p>
<p>假设：无论判断准确率如何，诚实用户永远如实报告</p>
<p>对于任意用户$i$，可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
P_{f, i} &=\left\{\begin{array}{ll}
\left(1-P_{f a, i}\right) P_{f, i}^{c}+P_{f a, i}\left(1-P_{f, i}^{c}\right), & \theta_{i}=1 ; \\
P_{f a, i}, & \theta_{i}=0 ;
\end{array}\right.\\
P_{m, i} &=\left\{\begin{array}{ll}
\left(1-P_{m d, i}\right) P_{m, i}^{c}+P_{m d, i}\left(1-P_{m, i}^{c}\right), & \theta_{i}=1 ; \\
P_{m d, i}, & \theta_{i}=0 .
\end{array}\right.
\end{aligned}</script><p>这里简单描述一下就是说，诚实用户的报告与实际不符的概率和他判断出错的概率一致，而恶意用户的报告与实际不符的概率则分为两部分：判断没出错但上报的时候故意骗人+判断出错了但上报的时候没骗人。</p>
<p>根据云收到的用户报告，DPC可以获得每个用户的可信度$T_i$，并通过应用以下规则做出服务评级的决定：</p>
<script type="math/tex; mode=display">
R=\sum_{i \in T} x_{i}\left\{\begin{array}{ll}
<n, & \text { the DPC rates the service } Q=l \\
\geq n, & \text { the DPC rates the service } Q=h
\end{array}\right.</script><p>其中$n$是服务评级阈值。说人话就是大家总分达标就把服务判定为高质量，否则是低质量。公式中的$T$表示高可信的诚实用户集合。</p>
<h2 id="对等预测"><a href="#对等预测" class="headerlink" title="对等预测"></a>对等预测</h2><p>这一部分具体介绍私有先验对等预测机制，以及可信度的计算。</p>
<h3 id="私有先验对等预测机制"><a href="#私有先验对等预测机制" class="headerlink" title="私有先验对等预测机制"></a>私有先验对等预测机制</h3><p>私有先验对等预测是一种激励相容的机制，最初是为了激励代理人报告他们关于电子商务的私人先验和后验信号信念。在基础的私有先验对等预测机制中，每个代理$i$都和他的同行代理$j=i+1$成为一组，并被要求分别报告自己在观察信号前后的针对状态的先验和后验信号信念。根据两份报告，代理$i$的分数可以根据严格正确计分规则来计算。</p>
<ol>
<li><p>发给云的先验信念报告：在本研究所建立的系统中，任意两个收到相同服务的用户可以被看做是一对对等用户，由此建立了一种用户之间的关系和拓扑结构。为了对服务$m$的质量进行评级，我们认为每个用户$i$都有从其他收到相同服务$m$并将继续使用该服务的用户中随机选择的对等用户$j$。在体验服务之前，用户$i$需要向云上报他对于同事$j$会上报高质量信号即$x_j=1$的先验信念$y_{ij}\in[0,1]$，这个上报也可以称之为信息报告。则$y_{ij}$的计算方式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
y_{i j}=& P_{i}\left(x_{j}=1\right) \\
=& P_{i}\left(x_{j}=1 \mid Q=h\right) P_{i}(Q=h) \\
&+P_{i}\left(x_{j}=1 \mid Q=l\right) P_{i}(Q=l) \\
\triangleq & P\left(x_{j}=1 \mid S_{i}=h\right) P\left(S_{i}=h\right) \\
&+P\left(x_{j}=1 \mid S_{i}=l\right) P\left(S_{i}=l\right)
\end{aligned}</script><p>其中，$P_{i}\left(x_{j}=1 \mid Q=h\right)$和$P_{i}\left(x_{j}=1 \mid Q=l\right)$可以从用户$j$在网络中之前发布过的报告$x_j$中获取。前者表示当用户$i$判断服务质量为高质量（即$S_i=h$）时用户$j$提交的报告也说服务是高质量。用户$i$的判断是私有信息，只有他自己知道，而先验信念$P_i(Q=h)$是用户$i$对服务质量的主观先验，与$P(S_i=h)$相同。类似地，$P_i(Q=l)$也等于$P(S_i=l)$。因此，我们可以得到上面公式中用$\triangleq$相连的等式。</p>
</li>
<li><p>发给云的后验信念报告：体验过服务后，用户$i$决定他自己对服务质量的判断$S_i=s_i$，然后将他关于对等用户$j$会上报该服务的质量评估为高质量这件事的后验信念（或称之为预测报告）发送给云，记作$y_{ij}^{‘}(s_i)\in[0,1]$。则$y_{ij}^{‘}$可以表示如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
y_{i j}^{\prime}\left(s_{i}\right)=& P_{i}\left(x_{j}=1 \mid S_{i}=s_{i}\right) \\
=& P\left(x_{j}=1 \mid Q=h\right) P\left(Q=h \mid S_{i}=s_{i}\right) \\
&+P\left(x_{j}=1 \mid Q=l\right) P\left(Q=l \mid S_{i}=s_{i}\right) .
\end{aligned}</script><p>与前文分析类似，$y_{ij}^{‘}$可以被分为以下两种情况：</p>
<script type="math/tex; mode=display">
\begin{aligned}
y_{i j}^{\prime}(l) &=\frac{\varphi_{1}\left(1-P_{f, j}\right)+\varphi_{2} P_{m, j}}{\varphi_{1}+\varphi_{2}} \\
y_{i j}^{\prime}(h) &=\frac{\varphi_{3}\left(1-P_{f, j}\right)+\varphi_{4} P_{m, j}}{\varphi_{3}+\varphi_{4}}
\end{aligned}</script><p>其中，</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\varphi_{1}=P_{f a, i} P(Q=h), \quad \varphi_{2}=\left(1-P_{m d, i}\right) P(Q=l), \\
\varphi_{3}=\left(1-P_{f a, i}\right) P(Q=h), \quad \varphi_{4}=P_{m d, i} P(Q=l)
\end{array}</script><p>$\varphi_1$是服务为高质量且用户$i$出现误报的概率，$\varphi_2$是服务为低质量且用户$i$没有漏检的概率，加起来就是用户$i$给出的判断是低质量的概率。</p>
</li>
</ol>
<p>类似地，$\varphi_3$是服务为高质量且用户$i$没有误报的概率，$\varphi_4$是服务为低质量且用户$i$漏检的概率，加起来就是用户$i$给出的判断是高质量的概率。</p>
<script type="math/tex; mode=display">
\begin{align}
y_{ij}^{'}(l)&= P\left(x_{j}=1 \mid Q=h\right) P\left(Q=h \mid S_{i}=l\right)+P\left(x_{j}=1 \mid Q=l\right) P\left(Q=l \mid S_{i}=l\right)\\
&=(1-P_{f,j})P(Q=h|S_i=l)+P_{m,j}P(Q=l|S_i=l)\\
&=P(S_i=l|Q=h)P(Q=h)(1-P_{f,j})/P(S_i=l)+P(S_i=l|Q=l)P(Q=l)P_{m,j}/P(S_i=l)\\
&=P_{fa,i}P(Q=h)(1-P_{f,j})/P(S_i=l)+(1-P_{md,i})P(Q=l)P_{m,j}/P(S_i=l)\\
&=\varphi_1(1-P_{f,j})/(\varphi_1+\varphi_2)+\varphi_2P_{m,j}/(\varphi_1+\varphi_2)\\
&=\frac{\varphi_1(1-P_{f,j})+\varphi_2P_{m,j}}{\varphi_1+\varphi_2}
\end{align}</script><p>$y_{ij}^{‘}(h)$也是类似的计算方法，就不写了。</p>
<p>如前文定义，$x_{ij}$是用户$i$在体验服务之前对$x_j=1$的先验判断。在用户$i$体验服务并发送报告$s_i=h$后，他理所当然有很大概率会判断$x_j=1$，即$y_{ij}^{‘}(h)&gt;y_{ij}$，这意味着用户$i$对$x_j=1$的先验信念会被提高。与之相反，如果用户$i$收到了低质量服务，则$y_{ij}&gt;y_{ij}^{‘}(l)$。但是，当存在会提供不真实的服务评价的恶意用户时，上述不等式的关系将不再成立。引理1证明了会使得$y_{i j}^{\prime}(h)&gt;y_{i j}&gt;y_{i j}^{\prime}(l)$出现的充分条件。</p>
<p>引理1：在私有先验预测机制中，对于每个用户$i$，他对用户$j$的先验和后验信念报告分别是$y_{ij}$和$y^{‘}_{ij}$，当所有用户都满足$P_{fa}+P_{md}<1$且$P_f+P_m<1$时，$y_{i j}^{\prime}(h)>y_{i j}&gt;y_{i j}^{\prime}(l)$成立。</p>
<p>证明：在附录，先不看了</p>
<p>备注：假设$P_{fa}<0.5$且$P_{md}<0.5$，对于所有用户而言，$P_{fa}+P_{md}<1$都成立。根据公式1和2，对于诚实用户即$\theta_i=0$，我们可得$P_{f,i}+P_{m,i}<1$.另一方面，对于不诚实用户（$\theta_i=1$），$P_{f,i}+P_{m,i}<1$能否成立取决于他的两个谎报概率$P_{f,i}^c$和$P_{m,i}^c$。有着相对高的$P_f^c>0.5$且/或$P_m^c$的彻底的恶意用户会同样有高$P_f&gt;0.5$且/或$P_m&gt;0.5$。有上述两种或两种之一作弊行为的用户可以根据他们以前的报告很容易被识别出来，因为其中的错误报告概率很高。如果评分系统移除有着较高的$P_f$和/或$P_m$的用户报告，则这些恶意报告就不会在系统更新服务评价时造成影响。因此，要实现连续的欺骗，恶意用户需要控制他们的$P_f^c$和$P_m^c$，从而伪装成偶尔可信的用户，以确保$P_f<0.5$且$P_m<0.5$。因此，引理1中的条件$P_f+P_m<1$是合理的，且这种情况下，不等式$y_{i j}^{\prime}(h)>y_{i j}&gt;y_{i j}^{\prime}(l)$始终成立。</p>
<ol>
<li><p>推断意见报告：用户$i$发送他对同事$j$会报告$x_j=1$这件事的先验和后验信念概率，而不是报告自己对服务质量的私有评价$S_i$或$x_i$。我们可以注意到，$x_i$和$x_j$都不由相关用户直接提供。在基础私有先验对等预测中，用户$i$仅向云发送报告$y_{ij}$和$y_{ij}^{‘}(s_i)$，基于此，DPC推断意见报告$x_i$并将它向社交服务评估平台公布。推断意见报告$x_i$的计算方式如下：</p>
<script type="math/tex; mode=display">
x_{i}=x\left(y_{i j}, y_{i j}^{\prime}\right)=\left\{\begin{array}{ll}
1, & y_{i j}^{\prime}>y_{i j} \\
0, & y_{i j}^{\prime}<y_{i j}
\end{array}\right.</script><p>备注：根据引理1，当用户$i$和用户$j$都满足$P_{fa}+P_{md}<1$且$P_f+P_m<1$时，$y_{ij}^{'}(h)>y_{ij}>y_{ij}^{'}(l)$。换言之，当用户$i$在体验服务后对它的质量判断为高质量（$S_i=h$），不等式$y_{ij}^{'}(h)$始终成立。由此，根据公式8，DPC推断意见报告为$x_i=1$因为$y_{ij}^{'}>y_{ij}$。因此这个推断报告$x_i=1$与用户$i$的真实判断$S_i=h$是一致的。对称地，当$S_i=l$时，公式8仍然可以推断真实意见报告$x_i=0$。因此，在$P_{fa}+P_{md}&lt;1$和$P_f+P_m&lt;1$的条件下，由公式8所决定的规则可以如实反映诚实用户的判断。</p>
</li>
<li><p>用户可信度：基于报告$y_{ij}$和$y_{ij}^{‘}$，DPC通过一个确定的计分规则来计算用户$i$的可信度，信任度低的用户被归类为恶意用户，他们的报告将在服务评级系统中不被考虑。接下来，我们首先介绍严格正确的计分规则，它可以激励用户提供真实的报告$y_{ij}$和$y_{ij}^{‘}$。</p>
</li>
</ol>
<p>定义1（严格正确的计分规则）：如果一个二进制评分规则导致代理人可以通过如实提供自己的报告$y\in[0,1]$来最大化自己的得分，则该规则就是正确的，且如果一个代理人当且仅当如实报告时能最大化得分，则该规则是严格正确的。</p>
<p>分别如(9)和(10)所示的二元对数和二次函数评分规则是严格正确的，这在[30]中已经得到证明：</p>
<p>对数：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
R_{l}(y, \omega=1)=\ln y \\
R_{l}(y, \omega=0)=\ln (1-y) .
\end{array}</script><p>二次函数：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
R_{q}(y, \omega=1)=2 y-y^{2} \\
R_{q}(y, \omega=0)=1-y^{2}
\end{array}</script><p>在上面两组公式中，$\omega\in\lbrace 0,1\rbrace$表示一个二值报告。</p>
<p>我们定义用户$i$的可信度为关于$y_{ij},y_{ij}^{‘},x_j$的函数：</p>
<script type="math/tex; mode=display">
T_{i}=\alpha R\left(y_{i j}, x_{j}\right)+(1-\alpha) R\left(y_{i j}^{\prime}, x_{j}\right)+\beta</script><p> 其中，$R(y,\omega)$是严格正确评分规则，$\alpha\in[0,1]$是先验和后验重要性的权重参数。此外，可信度在服务和评分过程中会进行累积。负面的信任度可以是金钱上的惩罚，也可以是对相应用户提供报告的限制，而负面的收益将作为正面的收益转移给用户，作为对他们荣誉和准确报告的奖励。因此，为了保证预算均衡，$\beta$如下计算：</p>
<script type="math/tex; mode=display">
 \beta=-\frac{1}{N} \sum_{k=1}^{N}\left[\alpha R\left(y_{k j}, x_{j}\right)+(1-\alpha) R\left(y_{k j}^{\prime}, x_{j}\right)\right]</script><p>在公式11（$T_i$的公式）中，$y_{ij}$和$y_{ij}^{‘}$分别是用户$i$判定$S_i=s_i$前后的报告，$x_j$是DPC根据用户$j$的报告推断出的用户$j$的隐性意见报告。此外，根据上述分析，我们可以注意到，用户$i$的可信度是由用户$j$的推断意见报告$x_j$、用户$i$的先验信念报告$y_{ij}$和后验信念报告$y_{ij}^{‘}$决定的。换句话说，一个用户的可信度与系统中其他用户的报告或推断的报告无关。因此，恶意用户的合作作弊对用户可信度的评价影响不大，这是由（11）定义的。</p>
<h3 id="激励相容"><a href="#激励相容" class="headerlink" title="激励相容"></a>激励相容</h3><p>如[33]所说，用户$i$提出的先验信念报告$y_{ij}$和后验信念报告$y_{ij}^{‘}(s_i)$在时间上是分离的，因为它们分别发生在做出判断$S_i=s_i$前后。因此，$y_{ij}$和$y_{ij}^{‘}(s_i)$是独立的，可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left[T_{i}\right]=& E\left[\alpha R\left(y_{i j}, x_{j}\right)\right]+E\left[(1-\alpha) R\left(y_{i j}^{\prime}, x_{j}\right)\right]+E[\beta] \\
=& \alpha\left(1-\frac{1}{N}\right) E\left[R\left(y_{i j}, x_{j}\right)\right] \\
&+(1-\alpha)\left(1-\frac{1}{N}\right) E\left[R\left(y_{i j}^{\prime}, x_{j}\right) \mid S_{i}=s_{i}\right] \\
&-\frac{1}{N} \sum_{k=1, k \neq i}^{N}\left[\alpha R\left(y_{k j}, x_{j}\right)+(1-\alpha) R\left(y_{k j}^{\prime}, x_{j}\right)\right],
\end{aligned}</script><p>其中，$\alpha\left(1-\frac{1}{N}\right) R\left(y_{i j}, x_{j}\right)$和$(1-\alpha)\left(1-\frac{1}{N}\right) R\left(y_{i j}^{\prime}, x_{j}\right)$仍然是严格正确的[32]。</p>
<ol>
<li><p>二值对数评分规则<br>令$p_1=P(x_j=1)$且$p_2=P(x_j=1|S_i=s_i)$，由此可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left[T_{i}\right]=& \alpha\left(1-\frac{1}{N}\right)\left[p_{1} \ln y_{i j}+\left(1-p_{1}\right) \ln \left(1-y_{i j}\right)\right] \\
=& \alpha\left(1-\frac{1}{N}\right)\left[p_{1} \ln y_{i j}^{\prime}+\left(1-p_{1}\right) \ln \left(1-y_{i j}^{\prime}\right)\right] \\
&-\frac{1}{N} \sum_{k=1, k \neq i}^{N}\left[\alpha R\left(y_{k j}, x_{j}\right)+(1-\alpha) R\left(y_{k j}^{\prime}, x_{j}\right)\right] .
\end{aligned}</script><p>分别求偏导：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\frac{\partial E\left[T_{i}\right]}{\partial y_{i j}}=\alpha\left(1-\frac{1}{N}\right) \frac{p_{1}-y_{i j}}{y_{i j}\left(1-y_{i j}\right)}=0 \\
\frac{\partial E\left[T_{i}\right]}{\partial y_{i j}^{\prime}}=\alpha\left(1-\frac{1}{N}\right) \frac{p_{1}-y_{i j}^{\prime}}{y_{i j}^{\prime}\left(1-y_{i j}^{\prime}\right)}=0 .
\end{array}</script><p>因此可得最优值：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\hat{y}_{i j}=p_{1}=P\left(x_{j}=1\right) \\
\hat{y}_{i j}^{\prime}=p_{2}=P\left(x_{j}=1 \mid S_{i}=s_{i}\right)
\end{array}</script><p>然后求二阶偏导，令$y_{ij}=\hat{y}_{ij}$且$y_{ij}^{‘}=\hat{y}_{ij}^{‘}$，可得：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\left.\frac{\partial E^{2}\left[T_{i}\right]}{\partial y_{i j}^{2}}\right|_{y_{i j}=\hat{y}_{i j}}=\alpha\left(1-\frac{1}{N}\right) \frac{y_{i j}\left(y_{i j}-1\right)}{y_{i j}^{2}\left(1-y_{i j}\right)^{2}}<0, \\
\left.\frac{\partial E^{2}\left[T_{i}\right]}{\partial y_{i j}^{\prime 2}}\right|_{y_{i j}^{\prime}=\hat{y}_{i j}^{\prime}}=\alpha\left(1-\frac{1}{N}\right) \frac{y_{i j}^{\prime}\left(y_{i j}^{\prime}-1\right)}{y_{i j}^{\prime 2}\left(1-y_{i j}^{\prime}\right)^{2}}<0 .
\end{array}</script><p>因此，当$y_{ij}=p_1$且$y_{ij}^{‘}=p_2$时，$E[T_i]$可达到最大值，这意味着当且仅当用户$i$如实报告$y_{ij}$和$y_{ij}^{‘}$时他可以获取最大的可信度。</p>
</li>
<li><p>二值二次函数评分规则：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left[T_{i}\right] \\
=& \alpha\left(1-\frac{1}{N}\right)\left[p_{1}\left(2 y_{i j}-y_{i j}^{2}\right)+\left(1-p_{1}\right)\left(1-y_{i j}^{2}\right)\right] \\
&+(1-\alpha)\left(1-\frac{1}{N}\right)\left[p_{2}\left(2 y_{i j}^{\prime}-y_{i j}^{\prime}{ }^{2}\right)+\left(1-p_{2}\right)\left(1-y_{i j}^{\prime}{ }^{2}\right)\right] \\
&-\frac{1}{N} \sum_{k=1, k \neq i}^{N}\left[\alpha R\left(y_{k j}, x_{j}\right)+(1-\alpha) R\left(y_{k j}^{\prime}, x_{j}\right)\right] .
\end{aligned}</script><p>仍然是求偏导，可以得到和对数函数一样的最优值。然后求二阶偏导，可得下述不等式恒成立：</p>
<script type="math/tex; mode=display">
\frac{\partial E^{2}\left[T_{i}\right]}{\partial y_{i j}^{2}}=\frac{\partial E^{2}\left[T_{i}\right]}{\partial y_{i j}^{\prime 2}}=-2 \alpha\left(1-\frac{1}{N}\right)<0</script></li>
</ol>
<p>备注：无论是二值对数还是二值二次函数评分规则，$\partial^{2} E\left[T_{i}\right] / \partial y_{i j}^{2}&lt;0$和$\partial^{2} E\left[T_{i}\right] / \partial {y^{‘}_{i j}}^{2}<0$都成立，$E[T_i]$会在两个一阶导得到的最优值满足时取最大值。换言之，用户$i$当且仅当如实报告$y_{ij}$和$y_{ij}^{'}$时他可以获取最大的可信度。假设存在共谋，这意味着恶意用户可以相互联系并控制恶意行为。根据定义1，当对等用户$j$是恶意用户时，用户$i$谎报时得到的分数会比如实报告的分数低。例如，用户$i$体验了一个高质量任务，这意味着他的诚实报告满足$y_{ij}^{'}>y_{ij}$。但是，由于用户$j$是恶意的，他会谎报意见，即$x_j=0$，根据二值对数和二次函数评分规则，与如实报告相比，给出一个更低的$y_{ij}^{‘}&lt;y_{ij}$会使得用户$i$得到更高的评分。为了确保即使在社会网络中发生合作欺骗行为时，诚实的用户仍占主导地位，我们假设恶意用户的数量少于总数的一半。基于这个假设，拥有准确信息报告和预测报告的用户将长期获得更高的信任度；同时，恶意用户每次公布不诚实的报告导致作弊的意见报告时，都会受到信任度下降的惩罚。</p>
<p>感觉这篇文章和贝叶斯实话血清那个相似的地方就在于这里的评分函数形式。</p>
<h2 id="基于用户可信度和不可靠度的服务评级"><a href="#基于用户可信度和不可靠度的服务评级" class="headerlink" title="基于用户可信度和不可靠度的服务评级"></a>基于用户可信度和不可靠度的服务评级</h2><h3 id="用户报告的不可靠度"><a href="#用户报告的不可靠度" class="headerlink" title="用户报告的不可靠度"></a>用户报告的不可靠度</h3><p>在私有先验对等预测中，所有用户在体验服务之前都被要求报告他们关于对等用户会报告高质量的先验信念$y_{ij}=P_i(x_j=1)$。DPC可以从过去的报告$x_j$中推断出该报告，并由云发布，这意味着过去的报告$x_j$可以被$i$在社交网络中的其他好友、云和DPC获取。因此，对于恶意用户来说伪造信息报告$y_{ij}$是困难的。为了实现欺骗，恶意用户$i$需要控制他的信息并根据前文的公式预测报告，即当服务质量为低（$Q=l$）时有概率$p_{m,i}^{c}$会出现$y^{‘}_{ij}=y_{ij}+\varepsilon(\varepsilon&gt;0)$，当服务质量为高（$Q=h$）时有概率$P_{f,i}^{c}$出现$y^{‘}_{ij}=y_{ij}-\varepsilon$。同时，恶意用户需要让$\varepsilon$尽可能小，从而避免当他们的对等用户是诚实用户时自己要因为大量损失评分和可信度而受到惩罚。此外，我们可以注意到误报和漏检并不一定来自于诚实用户的错误判断，同样也来自不诚实用户的欺骗行为。上述两种情况都被认为是不可靠的行为，需要在最终的服务评级中加以识别和删除。因此，有必要设置阈值来限制$y_{ij}$和$y_{ij}^{‘}$之间的最小值。</p>
<p>接下来，我们分析了误报判断和漏检判断对分数的影响。分别对前文公式中的$P_{fa,i}$和$P_{md,i}$求导，可得：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\frac{\partial y_{i j}^{\prime}(l)}{\partial P_{f a, i}}=\Phi_{1}\left(1-P_{m d, i}\right)\left(1-P_{f, j}-P_{m, j}\right) \\
\frac{\partial y_{i j}^{\prime}(l)}{\partial P_{m d, i}}=\Phi_{1} P_{f a, i}\left(1-P_{f, j}-P_{m, j}\right) \\
\frac{\partial y_{i j}^{\prime}(h)}{\partial P_{f a, i}}=-\Phi_{2} P_{m d, i}\left(1-P_{f, j}-P_{m, j}\right) \\
\frac{\partial y_{i j}^{\prime}(h)}{\partial P_{m d, i}}=-\Phi_{2}\left(1-P_{f a, i}\right)\left(1-P_{f, j}-P_{m, j}\right)
\end{array}</script><p>其中，$\Phi_1=P(Q=h)P(Q=l)/(\phi_1+\phi_2)^2,\Phi_2=P(Q=h)P(Q=l)/(\phi_3+\phi_4)^2$。基于前文假设$P_{fa,i}&lt;0.5,P_{md,i}&lt;0.5,P_{f,j}+P_{m,j}&lt;1$，可得：</p>
<script type="math/tex; mode=display">
\frac{\partial y_{i j}^{\prime}(l)}{\partial P_{f a, i}}>\frac{\partial y_{i j}^{\prime}(l)}{\partial P_{m d, i}}>0, \quad \frac{\partial y_{i j}^{\prime}(h)}{\partial P_{m d, i}}<\frac{\partial y_{i j}^{\prime}(h)}{\partial P_{f a, i}}<0</script><p>因此，在$Q=h$和$Q=l$这两种情况下，当用户$j$如实报告时，用户$i$的分数会随着$P_{fa,i}$和$P_{md,i}$的增加而减少。换言之，对于固定的$P_f,P_j,P(Q=h)$，判断准确率高的诚实用户将获得更高的分数和可信度，相比之下，那些判断错误率高的诚实用户和恶意用户则反过来保守地报告他们的预测，给出错误的报告，将分数的损失降到最低。在服务评级系统中，既不应该考虑恶意用户的隐性意见报告，也不应该考虑判断准确性低的诚实用户。为了识别出这两种不可靠的行为，我们通过用户$i$的先验信念报告$y_{ij}$和后验信念报告$y_{ij}^{‘}$定义了不可靠指数来表征用户$i$的不可靠度：</p>
<script type="math/tex; mode=display">
\rho_{i}=\left\{\begin{array}{ll}
\frac{\left|y_{i j}^{\prime}-P_{m, j}\right| P(Q=l)}{\left|y_{i j}^{\prime}-\left(1-P_{f, j}\right)\right| P(Q=h)} & y_{i j}^{\prime}<y_{i j} \\
\frac{\left|y_{i j}^{\prime}-\left(1-P_{f, j}\right)\right| P(Q=h)}{\left|y_{i j}^{\prime}-P_{m, j}\right| P(Q=l)}, & y_{i j}^{\prime}>y_{i j}
\end{array}\right.</script><p>备注：在上面的公式中，第一种情况$y_{ij}^{‘}<y_{ij}$表示，服务为低质量时$y_{ij}^{'}$越接近$P\lbrace x_j=1|Q=l \rbrace$，或者服务为高质量时$y_{ij}^{'}$越远离$P\lbrace x_j=1|Q=h \rbrace$，则$y_{ij}^{'}$越可靠。同时，对于$y_{ij}^{'}>y_{ij}$，当报告$y_{ij}^{‘}$接近$P\lbrace x_j=1|Q=h \rbrace$且远离$P\lbrace x_j=1|Q=l \rbrace$，该报告可以被认为是可靠的。此外，根据该公式，$y_{ij}^{‘}(l)$会随$P_{fa,i}$和$P_{md,i}$的增长而增加，且对$P_{fa,i}$比$P_{md,i}$更敏感。$y_{ij}^{‘}(h)$随$P_{fa,i}$和$P_{md,i}$的增长而减少，且对$P_{md,i}$比$P_{fa,i}$更敏感。假设$P_{fa,i},P_{md,i}\in [0,1]$，我们可得$P_{m, j}&lt;y_{i j}^{\prime}(l), y_{i j}^{\prime}(h)&lt;1-P_{f, j}$，因此上面公式中关于不可靠度的定义可以改写为：</p>
<script type="math/tex; mode=display">
\rho_{i}=\left\{\begin{array}{cl}
\frac{\left[y_{i j}^{\prime}-P_{m, j}\right] P(Q=l)}{\left[\left(1-P_{f, j}\right)-y_{i j}^{\prime}\right] P(Q=h)} & y_{i j}^{\prime}<y_{i j} \\
\frac{\left[\left(1-P_{f, j}\right)-y_{i j}^{\prime}\right] P(Q=h)}{\left[y_{i j}^{\prime}-P_{m, j}\right] P(Q=l)}, & y_{i j}^{\prime}>y_{i j}
\end{array}\right.</script><p>为了计算用户报告的不可靠度，DPC需要基于历史数据观察每个用户的报告错误率$P_f,P_m$。此外，我们假设服务质量（记作$P(Q=l),P(Q=h)$）也可以根据较长的时间尺度和相对稳定的服务历史评级结果来获得。考虑到目前大多数基于服务的应用系统有能力提供这样的信息，这样的假设是可行和合理的。通过优化上述公式，不可靠度高的用户被认为是不确定的，他们可能是错误判断率高的诚实用户或恶意用户。来自这些用户的报告对于DPC评价服务质量是不可靠的。因此，DPC需要设置一个不可靠度的阈值，不可靠度超过该阈值的用户的报告将从服务评级程序中删除。阈值可以通过具有相对较高判断精度的诚实用户的典型错误率来设计。</p>
<p>接下来，我们描述前文公式中定义的用户不可靠度的有效性。以$Q=h$为例，恶意用户$i$为了实现欺骗会给出预测报告$y_{ij}^{‘}=y_{ij}-\varepsilon&lt;y_{ij}$。为了得到比阈值更低的不可靠度并使得自身的欺骗行为能对服务评级造成影响，用户$i$需要伪造报告$y_{ij}^{‘}$使得它接近$P_{m,j}$并远离$1-P_{f,j}$。当$P_{f,i}&lt;0.5$且$P_{m,i}&lt;0.5$时，$y_{ij}^{‘}$越小，不可靠度越低。另一方面，当$Q=h$时大多数诚实用户倾向于报告$x_j=1$。根据很前面的公式，当用户$i$的对等用户$j$给出的报告准确而诚实，则用户$i$的评分随$y_{ij}^{‘}$的减小而减小。对称地，$Q=l$时也存在相同的困境。因此，恶意用户如果欺骗性地报告，很难同时获得高可信度和低不可靠度。然而，对于那些判断错误率相对较高的“功能不好”的诚实用户来说，最好的选择仍然是如实报告$y_{ij}$和$y_{ij}^{‘}$。他们没有必要修改他们的$y_{ij}^{‘}$，因为他们的利益是由信息和预测报告决定的分数和可信度，这个利益与他们的报告是否被DPC接受没有关系。</p>
<h3 id="基于同行预测的服务评级"><a href="#基于同行预测的服务评级" class="headerlink" title="基于同行预测的服务评级"></a>基于同行预测的服务评级</h3><p>根据以上对用户可信度和不可靠度的分析，我们设计了基于私人优先同伴预测的服务评级方法，具体步骤如下。</p>
<ol>
<li>对于每个接受服务的用户$i$，在他/她的朋友中随机选择另一个不重叠的用户$j$作为$i$的同伴。</li>
<li>要求用户$i$提供他/她的先验信念报告$y_{ij}\in[0,1]$，即他/她的同行$j$将向云报告高质量的概率。</li>
<li>用户$i$体验服务，并作出自己对服务质量的判断$S_i=s_i$</li>
<li>问用户的后验信念报告$y_{ij}^{‘}\in[0,1]$</li>
<li>DPC计算不可靠度并移除超过阈值的用户报告</li>
<li>DPC从报告中推断用户的隐含意见报告$x_i$，移除低可信度的用户</li>
<li>DPC根据高可信度且低不可靠度的用户报告决定服务质量</li>
</ol>
<h2 id="仿真实验"><a href="#仿真实验" class="headerlink" title="仿真实验"></a>仿真实验</h2><p>实验部分略</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>基于云的服务评级架构</li>
<li>基于私有先验的对等预测</li>
<li>设计了不可靠指数</li>
<li>仿真结果表明方法有效</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>trustworthiness</tag>
        <tag>peer prediction</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Secure Balance Planning of Off-blockchain Payment Channel Networks</title>
    <url>/2022/11/08/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Secure%20Balance%20Planning%20of%20Off-blockchain%20Payment%20Channel%20Networks/</url>
    <content><![CDATA[<h1 id="Secure-Balance-Planning-of-Off-blockchain-Payment-Channel-Networks"><a href="#Secure-Balance-Planning-of-Off-blockchain-Payment-Channel-Networks" class="headerlink" title="Secure Balance Planning of Off-blockchain Payment Channel Networks"></a>Secure Balance Planning of Off-blockchain Payment Channel Networks</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>链下支付渠道可以通过实现“无需向区块链提交单笔支付即可在两个区块链节点之间进行大量小额支付”这一点来显著提高区块链的可扩展性。多个支付渠道可以形成一个支付网络，从而使得没有直接相连的两个节点也可以进行支付。构建支付网络的一个关键挑战在于决定应该将多少资金存入支付渠道作为初始余额，这严重影响了支付网络的性能，却少有研究。本文通过设计支付网络的余额规划服务<code>PnP</code>来解决这一问题。考虑到节点之间估计的支付需求，<code>PnP</code>可以决定通道余额，以较高的概率满足这些需求。它不依赖于任何可信第三方，并能以较低的开销提供强大的保护来防止恶意攻击。它包含两个创新点：加密排序和机会约束的平衡规划算法。在一个由30个节点组成的测试平台上的实验结果表明，<code>PnP</code>可以比其他设计多实现30%的支付。</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ol>
<li>区块链牺牲了可扩展性来实现去中心化和一致性，因为共识需要包含所有节点，例如比特币和以太坊每秒处理的交易都很少</li>
<li>近年来有研究提出了新的共识来，可以实现每秒上千交易，单仍然无法满足大规模应用的需求。例如Visa每秒47000笔交易。</li>
<li>交易渠道（payment channels）通过在两个区块链节点之间创建私有通道来解决可扩展性问题。具体来说，两个节点建立了一个特殊的渠道合约，该合约将一定数量的资金作为初始余额。随后，这两个节点可以在通道上进行交易并自行维护渠道余额。因为渠道上的交易并不提交给区块链，所以区块链的可扩展性就显著提升了。</li>
<li>节点之间的多个支付渠道可以构成支付网络，从而使得没有支付渠道直接相连的两个节点可以通过多跳的方式实现链下交易。如今已经有了实现这样功能的网络，例如比特币的Lighting Network和以太坊的Raiden Network。（注意这个闪电网络和闪电贷不是一个东西）</li>
<li>建立支付渠道的关键问题在于初始余额。如果钱给少了，则这个渠道要时不时重新构建，导致了更频繁的区块链访问操作。而钱给多了又是不必要的。如果考虑多跳交易的支付网络，这个问题就更复杂了。 现有研究大多假设支付渠道里的钱是足够的，但这并不现实。而一个考虑了这个问题的研究则引入了中心化的可信第三方，这更容易受到恶意攻击了。</li>
<li>本文研究了支付网络中的余额规划问题，即给定节点们的支付需求估计，如何决定支付渠道的初始余额。本文设计了一个余额规划服务<code>PnP</code>来实现这一点，它可以集成到现有的支付网络中。<code>PnP</code>可以利用对支付需求的了解，即使有估计误差，也能将渠道总存款降到最低。它不依赖可信第三方，因此可以抵御来自恶意节点的攻击。此外，它的通信和计算开销很低。<code>PnP</code>通过解决两个主要挑战来实现上述优势。<ol>
<li>很难精确估计节点的支付需求。直觉上的想法是根据历史需求预测未来需求从而设计算法，但是实际需求往往或多或少，一旦渠道余额用完，所有关联该渠道的交易就都会失败。当然也能改进预测方法来得到更准确的估计，但不能从根本上解决这个问题。本文的解决方法是：将这个余额规划问题表达为机会约束优化问题，进而设计算法从而从理论上保证高概率满足支付需求。</li>
<li>恶意节点攻击问题。现有工作很多都假设存在可行第三方，但这不现实。<code>PnP</code>能防御一定比例的拜占庭攻击。它随机选择一组节点作为决策委员会来产生正确的余额规划结果。它通过解决两个问题来保障安全性：谁应该被选中加入委员会，以及决策委员会如何在正确规划结果上达成共识。本文为委员会成员选举设计了加密排序机制。委员会中的每个节点独立运行本文提出的余额规划算法并通过拜占庭协议达成共识。</li>
</ol>
</li>
<li>本文在Ind上搭建虚拟支付网络做了实验，因为<code>PnP</code>是第一个余额规划研究，所以在对比的时候是和它的一些变种（不同设计选择）对比。</li>
<li>本文主要贡献如下：<ol>
<li>设计了<code>PnP</code>作为支付网络的余额规划，是第一个研究这个的。</li>
<li>为了防御攻击，设计了加密排序来选择决策委员会来运行规划算法。</li>
<li>描述了最小化支付渠道保证金又同时满足所有节点支付需求这一问题。使用机会约束来描述支付需求的不确定性，并使用近似技术解决相关问题。</li>
<li>在testbed上的30个节点测试了<code>PnP</code>，实验表明效果很好。</li>
</ol>
</li>
</ol>
<h2 id="PRELIMINARIES-AND-MOTIVATION"><a href="#PRELIMINARIES-AND-MOTIVATION" class="headerlink" title="PRELIMINARIES AND MOTIVATION"></a>PRELIMINARIES AND MOTIVATION</h2><h3 id="支付渠道"><a href="#支付渠道" class="headerlink" title="支付渠道"></a>支付渠道</h3><h3 id="支付网络"><a href="#支付网络" class="headerlink" title="支付网络"></a>支付网络</h3><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><h3 id="委员会选举"><a href="#委员会选举" class="headerlink" title="委员会选举"></a>委员会选举</h3><h3 id="非直连余额规划"><a href="#非直连余额规划" class="headerlink" title="非直连余额规划"></a>非直连余额规划</h3>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-A solution to the single-question crowd wisdom problem</title>
    <url>/2022/10/31/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-A%20solution%20to%20the%20single-question%20crowd%20wisdom%20problem/</url>
    <content><![CDATA[<h1 id="A-solution-to-the-single-question-crowd-wisdom-problem"><a href="#A-solution-to-the-single-question-crowd-wisdom-problem" class="headerlink" title="A solution to the single-question crowd wisdom problem"></a>A solution to the single-question crowd wisdom problem</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ol>
<li>群体智慧一度被认为优于个体观点，在一些领域已经逐渐用投票来取代专家决策</li>
<li>民主投票有局限性</li>
<li>本文方法：选择比人们预测的更受欢迎的答案</li>
</ol>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>假设你对美国地理知识一无所知，现在提问：</p>
<ol>
<li>费城是宾夕法尼亚州的首府吗？</li>
<li>哥伦比亚是南卡罗来纳州的首府吗？<br>你去找很多人问这两个问题，希望他们中的主流观点是正确的，这个方法在哥伦比亚的问题上是有效的，但在费城的问题上，大多数人都会回答“是”，而这是个错误答案。显然民主投票的方法是有问题的。</li>
</ol>
<p>针对该问题的标准回应是根据信任对投票进行加权平均。对于二值问题，信任度$c$表示一个受访者的投票有$c$的主观概率是正确的，有$1-c$的概率是错误的。概率可以线性或非线性平均，产生置信加权投票算法。然而该方法仅在正确答案是高置信的，而这在费城和哥伦比亚的问题中也不适用，因为这两个问题的两个选项的置信度都很相似，没法从中找出一个主流的回答。</p>
<p>本文提出一种替代算法，它要求受访者预测其他人对该问题的回答的分布，并选择那些比预测得到更多支持的回答。算法的直观描述如下：想象有两个平行宇宙，正宇宙里费城不是宾州的首府，而反宇宙里费城就是首府。针对“费城是否为宾州首府”这个问题，正宇宙里认为“是”的人比反宇宙要少。该问题可以形式化为扔有偏硬币的问题，该硬币在正宇宙有<code>60%</code>的概率扔出“是”，而在反宇宙有<code>90%</code>的概率扔出“是”。两个宇宙的主流观点都是“是”，人们知道硬币是有偏差的，但不知道哪个宇宙是正宇宙。因此，他们对赞成票的预测频率将在60%到90%之间。然而，正宇宙中的赞成票会收敛到60%，于是反对票就是那个比预测能得到更多支持的答案，同时也是正确答案。</p>
<p>我们将这个选择原则称为“出乎意料的受欢迎”（SP）算法，并在补充材料中严格定义了它。在一个问题(P)中，数据显示投赞成票的受访者相信几乎所有人都同意他们，而投反对票的人认为自己会占少数。投赞成票的平均预测百分比很高，导致实际投赞成票的百分比低于这些预测。因此，出乎意料受欢迎的回答是“否”，而这正是正确答案。相反，在哥伦比亚问题中，预测的赞成票低于实际的赞成票，出乎意料受欢迎的答案和实际确实受欢迎的答案是一致的，由此多数人的判断是正确的。</p>
<p>是否可以利用受访者的信心构建一个同样有效的算法？假设受访者知道先验的世界概率和硬币偏见。每个受访者观察他们的私人硬币投掷结果，并通过应用贝叶斯规则计算他们的信心。假设的算法将需要从报告的信任度的大样本中识别正宇宙的硬币。图2通过反例证明了不存在这样的算法(附件中的定理1提供了一个一般不可能的结果)。它展示了对于两个不同的有偏见的硬币问题，一个正确答案是肯定的，另一个正确答案是否定的，信心的相同分布是如何产生的。诚然，真实的人可能不会遵循理想化的贝叶斯模型。我们的观点是，如果基于后验概率(投票和信心)的方法对理想中的受访者无效，那么对真正的受访者也可能无效。</p>
<p>相比之下，SP算法有一个理论上的保证，即它总是根据现有证据选择最佳答案（补充资料中的定理2）。定理3将该算法扩展到多选题，并显示了投票预测如何能够识别出对正确答案给予最高概率的受访者。这些结果是基于一个共同的理论模型，该模型将有偏见的硬币的例子推广到多个多面硬币上。</p>
<p>为了测试SP算法，我们用四种类型的语义和知觉内容进行了研究（详情见SI）。研究1a, b, c使用了50个美国州首府问题，用不同的人群重复其格式（P）。研究2采用了80个一般知识问题。</p>
<p>研究3要求专业皮肤科医生将80张皮肤病变图片诊断为良性或恶性。研究4a、b向非专业人士和艺术专业人士展示了90件20世纪的艺术品（图3），并要求他们预测正确的市场价格类别。所有的研究都包括一个二分法的投票问题，总共产生了490个项目。研究1c、2和3另外还测量了信心。预测的投票频率是通过对所有受访者的预测进行平均来计算的（详情见补充资料）。</p>
<p>我们首先测试了四种算法的配对准确性：多数票、SP、信心加权票和最大信心，后者选择平均信心最高的答案。在所有490个项目中，相对于简单的多数票，SP算法减少了21.3%的错误（通过双侧匹配对符号测试，P &lt; 0.0005）。在测量信心的290个项目中，相对于多数票，减少了35.8%（P &lt; 0.001），相对于信心加权票，减少了24.2%（P = 0.0107），相对于最大信心，减少了22.2%（P &lt; 0.13）。</p>
<p>当同一研究中不同正确答案的频率不平衡时，百分比的一致可能是偶然的高。因此，我们通过分类相关系数，如Cohen’s kappa、F1得分或Matthews相关，评估一项研究中的分类准确性。SP算法在每项研究中的卡帕值都是最高的（图4）；其他系数产生类似的排名（扩展数据图1-3）。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-A Bayesian Truth Serum for Subjective Data</title>
    <url>/2022/10/24/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-A%20Bayesian%20Truth%20Serum%20for%20Subjective%20Data/</url>
    <content><![CDATA[<h1 id="A-Bayesian-Truth-Serum-for-Subjective-Data"><a href="#A-Bayesian-Truth-Serum-for-Subjective-Data" class="headerlink" title="A Bayesian Truth Serum for Subjective Data"></a>A Bayesian Truth Serum for Subjective Data</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>因为没有评估真实性的公共标准，因此主观判断作为科学和政策的重要信息来源是不可靠的。本文提出了一种在客观事实不可知的情况下获取真实主观数据的评分方法。这种方法不是传统的少数服从多数，而是选择那些比集体预测更常见的答案。这种对评分标准的简单调整，消除了所有有利于多数人的偏见，即使是那些认为自己的答案代表了少数人的观点的受访者，真实的答案也会使预期得分最大化。</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>主观数据的重要性略</p>
<p>主观数据的价值受限于数据源的质量，但又没有一个标准来评价这个质量</p>
<p>本文提出了一种诱导主观信息的方法，是为客观事实本质上或实际上不可知的情况而设计的(6)。该方法包括一个信息评分系统，从理性（即贝叶斯）期望值最大化的受访者样本中诱导出真实的答案。与其他贝叶斯诱导机制不同（7-9），该方法并不假定研究者知道不同回答之间的概率关系。因此，它可以由一个对该领域完全不了解的研究者应用于以前没有问过的问题。与早期没有答案的理论测试方法(5)或德尔菲法(10)不同的是，它并不推崇共识答案。因此，受访者没有理由将他们的答案偏向于可能的群体平均值。即使有人确信自己的答案代表了少数人的观点，真实的回答仍然是正确的策略。</p>
<p>简单来说就是不再采用多数人共识作为答案，而是采用比集体预测更常见的作为答案。</p>
<blockquote>
<p>个人觉得就是用集体预测构建了一个先验，然后选比先验更常见的答案</p>
</blockquote>
<p>这项评分标准针对单一问题，例如：</p>
<ol>
<li>你估计人类能活过2100年的概率是多少(概率以百分比计量) ？</li>
<li>你会在下一届总统选举中投票吗(肯定/可能/可能不会/肯定不会) ？</li>
<li>在过去的一年里，你是否有超过20个性伴侣(是/否)</li>
<li>毕加索是你最喜欢的20世纪画家吗(是/否) ？</li>
</ol>
<p>每个受访者都会提供一个个人答案，并预测答案的经验分布(即，支持每个答案的人的比例)。本文对预测的准确性进行评分，也就是说，对它们与经验频率的匹配程度进行评分。作为主要关注对象的个人答案，其评分标准是令人惊讶的普遍性。在预测频率为5%的情况下，一个被10%的人认可的答案将是令人惊讶的普遍现象，并将获得较高的信息分；如果预测的平均频率为25%，这将是一个令人惊讶的不常见的答案，因此获得较低的分数。</p>
<p>该方法利用了关于人口频率的贝叶斯推理中一个被忽视的含义。在大多数情况下，人们应该预期其他人会低估自己的意见或个人特征的真实频率。这一含义是更常见的贝叶斯论证的必然结果，即对某一特定意见或特征在人群中的频率的最高预测应该来自持有该意见或特征的个人，因为持有该意见构成了一个关于其流行程度的有效和有利的信号。例如，将毕加索评为自己最喜欢画家的人应该——而且通常也是如此——对持有该观点的人群的百分比给出更高的估计，因为他们自己的感受是一个有信息量的样本。因此，毕加索爱好者有理由相信，与其他人的估计相比，他们对毕加索受欢迎程度的最佳估计会更高，他们会认为，毕加索的真实受欢迎程度被人们低估了。因此，一个人的真实意见也是最有可能出人意料的意见。（最后这句话和前文有什么关系我没理解）</p>
<p>这个结论的有效性并不取决于个人真实的答案是否被认为是罕见的或广泛的。例如，一个回答问题时有超过20个性伴侣的男性可能觉得很少有人属于这种滥交的类别。然而，根据贝叶斯推理，他应该期望他个人对这个百分比的估计（例如5%）会比从整个人口中收集的估计的平均值（例如2%）高一些。他有超过20个性伴侣的事实证明，包括伴侣较少的人在内的一般人群会低估这种情况的普遍性。</p>
<p>在说真话能最大化自己的期望信息分（也就是前面说的那个评分系统）时，说真话是个体理性和集体理性，是唯一的均衡。</p>
<p>均衡结果依赖于两个假设：</p>
<ol>
<li>受访者数量必须足够大，使得单个回答不会影响经验分布。这些结果对于大的有限种群来说确实成立，但对于可数的无限种群来说，说明起来更简单，就像这里所做的那样。受访者以$r\in \lbrace 1,2,… \rbrace$为索引，他们针对多选项问题的真实回答记为$t^r=(t_1^r,…,t_m^r)(t_k^r\in\lbrace 0,1\rbrace, \sum_k x_k^r=1)$。$t_k^r$表示第$k$个回答是否是第$r$个受访者的真实答案，如果是则值为1，否则为0。真实答案也被称为个人意见或特点。</li>
<li>受访者将个人意见视为关于人口分布的非个人信息信号，这是一个未知参数，$\omega = (\omega_1,…,\omega_m)\in \Omega$。形式上，本文假设所有受访者的公共知识是：后验信念$p(\omega |t^s)$ 都服从于$\omega$的单一分布的贝叶斯更新，也称之为公共先验，记作$p(\omega)$，且，当且仅当$t^r=t^s$时$p(\omega|t^r)=p(\omega|t^s)$。因此，个人意见提供了关于$\omega$的证据，但推论是非个人的：受访者相信其他与他们意见相同的人也会得出关于人口频率的相同推论。因此，我们可以用$t_j$表示意见为$j$的受访者，并在联合概率和条件概率中取消受访者上标：$Prob\lbrace t_j^r=1 |t_j^s=1\rbrace$变为$p(t_j|t_i)$，其他的也类似改写。</li>
</ol>
<h2 id="关于先验和后验的一个例子"><a href="#关于先验和后验的一个例子" class="headerlink" title="关于先验和后验的一个例子"></a>关于先验和后验的一个例子</h2><p>对于一个二值问题，一个人可以如下推断模型。每一个受访者私下进行一次有偏硬币抛掷，它出现头像那一面的概率是$\omega_H$。抛掷结果代表他的个人意见。以此为基准点，他构造了一个后验分布，$p(\omega_H|t^r)$，其期望是预测的出现头像的频率。例如，如果先验是均匀分布，则抛掷硬币后的后验分布是$[0,1]$的三角分布，倾向于正面还是反面取决于硬币结果，期望值是$\frac{1}{3}$或$\frac{2}{3}$。如果先验不是均匀分布，而是强烈地偏向于相反的结果(例如，反面) ，那么在抛出头像那面之后，头像的预期频率可能仍然相当低——这对应于一些一看就不常见的特征，例如一年有超过20个性伴侣。</p>
<blockquote>
<p>在接下来的内容中，我们把硬币头像那一面称为正面(head)，另一边成为反面(tail)。</p>
</blockquote>
<p>从先验计算后验的过程如下：<br>首先，贝叶斯公式为：</p>
<script type="math/tex; mode=display">
P(H|D)=\frac{P(D|H)P(H)}{P(D)}</script><p>其中，<code>H</code>是假设，<code>D</code>是数据，<code>P(H)</code>是先验概率（先验概率顾名思义是看到数据前的猜测），<code>P(H|D)</code>是后验概率（后验概率顾名思义是拿到数据之后的猜测），<code>P(D)</code>是数据发生的概率，<code>P(D|H)</code>是在这个假设下数据发生的概率，也叫似然函数 。 而<code>P(D)</code>和<code>P(D|H)</code>的关系是：</p>
<script type="math/tex; mode=display">
P(D)=\sum_{all\ H}[P(D \mid H) \times P(H)]</script><p>最初硬币是公平和不公平的概率分别是0.5，前者抛出正面和反面的概率也分别是0.5，后者抛出正面和反面的概率分别是1和0。我们把几个事件用如下字母表示：</p>
<ol>
<li>硬币是公平的——A</li>
<li>硬币是不公平的——B</li>
<li>硬币扔出正面——H</li>
<li>硬币扔出反面——T</li>
</ol>
<p>则显然，$P(A)=P(B)=0.5$。</p>
<p>如果一个受访者扔出了正面，则贝叶斯公式中的<code>D</code>为<code>正面</code>，在<code>A</code>和<code>B</code>两个事件发生的情况下，扔出正面的概率为：<br>$P(D|A)=0.5, P(D|B)=1$.</p>
<p>我们的要求是已知<code>D=正面</code>的情况下，判断这个硬币是<code>A</code>和<code>B</code>的概率分别有多少，也就是说要计算<code>P(A|D)</code>和<code>P(B|D)</code>。</p>
<p>利用贝叶斯公式，我们还有一个变量<code>P(D)</code>不知道，但是可以如下计算：</p>
<script type="math/tex; mode=display">
P(D)=P(D|A)P(A)+P(D|B)P(B)=0.5*0.5+1*0.5=0.75</script><script type="math/tex; mode=display">
P(A|D)=\frac{P(D|A)P(A)}{P(D)}=0.5*0.5/0.75=\frac{1}{3}</script><script type="math/tex; mode=display">
P(B|D)=\frac{P(D|B)P(B)}{P(D)}=1*0.5/0.75=\frac{2}{3}</script><p>也就是说，在扔出正面之后，认为硬币是公平的概率会变成$\frac{1}{3}$，而认为硬币不公平的概率会变成$\frac{2}{3}$。</p>
<p>而如果扔出了反面，从直觉上来说就可以判断出硬币肯定是公平的，从数学计算上来说，当<code>D=反面</code>时，$P(D|A)=0.5, P(D|B)=0$.</p>
<script type="math/tex; mode=display">
P(D)=P(D|A)P(A)+P(D|B)P(B)=0.5*0.5+0*0.5=0.25</script><script type="math/tex; mode=display">
P(A|D)=\frac{P(D|A)P(A)}{P(D)}=0.5*0.5/0.25=1</script><script type="math/tex; mode=display">
P(B|D)=\frac{P(D|B)P(B)}{P(D)}=0*0.5/0.75=0</script><p>可以看出来扔出反面后认为硬币是公平的概率会变成1，而不公平的概率会变成0.</p>
<h2 id="具体计算方法"><a href="#具体计算方法" class="headerlink" title="具体计算方法"></a>具体计算方法</h2><p>该方法的一个重要简化是不提取先验/后验分布，只提取答案和预测频率，答案和预测分别记作$x^r=(x_1^r,…,x_m^r)(x_k^r\in\lbrace 0,1\rbrace,\sum_k x_k^r=1)$和$y^r=(y_1^r,…,y_m^r)(y_k^r\geq 0,\sum_ky_k^r=1)$。我们按照下列公式计算人口认可频率$\bar{x_k}$，和预测频率的（几何）平均$\bar{y_k}$</p>
<script type="math/tex; mode=display">
\bar{x}_{k}=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} x_{k}^{r},</script><script type="math/tex; mode=display">
\log \bar{y}_{k}=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} \log y_{k}^{r}</script><p>说明：这里的$\bar{x_k}$就是计算选择这个回答的人占总人数的比例，而$\bar{y_k}$则是所有人对这个回答的预测频率的几何平均值</p>
<p>我们不使用预设的答案键，而是根据答案的信息得分来评估答案，这个得分就是实际频率与预测频率的对数比。</p>
<script type="math/tex; mode=display">\log \frac{\bar{x}_{k}}{\bar{y}_{k}}</script><p>至少一个答案的信息分非负。预测中的偏差往往会降低所有$\bar{y_k}$值，从而提高信息分值。</p>
<p>受访者的总分将信息分数与预测准确性的单独分数结合起来：<br>受访者$r$的得分 = 信息分 + 预测分 = </p>
<script type="math/tex; mode=display">\sum_{k} x_{k}^{r} \log \frac{\bar{x}_{k}}{\bar{y}_{k}}+\alpha \sum_{k} \bar{x}_{k} \log \frac{y_{k}^{r}}{\bar{x}_{k}}, 0<\alpha</script><p>上述公式是博弈的完全收益方程，它是对称的，如果 a = 1则为零和。第一部分是信息分，除了被受访者$r$选择的那个答案以外，其他答案的$x_k^r$都是<code>0</code>。第二部分是与经验分布和受访者$r$对该分布的预测之间的相对熵成正比的惩罚。最优预测分为0，是指预测完全符合现实，即$y_k^r=\bar{x_k}$（也就是说，所有人对这个答案出现的频率预测都一致并且符合真实情况）。期望预测分可以通过报告期望频率$y_k^r=E\lbrace \bar{x_k}|t^r \rbrace$来最大化。系数$\alpha$表示预测误差的权重。</p>
<p>接下来用硬币的例子来说明该公式是如何发挥作用的。想象有下述两种等可能性的事件：</p>
<ol>
<li>硬币是公平的</li>
<li>硬币不公平，它永远会扔出正面<br>在这个表述里，硬币是公平的先验概率为$\frac{1}{2}$</li>
</ol>
<p>接下来找一群人，让他们私下抛硬币并报告自己是哪一面，则可以分析出以下两种情况：</p>
<ol>
<li>一个扔出了反面的观测者会意识到这个硬币属于第一种情况，并由此预测整个群体观察到的正面和反面频率是五五开的。</li>
<li>一个扔出了正面的观测者会把“硬币是公平的”这件事的概率从先验的$\frac{1}{2}$降低到后验的$\frac{1}{3}$，进而使得他对扔出反面的预期概率降低到$\frac{1}{6}$，而扔出正面的预期概率就是$\frac{5}{6}$。</li>
</ol>
<p>我们从扔出反面的观测者的角度思考问题，其他人对抛硬币出反面这一结果的预期频率应该是$\frac{1}{2}$和$\frac{1}{6}$的混合，也就是说比他自己预测的$\frac{1}{2}$要小，因此他会期待实际结果中的反面更常见，从而得到较高的信息分。而相反，他会希望正面不常见，因为$\frac{1}{2}$和$\frac{5}{6}$的混合比他自己预测的$\frac{1}{2}$要大，这会导致一个较低的信息分。</p>
<p>类似的，扔出正面的观测者就会希望实际结果中正面更常见。由此可以发现，大家都会希望自己扔出的那一面更常见，而为此也会如实上报自己的结果从而试图增加这部分信息分。</p>
<p>该示例说明了信息分的一般属性。也就是说，如果最佳答案是由预期的信息得分精确定义的且其他受访者如实回答并给出真实的预测频率，那么一个真实的答案构成了对最令人惊讶的常见答案的最佳猜测。此属性不依赖于可能的答案的数量或先验。它直接导致均衡结果。</p>
<p>假设：</p>
<ol>
<li>每一个意见为$t^r$的受访者$r$通过对共同的先验$p(\omega)$应用贝叶斯法则形成了对意见的群体分布的后验$p(\omega|t^r)$。</li>
<li>当且仅当$t^r=t^s$时，$p(\omega|t^r)=p(\omega|t^s)$</li>
<li>分数按照前面的那个信息分+预测分来计算</li>
</ol>
<p>则：</p>
<ol>
<li>(T1) 对于任意$\alpha&gt;0$，说真话是纳什均衡：说真话可以最大化每一个相信其他人也会说真话的受访者的期望总分。</li>
<li>(T2) 期望均衡信息分是非负的，并且在所有受访者都说真话时取最大值。</li>
<li>(T3) 当$\alpha=1$时，博弈是零和的，总分在说真话均衡中为$log p(\omega|t^r)+K$，$K$由零和约束设置。</li>
</ol>
<p>说真话是指回答和预测都是真实的，即：$x^r=t^r$且$y^r=E\lbrace \omega|t^r \rbrace$。</p>
<p>T2指出，尽管存在其他均衡，可以通过将多个真实意见映射到一个反应类别中或通过随机化来构建，但这些揭示性较低的均衡会导致所有受访者的信息得分较低。如果需要，我们可以通过在公式2中给予信息分相对更多的权重来增强讲真话的战略优势。在$\alpha$足够小的情况下，讲真话均衡中的预期总分将以帕累托方式支配任何其他均衡中的预期分值。</p>
<p>T3说明，通过设置$\alpha=1$，我们可以将该博弈呈现为一个纯粹的竞争性的零和竞赛。总分根据受访者对答案的真实分布的预期程度进行排名。需要注意的是：评分系统只要求提供真实答案的预期分布$E\lbrace \omega|t^r \rbrace$而不是后验分布$p(\omega|t^r)$，后者是一个<code>m</code>维的概率密度函数。我们可以通过一个不直接引出这些概率的方法来推断哪些受访者对$\alpha$的实际值赋予了更多的概率。</p>
<p>在以往关于激励机制的经济学研究中，标准的做法是假设评分者（或中心）知道先验和后验，并将这种知识纳入评分函数。原则上，先验的任何变化，无论是问题措辞的变化、样本构成的变化，还是新的公共信息的变化，都需要重新计算计分函数。相比之下，我的方法采用了一个通用的一刀切的打分方程，不提先验或后验概率。这对实际应用有三个好处。首先，问题不需要局限于一些预先测试过的、可获得经验估计的基本比率和条件概率的集合；相反，人们可以利用自然语言的全部资源，为每个应用定制一套新问题。第二，可以对不同的人群进行相同的调查，或者在动态环境下进行调查（这与政治民意调查有关）。第三，人们可以诚实地指示受访者在制定自己的答案时不要猜测他人的答案。真实的答案对任何先验来说都是最佳的，而且没有公开的概率供他们考虑，或许还可以拒绝。</p>
<p>当涉及到为复杂、独特的问题打分时，这些都是决定性的优势。特别是，人们可以应用这种方法来获得关于任何明确陈述的命题的真实价值的诚实的概率判断，即使实际的真理是遥不可及的，也没有先验。例如，最近由一位著名的英国天文学家撰写的《我们最后的世纪》一书中，人类在2100年后生存的机会不超过50：50。这是一个挑衅性的评估，它不会很快被检验。用现在的方法，人们可以提出这样的问题：这是我们最后的世纪吗？并将其提交给一个专家样本，他们将各自提供一个主观概率，并估计其他概率的概率分布。T1意味着对主观概率的诚实报告将使预期信息得分最大化。专家们将面临类似的讲真话的激励，就像他们对实际结果下注一样，例如，在期货市场上，结果可以及时确定，以便评分。</p>
<p>我们用离散计算来说明。假设概率以1%为精度被分为100份，由此这个问题就成了一个有100个选项的选择题（在实际生活中，我们往往会有更少的类别，和更平滑的经验频率）。人口向量$\omega=\lbrace \omega_{00},…,\omega_{99} \rbrace$表示专家们之间的关于概率的未知分布。给定任意先验，$p(\omega)$，计算作为真实个人概率和被大众所认可的概率的函数的预期信息分数是一项费力但简单的工作。计算结果如下图所示，其中<code>A(90)</code>和<code>B(90)</code>分别表示两种不同先验（分别记作$p_A(\omega)$和$p_B(\omega)$）下专家认为90%的概率地球会在2100年之前毁灭。因此，专家们有着相同的评估，但对于他们的评估与其他人的评估之间的关系却有着不同的理论。虽然A90和B90不同，但在这两种情况下，预期信息分都是由90%的真实认可来计算的。这证实了T1。在这两种情况下，每个专家都认为他的主观概率相对于人群是悲观的。以个人估计的90%为条件，对他人概率的期望值在$p_A(\omega)$的情况下只有65%，在$p_A(\omega)$的情况下只有54%。</p>
<p>如果主观概率变成<code>50%</code>，这两条线会移动到<code>A(50)</code>和<code>B(50)</code>，则此时二者的最优策略就也会变成<code>50%</code>。总的来说就是无论主观信念怎么变，说实话都是最好的选择。</p>
<p>A线和B线的不同之处在于，A线的先验概率被假定为50%，B线为20%。B线的期望分数较高，因为90%的估计值在这种情况下更令人惊讶。<br><img src="https://github.com/likun1208/image/blob/master/BayesianTruth.jpg?raw=true" alt="概率统计图"></p>
<p>假设评分者能精确为估计值打分，则对比信息分与这个精确分是有意义的。激发关于可公开验证的事件的诚实概率的标准工具是对数适当得分规则。根据该规则，一个专家在<code>n</code>个互斥事件上宣布其概率分布为$z=(z_1,…,z_n)$，如果事件$i$发生了，则他得到的评分为$K+log z_i$。举个例子，一位专家对人类将在2100年之前灭亡的真实主观概率估计为90%，但他宣布的概率<code>z</code>可能不是90%，根据<code>z</code>可以计算出他的分数是$0.9log z+0.1log(1-z)$，再次强调，这里假设我们知道他真实的估计概率是90%。这个分数计算公式会在$z=0.9$时取最大值，就是图中PS90对应的那条线。可以看出来它和用信息分计算的A90、B90的趋势是基本一样的。</p>
<p>非个人信息性先验的假设可能在两方面会失败。首先，在存在关于人口频率的公共信息的情况下，一个真实的答案可能不会对这些频率提供信息。例如，一个人的性别对他们判断人口中的男女比例的影响很小。这意味着$t^r \neq t^s$但$p(\omega|t^r)=p(\omega|t^s)$，且诚实和欺骗性答案的预期信息分之间的差异几乎为零（尽管仍然是正数）。如下图所示，补救措施是将性别问题与一个与性别有关的意见问题结合起来。</p>
<p>第二，具有不同品味或特征的受访者可能出于不同的原因选择相同的答案，从而形成不同的后验。例如，具有非标准政治观点的人可能会把他或她对某位候选人的喜欢当作大多数人都会喜欢其他候选人的证据。这意味着尽管$t^r=t^s$，但是$p(\omega|t^r) \neq p(\omega|t^s)$。在这里，补救的办法也是扩大问卷，让当事人同时透露意见和特征。</p>
<p>最后一个例子，一个艺术评估，说明了这两种补救措施。这个例子假设存在专家和门外汉，以及一个二元性质的状态：一个特定的艺术家是否代表原创才能的问题。根据假设，艺术专家能很好地识别这种区别，但普通人的辨别能力很差，事实上，喜欢衍生艺术家的机会比喜欢原创艺术家的机会要大。专家的比例是众所周知的，其他的概率也是如此（表1）。</p>
<p>本例和其他例子中的信息分反映了与某一观点或特征相关的信息量。在表格中，专家有明显的优势，尽管他们在样本中占少数，因为他们的意见对人口频率的信息量更大。一般来说，意见<code>i</code>的期望信息分就等于分布$p(\omega|t_k,t_i)$和$p(\omega|t_k)$之间的期望相对熵，后者是所有$t_k$的平均值。换句话说，<code>i</code>的预期得分是信息论的衡量标准，即赞同<code>i</code>的意见会在多大程度上改变他人对人口分布的后验信念。专家的认可将导致信念的更大转变，因为它对驱动两个部分意见的基本变量的信息量更大。这种影响的衡量标准对专家群体的规模或专家与非专家意见之间的关联方向相当不敏感。</p>
<p><img src="https://github.com/likun1208/image/blob/master/BayesianTruth-2.png?raw=true" alt="表格"></p>
<p>通过建立说实话的激励机制，我并不是说人们在没有明确的经济回报的情况下就会欺骗或者不愿意提供信息。相反，人们担心的是，缺乏外部标准可能会助长自我欺骗和虚假的信心，即使是在善意的人之间。一个未来学家，或者一个艺术评论家，可以轻松地花一生的时间做出判断，而不用面对医生、科学家或者商业投资者的现实检查。在缺乏现实检验的情况下，人们很容易给予主流共识以特殊地位。明确得分的好处恰恰是抵消了非正式的压力，要求同意(或者也许是要突出(和不同意)。事实上，仅仅存在一个真相诱导评分系统就为社会科学提供了方法论上的保证，表明如果需要的话，主观数据可以通过一个既不基于信仰(所有的答案都同样好)也不偏向于例外观点的过程来获得。</p>
<h2 id="我的问题"><a href="#我的问题" class="headerlink" title="我的问题"></a>我的问题</h2><ol>
<li>公式里的$\bar{y_k}$如果是0怎么办？</li>
<li>信息分那里为什么要取对数？如果不取对数，效果是不是仍然一样？大小关系感觉没变。</li>
</ol>
<h2 id="补充材料"><a href="#补充材料" class="headerlink" title="补充材料"></a>补充材料</h2><p>是这篇论文作者附的一系列证明。</p>
<p>有一个无限可数的受访者群体，记作$r,s,…\in I=\lbrace 1,2,…\rbrace$，它们都面对同一个有着$m$个候选答案的多选项问题。受访者$r$的私有“信号”通过$m$维单位向量$t^r\in E^m$提供，该向量中，坐标对应了受访者$r$所选答案的元素的值是1，其他元素值为0。持有意见$i$的受访者记作$t_i$。</p>
<p>说明：我们用上标来指示个体，下标指示个体的类别，即$t^r$表示某个具体的受访者$r\in I$的意见，是一个向量，而$t_i$表示持有意见$i$的受访者。</p>
<p>每个受访者支持一个回答，并预测其他受访者中支持其他可能回答的频率。回答用$n$维单位向量$x^r=(x_1^r,…,x_m^r)\in E^m,(x_k^r\in\lbrace 0,1 \rbrace,\sum_k x_k^r=1)$来表示，而预测用相对频率分布$y^r=(y_1^r,…,y_m^r)\in \Delta^m(y_l^r\geq 0,\sum_k y_k^r=1)$来表示。$x_k^r$根据个体$r$是否支持这个答案而取值1或者0；$y_k^r$是个体$r$对支持答案$k$的受访者的比例的估计。$(x,y)$是回答和预测组成的向量（可数无限）</p>
<p>任意受访者的得分取决于他的回答、预测和经验平均：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
\bar{x}_{k}=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} x_{k}^{r}, \\
\log \bar{y}_{k}=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} \log y_{k}^{r} .
\end{array}</script><p>其中，$\bar{x_k}$是答案$k$的平均频率，$\bar{y_k}$是答案$k$的预测频率的几何平均。如果$y_k^r=0$，则设$\bar{y_k}=0$，且设$log(0/0)=0$，$0log(0)=0$。</p>
<p>受访者$r$的得分，是$(x,y)$的函数，为：</p>
<script type="math/tex; mode=display">
u^{r}(x, y)=\sum_{k} x_{k}^{r} \log \frac{\bar{x}_{k}}{\bar{y}_{k}}+\alpha \sum_{k} \bar{x}_{k} \log \frac{y_{k}^{r}}{\bar{x}_{k}}</script><p>第一项为信息分，是受访者$r$所支持的答案对应的$log(\frac{\bar{x_k}}{\bar{y_k}})$。第二项是预测分。</p>
<h3 id="信息假设"><a href="#信息假设" class="headerlink" title="信息假设"></a>信息假设</h3><ol>
<li>A1：存在集合S的成员意见的公共先验$p(t^r,…,t^s)$。</li>
<li>A2：先验是可交换的：对于所有组合$\pi$，都有$p(t^r,…,t^s)=p(t^{\pi(r)},…,t^{\pi(s)})$。</li>
<li>A3：不同的意见代表不同的后验分布：$p(\cdot|t^r)=p(\cdot|t^s)$就意味着$t^r=t^s$。</li>
</ol>
<p>A1是贝叶斯博弈理论的标准假设。A2是至关重要的。根据De Finetti定理，它意味着$\Omega=\Delta^m$上存在一个概率分布$p(\omega)$，它将共同先验表达为条件独立随机变量的联合分布：</p>
<script type="math/tex; mode=display">
\begin{array}{l} 
p\left(t^{r}, ..., t^{s}\right)=\int_\Omega \prod_{q \in S} p\left(t^{q} \mid \omega\right) p(\omega) d \omega \\
p\left(t_{k}^{r} \mid \omega\right)=\omega_{k}=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{q=1}^{n} t_{k}^{q} .
\end{array}</script><p>换句话说，受访者相信他们的意见是独立的，是以意见的人口频率$\omega$为条件的。条件独立性的假设可以直接引用，而不是从可交换性中推导出来。然而，交换性强调了关键的基本属性，即具有相同意见的受访者对人口中的意见分布具有相同的后验信念。最后一个假设（A3）是随机相关性的一个版本；它只影响到讲真话的纳什均衡是否严格。</p>
<p>这里$\omega$应该是指人口频率的分布情况，$\omega_k$是指在这样的人口频率下，支持第$k$个答案的人口百分比。</p>
<h3 id="贝叶斯纳什均衡策略"><a href="#贝叶斯纳什均衡策略" class="headerlink" title="贝叶斯纳什均衡策略"></a>贝叶斯纳什均衡策略</h3><p>受访者$r$的回答策略是一个函数$x^r(t^r)=(x_1^r(t^r),…,x_m^r(t^r)):E^m \rightarrow \Delta^m$，表示如果受访者$r$的真实回答是$t^r$，则他有概率$x_k^r(t^r)$给出答案$x_k$。如果$x^r(t^r)=t^r$则该策略是真实的。</p>
<p>受访者$r$的预测策略同样是一个函数$y^{r}\left(t^{r}\right)=\left(y_{1}^{r}\left(t^{r}\right), \ldots, y_{m}^{r}\left(t^{r}\right)\right): E^{m} \rightarrow \Delta^{m}$，表示如果受访者$r$持有意见$t^r$，则他会预测人群中有占比$y_k^r$的人会回答$k$。我们不需要考虑预测随机性，因为收益函数是关于$y_k^r$的严格凸函数(convex)。</p>
<p>二元组$(x^r(t^r),y^r(t^r))$是受访者$r$的策略。$(x(t),y(t))$表示所有受访者的策略。$(x^{-r}(t^{-r}),y^{-r}(t^{-r}))$是除了受访者$r$以外其他所有受访者的策略。如果所有的答案都是真实的，并且预测符合贝叶斯法则，那么$(x(t),y(t))$就是集体真实的。</p>
<p><strong>定义</strong>：如果对于所有受访者$r$、回答$x_k^r$和预测$y^r$，下列式子都成立，则$(x(t),y(t))$是贝叶斯纳什均衡(BNE)。</p>
<script type="math/tex; mode=display">
E\left\{u^{r}(x(t), y(t)) \mid t^{r}\right\} \geq E\left\{u^{r}\left(x^{r}, y^{r}, x^{-r}\left(t^{r}\right), y^{-r}\left(t^{r}\right)\right) \mid t^{r}\right\}, \text { for all } x^{r} \in E^{m}, y^{r} \in \Delta^{m}</script><p>如果不等式是严格的，则该BNE也是严格的</p>
<p><strong>定理1</strong>：如果A1~A3成立，则集体说真话是严格贝叶斯纳什均衡。<br>证明：如果大家都说真话，则人口平均是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\bar{x}_{k} & =\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{s=1}^{n} x_{k}^{s} =\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{s=1}^{n} t_{k}^{s} =\omega_{k},\\
\log \bar{y}_{k} & =\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{s=1}^{n} \log y_{k}^{s} 
=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{s=1}^{n} \log p\left(t_{k} \mid t^{s}\right) 
=\sum_{j=1}^{n} \omega_{j} \log p\left(t_{k} \mid t_{j}\right)
\end{aligned}</script><p>【记录一下我的理解】这里$y_k^s$表示受访者$s$持有意见$t^s$，他预测其他人有概率$y_k^s$支持答案$k$，由于假设其他人都说真话，也就是说支持答案$k$意味着持有意见$t^k$，因此$y_k^s$就可以表示持有意见$t^s$的受访者认为其他人持有意见$t^k$的概率，也就写作$p(t_k|t^s)$。接下来，虽然不知道这里为什么要把$s$变成$j$，但是前面的$s$和后面的$j$应该是等价的，表示支持某个回答的受访者。而在这个无限数量的人群中，任意一个受访者支持持有意见$t^j$的概率就是$\omega_j$，显然可以把前面的除以$n$取极限的形式直接改写成人口频率的形式，由此得到了$\sum_{j=1}^n \omega_j log p(t_k|t_j)$。</p>
<p>考虑持有意见$i$且相信其他人都说真话的个体，他应该支持哪个答案才能最大化自己的期望评分呢？因为期望预测错误并不取决于他自己的回答，我们可以先忽略评分公式的第二部分，只看第一部分信息分。如果他支持答案$j$，则他的期望信息分为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left\{\log \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid t_{i}\right\} & =\int_{\Omega} p\left(\omega \mid t_{i}\right) E\left\{\log \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid \omega\right\} d \omega \\
& =\int_{\Omega} p\left(\omega \mid t_{i}\right) \sum_{k=1}^{m} \omega_{k} \log \frac{\omega_{j}}{p\left(t_{j} \mid t_{k}\right)} d \omega \\
& =\sum_{k=1}^{m} \int_{\Omega} p\left(\omega, t_{k} \mid t_{i}\right) \log \frac{\omega_{j}}{p\left(t_{j} \mid t_{k}\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{\omega_{j}}{p\left(t_{j} \mid t_{k}\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(t_{j} \mid \omega\right) p\left(t_{k} \mid t_{j}, \omega\right)}{p\left(t_{j} \mid t_{k}\right) p\left(t_{k} \mid \omega\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{j}\right)}{p\left(\omega \mid t_{k}\right)} d \omega
\end{aligned}</script><p>这个公式第一行计算了先验分布$p(\omega|t_i)$下的$log(\frac{\bar{x_j}}{\bar{y_j}})$的期望，大致意思就是说当受访者持有意见$i$时，他对人群整体的分布有一个先验的连续条件概率，因此用积分的形式计算最终的期望，$p(\omega|t_i)$表示先验概率，$E(xxx)$表示在这样的先验概率下的期望信息分，是一个条件期望。</p>
<p>第二行是从集体如实上报推导而来，按照期望的定义，$E\left\{\log \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid \omega\right\}$的计算应该就是<br>在别人都说真话的情况下，$\bar{x}_j$就可以改写成$\omega_j$，而$log \bar{y}_j$则改写为$\sum_{k=1}^{n} \omega_{k} \log p\left(t_{j} \mid t_{k}\right)$。接下来是条件期望的公式套用，根据<a href="https://zhuanlan.zhihu.com/p/417592820" target="_blank" rel="noopener">链接</a>可知，由此第一行的那个条件期望就可以改写成$\sum$</p>
<p>第三行使用条件独立将$\omega_k p(\omega|t_i)$改写为$p(\omega,t_k|t_i)$。首先$\omega_k$可以直接写作$p(t_k|\omega)$，由此$\omega_k p(\omega|t_i)$就变成$p(t_k|\omega)p(\omega|t_i)$，在条件$\omega$下，$t_k$和$t_i$独立，所以$p(t_k|\omega)=p(t_k|\omega,t_i)$，于是就可以进一步改写成$p(t_k|\omega,t_i)p(\omega|t_i)$。根据贝叶斯条件概率的公式，$P(AB)=P(B)P(A|B)$，给这个公式加上条件概率就是$P(AB|C)=P(B|C)P(A|BC)$，这个式子就可以变成$p(t_k,\omega|t_i)$了。</p>
<p>第四行是使用贝叶斯规则从第三行推出的。还是根据前面的贝叶斯条件概率公式，对应到这里，就可以把$p(\omega,t_k|t_i)$改写为$p(t_k|t_i)p(\omega|t_k,t_i)$，而前面的$p(t_k|t_i)$与$\omega$的积分无关，所以可以提出来放积分外面。</p>
<p>第五行我们再次使用条件独立将$\omega_j$改写为$p(t_j|\omega)$，然后插入$\frac{p(t_k|t_j,\omega)}{p(t_k|\omega)}=1$，具体来说就是把第四行的$\omega_j$直接改写成$p(t_j|\omega)$，而因为$t_k$和$t_j$在条件$\omega$下是独立的，所以$\frac{p(t_k|t_j,\omega)}{p(t_k|\omega)}=1$。</p>
<p>第六行也是随之根据贝叶斯规则推导而来，过程如下：</p>
<script type="math/tex; mode=display">
\frac{p(t_j|\omega)p(t_k|t_j,\omega)}{p(t_j|t_k)p(t_k|\omega)}=\frac{\frac{p(t_j,\omega)p(t_k,t_j,\omega)}{p(\omega)p(t_j,\omega)}}{\frac{p(t_j,t_k)p(t_k,\omega)}{p(t_k)p(\omega)}}=\frac{\frac{p(t_k,t_j,\omega)}{p(t_k,t_j)}}{\frac{p(t_k,\omega)}{p(t_k)}}=\frac{p(\omega|t_k,t_j)}{p(\omega|t_k)}</script><p>由此，我们可以对比如实回答答案$i$和谎报答案$j$的信息分：</p>
<script type="math/tex; mode=display">
\begin{array}{l} 
E\left\{\ln \frac{\bar{x}_{i}}{\bar{y}_{i}} \mid t_{i}\right\}-E\left\{\ln \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid t_{i}\right\}=\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \\
-\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{j}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \\
=-\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{j}\right)}{p\left(\omega \mid t_{k}, t_{i}\right)} d \omega \\
>-\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \log \left(\int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \frac{p\left(\omega \mid t_{k}, t_{j}\right)}{p\left(\omega \mid t_{k}, t_{i}\right)} d \omega\right) \\
=\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \log \left(\int_{\Omega} p\left(\omega \mid t_{k}, t_{j}\right) d \omega\right)=\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \ln (1)=0
\end{array}</script><p>该不等式来源于Jensen不等式，且当A3成立时是严格的。它证明了当其他人都如实回答和预测时，说真话能最大化期望信息分。</p>
<p>接下来该证明同样应该如实预测。这次我们忽略信息分，来计算个体意见是$i$的条件下的期望预测分：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left\{\sum_{k=1}^{m} \bar{x}_{k} \log \frac{y_{k}}{\bar{x}_{k}} \mid t_{i}\right\} & =\sum_{k=1}^{m} E\left\{\bar{x}_{k} \mid t_{i}\right\} \log y_{k}-E\left\{\sum_{k=1}^{m} \bar{x}_{k} \log \bar{x}_{k} \mid t_{i}\right\} \\
& =\sum_{k=1}^{m} E\left\{\omega_{k} \mid t_{i}\right\} \log y_{k}-E\left\{\sum_{k=1}^{m} \omega_{k} \log \omega_{k} \mid t_{i}\right\} .
\end{aligned}</script><p>这里假定会如实回答，因此$\bar{x_k}=\omega_k$。第二个期望不包括$y_k$，因此，能最大化评分的针对$k$个答案占比的预测，就是回答$k$的期望频率，或者说等价于随机选一个人会持有意见$k$的概率：$y_k=E\lbrace \omega_k|t_i\rbrace=p(t_k|t_i)$。</p>
<p>由此完成了集体说真话是BNE的证明。</p>
<p><strong>定理2</strong>：如果A1~A3成立，则对于所有受访者而言下述内容都成立：</p>
<ol>
<li>任意BNE中的期望信息分是非负的</li>
<li>说真话对应的均衡解下的期望信息分会微弱地高于其他任意BNE对应的期望信息分</li>
</ol>
<p>证明(a)：期望信息分可以通过在定理1的公式那里设置$j=i$来计算：</p>
<script type="math/tex; mode=display">
E\left\{\ln \frac{\bar{x}_{i}}{\bar{y}_{i}} \mid t_{i}\right\}=\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \ln \frac{p\left(\omega \mid t_{k}, t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \geq 0</script><p>这其实是分布$p(\omega|t_k,t_i)$和$p(\omega|t_k)$之间的相对熵，对所有$t_k$取平均。它衡量了“知道$t_i$”这件事能在多大程度上提升其他人对$\omega$的预测，也称为“数据期望效用”——将$t_i$看作数据（参考文献25的定理2.31）。当$i$的回答不会改变其他人对$\omega$的预测时，这个表达式最小为0。这证明了定理2的第一条。</p>
<p>证明(b)：我们考虑$q(\omega,\bar{x})$的联合分布，它是由一个特定的BNE推导而来的，该BNE记作$(x(t),y(t))$，$q$的边际与$p$重合，$q(\omega)=p(\omega)$。当真实意见是$i$而支持的答案是$j$时，期望信息分是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left\{\log \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid t_{i}\right\} & =\int_{\Omega} p\left(\omega \mid t_{i}\right) E\left\{\log \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid \omega\right\} d \omega \\
& =\int_{\Omega} p\left(\omega \mid t_{i}\right) \sum_{k=1}^{m} \omega_{k} \log \frac{\bar{x}_{j}}{q\left(x_{j} \mid t_{k}\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{\bar{x}_{j}}{q\left(x_{j} \mid t_{k}\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{\bar{x}_{j}}{q\left(x_{j} t_{k}\right)} d \bar{x} \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(x_{j} \mid \bar{x}\right) q\left(t_{k} \mid x_{j} \bar{x}\right)}{q\left(x_{j} t_{k}\right) q\left(t_{k} \mid \bar{x}\right)} d \bar{x} \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, x_{j}\right)}{q\left(\bar{x} \mid t_{k}\right)} d \bar{x}
\end{aligned}</script><p>这和定理1中的证明很像，除了第二行不再假设一个说真话的均衡。</p>
<p>现在我们将$q\left(\omega, \bar{x} \mid t_{i},t_{k}\right)$和$q\left(\omega, \bar{x} \mid t_{k}\right)$之间的相对熵扩展到两个不同的方式，先把$\omega$作为条件，再把$\bar{x}$作为条件：</p>
<script type="math/tex; mode=display">
\begin{array}{l} 
\int_{\Omega, \bar{X}} q\left(\omega, \bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\omega, \bar{x} \mid t_{k}, t_{i}\right)}{q\left(\omega, \bar{x} \mid t_{k}\right)} d \omega d \bar{x}= \\
= \int_{\Omega} q\left(\omega \mid t_{k}, t_{i}\right) \log \frac{q\left(\omega \mid t_{k}, t_{i}\right)}{q\left(\omega \mid t_{k}\right)} d \omega \\
+\int_{\bar{X}, \Omega} q\left(\bar{x} \mid \omega, t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid \omega, t_{k}, t_{i}\right)}{q\left(\bar{x} \mid \omega, t_{k}\right)} d \bar{x} d \omega \\
= \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, t_{i}\right)}{q\left(\bar{x} \mid t_{k}\right)} d \bar{x} \\
\quad+\int_{\Omega, \bar{X}} q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right) \log \frac{q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right)}{q\left(\omega \mid \bar{x}, t_{k}\right)} d \omega d \bar{x}
\end{array}</script><p>第二行仅考虑了$q(\omega,\bar{x})$对于$\omega$的边界，因此我们可以用$p$代替$q$；因为$\bar{x}$完全取决于$\omega$，所以第三行是0。现在我们可以将第二行如下改写，并将第四行如下扩展：</p>
<script type="math/tex; mode=display">
\begin{array}{l} 
\int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \\
= \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, x_{j}\right)}{q\left(\bar{x} \mid t_{k}\right)} d \bar{x} \\
\quad+\int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, t_{i}\right)}{q\left(\bar{x} \mid t_{k}, x_{j}\right)} d \bar{x} \\
\quad+\int_{\Omega, \bar{X}} q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right) \log \frac{q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right)}{q\left(\omega \mid \bar{x}, t_{k}\right)} d \omega d \bar{x}
\end{array}</script><p>对所有$t_k$求和可以得到一个表达式，该表达式关系到讲真话均衡中的预期信息分数和替代均衡中的预期信息分数。</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \\
=\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, x_{j}\right)}{q\left(\bar{x} \mid t_{k}\right)} d \bar{x} \\
+\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, t_{i}\right)}{q\left(\bar{x} \mid t_{k}, x_{j}\right)} d \bar{x} \\
+\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega, \bar{X}} q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right) \log \frac{q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right)}{q\left(\omega \mid x, t_{k}\right)} d \omega d \bar{x}
\end{array}</script><p>第一行是说真话均衡的期望信息分，第二行是在其他均衡中支持答案$j$的信息分，第三行和第四行是相对熵。这证明了期望信息分在不说真话的均衡里只会更低。</p>
<p><strong>定理3</strong>：如果A1~A3成立，且$\alpha=1$，则该博弈是零和博弈，且在说真话的均衡中，持有意见$i$的受访者的总分为$log p(\omega|t_i)+K$。</p>
<p>证明：对于$\alpha=1$，评分公式为：</p>
<script type="math/tex; mode=display">
u^{r}(x, y)=\sum_{k} x_{k}^{r} \log \frac{\bar{x}_{k}}{\bar{y}_{k}}+\sum_{k} \bar{x}_{k} \log \frac{y_{k}^{r}}{\bar{x}_{k}}</script><p>所有受访者的平均总分比等于0：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} u^{r}(x, y) & =\lim _{n \rightarrow \infty} \frac{1}{n}\left(\sum_{r=1}^{n} \sum_{k} x_{k}^{r} \log \frac{\bar{x}_{k}}{\bar{y}_{k}}\right)+\lim _{n \rightarrow \infty} \frac{1}{n}\left(\sum_{r=1}^{n} \sum_{k} \bar{x}_{k} \log \frac{y_{k}^{r}}{\bar{x}_{k}}\right) \\
& =\sum_{k}\left(\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} x_{k}^{r}\right) \log \frac{\bar{x}_{k}}{\bar{y}_{k}}+\sum_{k} \bar{x}_{k}\left(\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} \log \frac{y_{k}^{\prime}}{\bar{x}_{k}}\right) \\
& =\sum_{k} \bar{x}_{k} \log \frac{\bar{x}_{k}}{\bar{y}_{k}}+\sum_{k} \bar{x}_{k} \log \frac{\bar{y}_{k}}{\bar{x}_{k}}=0 .
\end{aligned}</script><p>为了计算说真话均衡中的总分，我们需要用期望信息分的类似表达莱补充期望预测分，说真话均衡意味着最前面计算期望预测分的公式中的$y_k=p(t_k|t_i)$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left\{\sum_{k=1}^{m} \bar{x}_{k} \log \frac{y_{k}}{\bar{x}_{k}} \mid t_{i}\right\} & =E\left\{\sum_{k=1}^{m} \omega_{k} \log \frac{p\left(t_{k} \mid t_{i}\right)}{\omega_{k}} \mid t_{i}\right\} \\
& =\int_{\Omega} p\left(\omega \mid t_{i}\right) \sum_{k=1}^{m} \omega_{k} \log \frac{p\left(t_{k} \mid t_{i}\right)}{\omega_{k}} d \omega \\
& =\sum_{k=1}^{m} \int_{\Omega} p\left(\omega, t_{k} \mid t_{i}\right) \log \frac{p\left(t_{k} \mid t_{i}\right)}{\omega_{k}} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(t_{k} \mid t_{i}\right)}{\omega_{k}} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(t_{k} \mid t_{i}\right) p\left(t_{k} \mid \omega\right)}{p\left(t_{k} \mid \omega\right) p\left(t_{k} \mid t_{i}, \omega\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{i}\right)}{p\left(\omega \mid t_{k}, t_{i}\right)} d \omega \leq 0
\end{aligned}</script><p>这也是对所有$t_k$取平均后，$p(\omega|t_k)$和$p(\omega|t_k,t_i)$的分布之间的相对熵。它测量了通过了解另一个人的意见$k$而产生的$i$对$\omega$的信念的（负数的）熵减。如果了解其他人的回答并不会改变$i$对$\omega$的信念，则期望预测分为0。</p>
<p>在说真话均衡解中，期望总分就是结合了前面的两组公式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left\{\frac{\bar{x}_{i}}{\bar{y}_{i}}+\sum_{k=1}^{m} \bar{x}_{k} \log \frac{p\left(t_{k} \mid t_{i}\right)}{\bar{x}_{k}} \mid t_{i}\right\} & =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \\
& =\int_{\Omega} p\left(\omega \mid t_{i}\right) \sum_{k=1}^{m} \omega_{k} \log \frac{p\left(\omega \mid t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega
\end{aligned}</script><p>那么，当人口平均是$\omega$时，支持$i$的人的后验评分为：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^{m} \omega_{k} \ln \frac{p\left(\omega \mid t_{i}\right)}{p\left(\omega \mid t_{k}\right)}=\ln p\left(\omega \mid t_{i}\right)-\sum_{k=1}^{m} \omega_{k} \ln p\left(\omega \mid t_{k}\right)</script><p>第二项是由零和约束决定的常数。由此证明了定理3.</p>
<h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p><a href="https://wesselb.github.io/assets/write-ups/Bruinsma,%20A%20Bayesian%20Truth%20Serum.pdf" target="_blank" rel="noopener">资料来源</a><br>假设一些人参加了一个带有主观问题的调查。你被要求对这个问题的答案分布做出最佳猜测。作为一个人，你的猜测并非完全不知情：你知道自己对这个调查问题的看法。尽管这个样本可能不能说明人口的分布情况，但它确实构成了一个有效的样本，因此应该说明一些问题；也就是说，在某种程度上，一个人的意见是一个信息丰富的 “一个样本”。</p>
<p>你的最优猜测记作$f$，它由每一个答案的频率组成。与人口群体的平均最优猜测即公共预测$\langle f\rangle$相比，可以预计$f-\langle f\rangle$会在你的意见取最高值，因为与常见的预测不同，你的最佳猜测是由你的意见提供的，尽管是非常轻微的；这种现象在实践中确实被观察到。因此，如果你是一个元理性的贝叶斯代理人，并意识到这种情况，你应该相信你的意见具有最高的概率，比通常预测的更常见。</p>
<p>贝叶斯吐真剂是基于上述现象的。在BTS中，答案的评分标准是衡量一个答案与常见预测值相比有多普遍。事实上，如上所述，从受访者的角度来看，诚实回答就能获得最高分的概率最大。 </p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>除了给出每个问题的回答$x^n$，BTS还要求受访者$n$给出他对该问题答案分布的最优猜测$f^n$，这些随机变量的模型如下图所示，</p>
<p><img src="https://github.com/likun1208/image/blob/master/BTS-1.png?raw=true" alt="BTS模型图"></p>
<p>每一个个体$n$都持有意见$t^n$，我们将$t^n=i$简化表达为$t^n_i$。所有个体的意见都有条件独立，条件是给定潜在变量$\omega$，对于每个个体而言分布都是$p(t_i^n|\omega)=w_i$。此外，给定个体$n$的意见$t^n$，他们会根据回答策略$p(x^n|t^n)$来给出答案$x^n$，我们将$x^n=i$简化表达为$x^n_i$。个体$n$对其他回答$i$的频率预测记作$f^n_i$。需要注意的是，假设存在潜在变量$\omega$使得$p(t^n_i|\omega)=\omega_i$就意味着假设个体意见$t^n$服从一个可交换序列。</p>
<p>一般来说我们讨论哪一个个体都是无所谓的。为了简化，我们省略个体索引，例如$t_i$表示意见为$i$的个体，$x_j$表示回答为$j$的个体，$f_k$表示个体对回答$k$的频率预测为$f_k$。</p>
<p>【记录一下个人理解】BTS的模型应该是指，首先人群中持有的各个意见服从某个潜在分布$\omega$，在此基础上，随便一个受访者的个人意见是$i$的概率就记作$\omega_i$，而根据前文可知，个人意见会对回答和预测产生影响，从而使得受访者得出回答$x^n$和$f^n$，这俩应该都是向量，其中前者是受访者的答案对应的那个向量元素为1，其他都是0，表示他就选了这个答案；后者则是所有元素都小于1并且求和为1，表示后者对每个答案的频率预测，并且这些预测总和应该是1。</p>
<h3 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h3><p>给定回答$x^n$和预测频率$f^n$，BTS的评分为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
S\left(x_{i}, f\right) &=\overbrace{\log \frac{\langle x\rangle_{i}}{\langle f\rangle_{i}}}^{\text {information score }}-\overbrace{\sum_{j}\langle x\rangle_{j} \log \frac{f_{j}}{\langle x\rangle_{j}}}^{\text {prediction penalty }}, \\
\langle x\rangle_{i} &=\text { average of }\left(\mathbb{1}\left(x^{n}=i\right)\right), \\
\langle f\rangle &=\text { geometric average of }\left(f^{n}\right) .
\end{aligned}</script><p>评分函数由两部分组成：</p>
<ol>
<li>信息分衡量的是答案$i$与公共预测相比的常见程度。</li>
<li>预测惩罚形成了真实和预测的答案频率之间的Kullback-Leibler（KL）散度。</li>
</ol>
<p>KL散度描述了我们用分布$Q$来估计数据的真实分布$P$的编码损失。</p>
<p>【记录一下个人理解】对比一下前面的公式，这里信息分那里不太一样，不过仔细分析一下会发现其实是一个意思，就是指【该答案的实际频率（anwser’s actual frequency）】/【所有人对这个答案的预测频率的几何平均(mean of answer’s predicted frequency)】。举个例子，有10个人，其中2个人选了这个答案，大家对这个答案的预测频率都是0.1（姑且这么假设），那信息分就是$log\frac{0.2}{0.1}$。信息分如果大于0（就是说里面的分式大于1），就意味着这个答案是出乎意料受欢迎的（surprissingly common），实际选它的人比大家对它的预测频率要高。</p>
<p>通常来说，如果一个人持有某种意见，那么他会产生偏见，从主观上认为持有该意见的人相对多，也就是说他自己的预测频率会比真实的频率高一些，有点类似信息茧房。从数学上来说，受访者提出的预测实际上是一个条件概率，条件就是他自己的意见，公式表达一下就是$P(我觉得大家有x的概率选A，y的概率选B，z的概率选C，等等|我的意见是B)$。举个例子，关于是否作弊这个问题，$P(你觉得很多人都作弊|你作弊了)&gt;P（你觉得很多人都作弊|你没作弊）$。在这样的情况下，在预测总频率的时候，我们就会想：会有人不选这个答案，他们对这个答案的预测就会低一些。假如一个人本来觉得有20%的人会选这个答案，这样考虑一番之后他就会把自己预测的频率降低一些，比如降到15%。由此，信息分的分母就会变小，而此时这个人的真实意见就是那个出乎意料受欢迎的意见。</p>
<p>如何避免他人发言对偏见的影响</p>
<p>这里参考了<a href="https://www.youtube.com/watch?v=uOIqIeDFpS4" target="_blank" rel="noopener">一个视频</a>，不过感觉这个视频没太讲清楚，没说明白为什么说真话最好。</p>
<p>第二部分预测惩罚那里，是根据个人对所有答案频率的预测与所有答案真实频率的差距来计算的预测分，这个分越大，说明预测偏得越远。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><strong>假设3.1</strong>：可交换性。个体意见$t^n$组成了一个可交换序列。该假设证明了BTS所假设的图形模型的合理性。</p>
<p><strong>假设3.2</strong>：随机相关性。不同意见表示$\omega$的不同先验分布：如果$i\neq j$，则$p(\omega|t_i)\neq p(\omega|t_j)$。该假设是一个技术上的便利，将被用来得出最大化者的唯一性的结论。</p>
<p><strong>假设3.3</strong>：样本量足够大。$\langle x\rangle$和$\langle f\rangle$的方差足够小从而可以用极限来求近似。</p>
<p><strong>定理3.1</strong>：说真话是均衡解。假设一个受访者持有意见$k$、回答$i$和预测$f$，且其他人都如实回答和预测。则该受访者也最好如实回答和预测：</p>
<script type="math/tex; mode=display">
\max _{(i, f)} \mathbb{E}\left(S\left(x_{i}, f\right) \mid t_{k}\right)=\left(k, p\left(t \mid t_{k}\right)\right)</script><p>此外，</p>
<script type="math/tex; mode=display">
\mathbb{E}\left(\text { information score }\left(x_{i}\right) \mid t_{i}\right)=\sum_{j} p\left(t_{j} \mid t_{i}\right) \mathrm{D}_{\mathrm{KL}}\left(p\left(\omega \mid t_{i}, t_{j}\right) \| p\left(\omega \mid t_{j}\right)\right) \text {. }</script><p>证明：如果其他人如实回答和预测，则</p>
<script type="math/tex; mode=display">
\langle x\rangle_{i} \approx p\left(t_{i} \mid \omega\right)=\omega_{i}, \quad \log \langle f\rangle_{i} \approx \sum_{j} p\left(t_{j} \mid \omega\right) \log p\left(t_{i} \mid t_{j}\right)=\sum_{j} \omega_{j} \log p\left(t_{i} \mid t_{j}\right)</script><p>这里$\langle x\rangle_i$是人群中答案$i$的真实频率，如果大家都说真话，那么它应该就约等于那个潜在概率$w_i$。</p>
<p>而$\langle f\rangle_i$是人群对答案$i$的几何平均预测频率，根据几何平均数的公式，取对数后的计算方式就是每个元素取对数然后求和再平均，$p(t_i|t_j)$的含义看起来是说个人意见选$j$的个体对别人选$i$的频率预测，【每一种个人意见会出现的频率】乘log【该意见下的人对答案$i$的频率预测】，符合几何平均预测频率的定义。</p>
<p>信息分仅取决于回答$i$，而预测惩罚仅取决于预测$f$，因此我们可以分开考虑它们。</p>
<p>首先，</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbb{E}\left(\text { information score }\left(x_{i}\right) \mid t_{k}\right) & =\int p\left(\omega \mid t_{k}\right) \sum_{j} p\left(t_{j} \mid \omega\right) \log \frac{p\left(t_{i} \mid \omega\right)}{p\left(t_{i} \mid t_{j}\right)} \\
& =\sum_{j} p\left(t_{j} \mid t_{k}\right) \int p\left(\omega \mid t_{k}, t_{j}\right) \log \frac{p\left(\omega \mid t_{i}, t_{j}\right)}{p\left(\omega \mid t_{j}\right)} \mathrm{d} \omega \\
& \leq \sum_{j} p\left(t_{j} \mid t_{i}\right) \operatorname{D}_{\mathrm{KL}}\left(p\left(\omega \mid t_{i}, t_{j}\right) \| p\left(\omega \mid t_{j}\right)\right)
\end{aligned}</script><p>当且仅当$k=i$时取等号。</p>
<p>第二，</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbb{E}\left(\text { prediction penalty }(f) \mid t_{k}\right) & =\int p\left(\omega \mid t_{k}\right) \sum_{j} p\left(t_{j} \mid \omega\right) \log \frac{f_{j}}{p\left(t_{j} \mid \omega\right)} \frac{p\left(t_{j} \mid t_{k}\right)}{p\left(t_{j} \mid t_{k}\right)} \mathrm{d} \omega \\
& =\int p\left(\omega \mid t_{k}, t_{j}\right) \sum_{j} p\left(t_{j} \mid t_{k}\right) \log \frac{f_{j}}{p\left(t_{j} \mid t_{k}\right)} \frac{p\left(\omega \mid t_{k}\right)}{p\left(\omega \mid t_{k}, t_{j}\right)} \mathrm{d} \omega \\
& \leq-\mathrm{D}_{\mathrm{KL}}\left(f_{j} \| p\left(t_{j} \mid t_{k}\right)\right)-\sum_{j} p\left(t_{j} \mid t_{k}\right) \mathrm{D}_{\mathrm{KL}}\left(p\left(\omega \mid t_{k}, t_{j}\right) \| p\left(\omega \mid t_{k}\right)\right)
\end{aligned}</script><p>当且仅当$f_j=p(t_j|t_k)$时取等号。</p>
<p>定理3.1说明了说真话是贝叶斯纳什均衡。它还表明，讲真话的信息分数，也是最佳的信息分数，衡量的是另一个人的后验分布在得知你的意见后平均变化的程度；这表明专家可能享有更高的预期信息分数。下面的命题表明，讲真话也是最优贝叶斯纳什均衡。</p>
<p><strong>定理3.2</strong>：说真话是最优均衡。说真话的均衡解是最大化期望信息分的均衡。</p>
<p>证明：在任意一个均衡中</p>
<script type="math/tex; mode=display">
\langle x\rangle_{i} \approx p\left(x_{i} \mid \omega\right), \quad \log \langle f\rangle_{i} \approx \sum_{j} p\left(t_{j} \mid \omega\right) \log p\left(x_{i} \mid t_{j}\right)</script><p>则：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\left.\mathbb{E} \text { (information score }\left(x_{i}\right) \mid t_{k}\right) \\
\quad=\sum_{j} p\left(t_{j} \mid t_{k}\right) \int p\left(\omega \mid t_{k}, t_{j}\right) \log \frac{p\left(\omega \mid x_{i}, t_{j}\right)}{p\left(\omega \mid t_{j}\right)} \mathrm{d} \omega \\
\quad=\underbrace{\sum_{j} p\left(t_{j} \mid t_{k}\right) \int p\left(\omega \mid t_{k}, t_{j}\right) \log \frac{p\left(\omega \mid t_{k}, t_{j}\right)}{p\left(\omega \mid t_{j}\right)} \mathrm{d} \omega}_{\text {truth-telling equilibrium }}+\sum_{j} p\left(t_{j} \mid t_{k}\right) \underbrace{\int p\left(\omega \mid t_{k}, t_{j}\right) \log \frac{p\left(\omega \mid x_{i}, t_{j}\right)}{p\left(\omega \mid t_{k}, t_{j}\right)} \mathrm{d} \omega .}_{-\mathrm{D}_{\mathrm{KL}}\left(p\left(\omega \mid t_{k}, t_{j}\right) \| p\left(\omega \mid x_{i}, t_{j}\right)\right) \leq 0}
\end{array}</script><p>最后，在说真话的均衡中，BTS是零和博弈，分数表征了与先验期望频率相比一个答案有多普遍。</p>
<p><strong>定理3.3</strong>：零和博弈。在说真话博弈中，分数在极限时加起来是0：</p>
<script type="math/tex; mode=display">
\sum_{i} p\left(t_{i} \mid \omega\right) S\left(x_{i}, p\left(t \mid t_{i}\right)\right)=0 .</script><p>此外，</p>
<script type="math/tex; mode=display">
S\left(x_{i}, p\left(t \mid t_{i}\right)\right)=\log \frac{\omega_{i}}{\mathbb{E}_{p(\omega)}\left(\omega_{i}\right)}+\operatorname{constant}(\omega) .</script><p>证明：</p>
<script type="math/tex; mode=display">
S\left(x_{i}, p\left(t \mid t_{i}\right)\right)=\sum_{j} p\left(t_{j} \mid \omega\right) \log \frac{p\left(\omega \mid t_{i}\right)}{p\left(\omega \mid t_{j}\right)}=\log p\left(\omega \mid t_{i}\right)-\sum_{j} p\left(t_{j} \mid \omega\right) \log p\left(\omega \mid t_{j}\right)</script>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>trustworthiness</tag>
        <tag>BTS</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Eliciting Thinking Hierarchy without a Prior</title>
    <url>/2022/10/13/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Eliciting%20Thinking%20Hierarchy%20without%20a%20Prior/</url>
    <content><![CDATA[<h1 id="Eliciting-Thinking-Hierarchy-without-a-Prior"><a href="#Eliciting-Thinking-Hierarchy-without-a-Prior" class="headerlink" title="Eliciting Thinking Hierarchy without a Prior"></a>Eliciting Thinking Hierarchy without a Prior</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>针对无法验证答案的众包任务，传统思路：选择大多数人支持的答案</p>
<p>存在问题：大多数人犯系统性错误，会导致最终结果出错</p>
<p>本文希望：在没有任何先验的情况下，在所有答案中建立一个等级制度，使得根据该制度得到的排名较高的答案（可能不被大多数人支持）来自更可靠的人</p>
<p>本文提出：</p>
<ol>
<li><p>一个新的模型来描述人们的思维层次</p>
</li>
<li><p>两种算法来学习没有任何先验的思维层次</p>
</li>
<li><p>一种基于上述理论框架的新的公开回答的众包方法</p>
</li>
</ol>
<p>本文实验：</p>
<ol>
<li><p>本文方法所学习到的排名靠前的答案的准确度远远高于全体投票（在一个问题中，全体投票的答案得到了74名受访者的支持，但正确答案只得到了3名受访者的支持。我们的方法在没有任何先验的情况下将正确答案排在最高位置）</p>
</li>
<li><p>本文模型有很高的拟合度，特别是对于我们排名第一的答案是正确的问题</p>
</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>群体智慧在面对系统性错误的时候往往会得出错误结果</p>
<p>一个例子：圆A的半径是圆B半径的1/3，圆A绕着圆B转了一圈后回到起点。圆A总共会旋转多少次？</p>
<p><img src="https://github.com/likun1208/image/blob/master/2109.jpg?raw=true" alt="圆圈问题"></p>
<p>根据实验，有11个人认为是1次，8个人选2次，134个人选3次，16个人选4次，27个人选6次，21个人选9次。显然在多数一致的众包任务中，这个题的答案会被认为是3次，但其实正确答案是4次，只有16个人选。</p>
<p>如果事先了解所有受访者的先验水平，我们也许能根据大家的专业水平来确定正确答案，但是在大多数众包场景中，往往没这样的先验知识。</p>
<p>为了解决上述问题，Prelc等人[15]提出了一种创新的方法，他们准备了多个选择，要求受访者挑选一个选项，并预测其他人的选择分布。他们使用预测结果来构建一个关于选择的先验分布，然后选择比先验分布更受欢迎的选择，这样就纠正了偏见（是2017年的nature）。许多其他工作[10, 5, 16]发展了使用先验或预测来纠正偏差的想法。</p>
<p>然而，首先，将以前的方法应用于运行中的例子，即圆圈问题，是不适用的，因为它们需要先验知识来设计选择。让受访者报告所有选择的整体分布也很费力。第二，以前的工作主要是利用预测来纠正偏见，而利用他们的预测来建立一个思维层次是内在的问题。这也导致了答案之间的层次性。著名的认知分层理论（CHT）[21, 22, 3]在人们玩游戏的场景中建立了一个思维理论，这样我们就可以学习不同复杂程度的玩家的行动。然而，CHT只是为游戏理论环境设计的。我们对在一般的问题解决场景中建立一个思维理论感到好奇。该问题的关键在于，水平较高的人知道水平较低的人的想法，但反之则不然[3, 9]。我们想应用这个见解来学习不同复杂程度的人的答案，称为思维层次，而不需要任何先验。</p>
<p><strong>关键问题</strong>：我们的目标是建立一个实用的方法，在没有任何先验的情况下学习思维层次。基于思维层次，我们可以对答案进行排序，这样，排名较高的答案，可能不被大多数人支持，但是来自更可靠的人。</p>
<p>层次性思维方式的优势除了在于选出正确答案以外，还有以下几点：</p>
<ol>
<li><p>一些主观性问题可能有多个高质量答案，完整的层次结构能提供更丰富的结果。</p>
</li>
<li><p>答案的层次性有助于更好地理解人们的思维方式，尤其当我们试图征求人们对某项政策的意见时这一点更重要。</p>
</li>
</ol>
<p><strong>本文方法</strong>：和以往研究一样，让受访者同时写出自己的回答和对其他人答案的预测，并将其扩展到一个更实用的基于开放回答的范式。该范式提出了一个单一的开放回答问题，并要求每个回答者的答案和对其他人的答案的预测。例如，在圆圈问题中，一个回答者可以提供：答案。”4”，预测。”3”。然后我们构建一个答案-预测矩阵A，记录报告特定答案-预测对的人数。（例如，图2（a）显示有28人回答 “3”，预测其他人回答 “6”）。</p>
<p><img src="https://github.com/likun1208/image/blob/master/fig2.png?raw=true" alt="圆圈问题的答案-预测矩阵"></p>
<p>为了学习思维层次，本文提出了一个新颖的模型，它描述了不同复杂程度的人如何回答问题，和预测其他人的答案。回答者的答案和预测的联合分布取决于描述人们思维层次的潜在参数。本文表明，鉴于回答者的答案和预测的联合分布，可以通过解决非负矩阵分解问题的一个新变体来推断潜在的思维层次，该问题被称为非负全等三角化（NCT）。基于对NCT的分析，本文提供了两个简单的答案排序算法，并表明在适当的假设下，给定应答者的答案和预测的联合分布，这些算法将学习潜在的思维层次。</p>
<blockquote>
<p>直接一些来说，就是专业人士不仅能答对，还能知道业余者会犯什么错。</p>
</blockquote>
<p>最后，本文将答案和预测的联合分布表示为答案-预测矩阵，并在该矩阵上实现了基于NCT的答案排序算法。默认的排序算法是使矩阵上三角区域内的元素的平方和最大化，在变体的排序算法中，为了让不同的答案具有相同的复杂程度，答案被分割以压缩矩阵，该算法使压缩后的矩阵的上三角区域的平方和最大化。</p>
<p>在实验方面，进行了包括数学、围棋、常识和字符发音的实证研究。</p>
<p>需要说明的是：在前面那个矩阵图中，因为默认算法不需要用对角线的元素，所以这里对角线上的元素不再是答案-预测的人数，而是选择了这个答案的人数，这样方便和普通的多数一致众包方法做对比，例如那个矩阵里<code>(3,3)</code>对应的134表示有134个人回答了3，而不是说这么多人自己回答3也预测别人回答3。</p>
<h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><p>先略，以下是从他们公众号的介绍里复制来的内容：</p>
<p>正如前文所言，在没有先验的情况下，很难对这些答案采取支持度以外的排序方式。Prelec [1], Prelec et al. [2] 通过在单选题中额外询问回答者对各个选项分布的预测，进而构造先验信息，并汇总答案为支持度“令人意外地高”的选项，并实验证明该方法比多数决有效。Rothschild and Wolfers [3] 在民调时除了询问“你会选谁”，还额外询问选民“你觉得谁会得到更多的支持”，并实验证明额外信息具有更高的信息量。</p>
<p>类似地，我们采用了一套基于填空题的问卷调查方式：  </p>
<p><strong>“你的答案是？”</strong></p>
<p><strong>“你觉得别人会答什么？”</strong>  </p>
<p>与之前工作不同，在以上框架下，询问者无需任何先验设计选项，回答者无需提供分布信息。针对答案的汇总，Kong and Schoenebeck [4] 提出一个猜想：“专业度高的人可以预测专业度低的答案，反之不然。”  </p>
<p>这个猜想和行为经济学有限理性理论中的等级 k（Level-k）[5] 以及认知等级（Cognitive Hierarchy）[6] 理论相似，都认为人在逻辑思考推理中存在不同的等级。等级 k 和认知等级理论认为高等级知道低等级的存在并采取针对低等级的最优策略。</p>
<h2 id="Learning-Thinking-Hierarchy"><a href="#Learning-Thinking-Hierarchy" class="headerlink" title="Learning Thinking Hierarchy"></a>Learning Thinking Hierarchy</h2><h3 id="Thinking-hierarchy"><a href="#Thinking-hierarchy" class="headerlink" title="Thinking hierarchy"></a>Thinking hierarchy</h3><p>给定一个问题<code>q</code>（例如圆圈问题），<code>T</code>表示思维类型的集合，<code>A</code>表示可能出现的回答的集合，这两个都是有限集，$\Delta_A$表示<code>A</code>的所有可能分布。</p>
<p><strong>Generating answers</strong>：说明不同思维类型的人是如何得出答案的。</p>
<p><strong>定义2.1</strong>：思维类型的预言机<code>W</code>：一个生成答案的预言机（an anwser generating oracle，不太理解这是指生成预言机的答案还是指生成答案的预言机，感觉是后者）将问题映射到集合<code>A</code>中的（随机）答案。每一个类型<code>t</code>都对应了一个预言机$O_t$，$O_t(q)$的输出是一个随机变量，其分布是$w_t\in \Delta_A$。$W$是一个$|T|\times|A|$矩阵，其中每一行是$w_t$。</p>
<p>每一个受访者都有概率$p_t$是类型$t$，且$\sum_t p_t=1$，类型<code>t</code>的受访者通过运行预言机$O_t$得到自己的答案。对于所有$a\in A$，一个受访者回答$a$的概率是$\sum_t p_tw_t(a)$，假设对于所有$a\in A$，概率都是正的。</p>
<p><strong>例2.2（运行示例）</strong>：有两种思维类型$T=\{0,1\}$，回答空间是$A=\{3,4,6\}$，预言机$O_0$有0.8的概率输出3，0.2的概率输出6；$O_1$会直接输出4。在这个例子中，$W=[\begin{matrix}0.8&amp;0&amp;0.2\\0&amp;1&amp;0 \end{matrix}]$，其中第一行是$O_0$的输出，第二行是$O_1$的输出。</p>
<p><strong>Generating predictions</strong>：说明不同思维类型的人会如何预测其他人的回答。这里的预测不是一个分布，而是一个其他人可能会报告的答案。当类型<code>t</code>的受访者预测时，她会运行一个预言机来得到预测结果$g\in A$，该预言机有概率$p_{t\rightarrow t’}$等于$O_{t’}$，其中$\sum_{t’}p_{t\rightarrow t’}=1$。</p>
<p><strong>Combination: answer-prediction joint distribution M</strong>：<code>M</code>表示一个$|A|\times |A|$的矩阵，其中$M_{a,g}$是受访者回答<code>a</code>且预测他人回答<code>g</code>的概率，$\Lambda$表示一个$|T|\times |T|$的矩阵，其中$\Lambda_{t,t’}$是受访者为类型<code>t</code>且预测他人类型<code>t&#39;</code>的概率。</p>
<p><strong>例2.3</strong>：在本例中，当类型<code>0</code>的受访者进行预测时，她会以概率<code>1</code>再次运行预言机$O_0$。当类型<code>1</code>的受访者进行预测时，她会以<code>0.5</code>的概率运行预言机$O_0$，<code>0.5</code>的概率运行预言机$O_1$。且受访者有<code>0.7</code>的概率是类型<code>0</code>，<code>0.3</code>的概率是类型<code>1</code>。则$\Lambda=[\begin{matrix}p_0p_{0\rightarrow 0}&amp;p_0p_{0\rightarrow 1}\\p_1p_{1\rightarrow 0}&amp;p_1p_{1\rightarrow 1}\end{matrix}]=[\begin{matrix}0.7&amp;0\\0.15&amp;0.15\end{matrix}]$</p>
<p><strong>观点2.4</strong>：基于以上生成过程，$M=W^{\top}\Lambda W$。<br><strong>证明</strong>：对于每一个受访者，她回答<code>a</code>且预测<code>g</code>的概率为</p>
<script type="math/tex; mode=display">M_{a, g}=\sum_t p_t \mathbf{w}_t(a) \sum_{t^{\prime}} p_{t \rightarrow t^{\prime}} \mathbf{w}_{t^{\prime}}(g)=\sum_{t, t^{\prime}} \mathbf{w}_t(a) p_t p_{t \rightarrow t^{\prime}} \mathbf{w}_{t^{\prime}}(g)</script><p>我们对所有受访者可能的类型进行求和，假定她的类型为<code>t</code>，则她会运行预言机$O_t$来得到答案，且有概率$w_t(a)$得到答案<code>a</code>。我们对她所有可能为了预测而运行的预言机进行求和，假定她运行$O_{t’}$，则预测为<code>g</code>的概率是$w_{t’}(g)$。</p>
<p>一些补充说明：这里从证明到2.4的过程我其实没完全搞明白，姑且写一下理解：</p>
<p>首先$w_t(a)$就是矩阵<code>W</code>的第<code>t</code>行第<code>a</code>列的元素，中间的$p_tp_{t\rightarrow t’}$是矩阵$\Lambda$的第<code>t</code>行第<code>t&#39;</code>列的元素，最后的$w_{t’}(g)$是第<code>t&#39;</code>行第<code>g</code>列的元素。</p>
<p>接下来回顾一下矩阵相乘的公式：<br>矩阵<code>A</code>和矩阵<code>B</code>相乘得到矩阵<code>C</code>，其计算方法是：</p>
<script type="math/tex; mode=display">
C_{i,j} = \sum_{k=0}A_{i,k}B_{k,j}</script><p>由此可以推导出，三个矩阵连乘法的计算方式：</p>
<script type="math/tex; mode=display">
D_{i,m}=\sum_{j=0}(\sum_{k=0}A_{i,k}B_{k,j})C_{j,m}=\sum_{j=0,k=0}A_{i,k}B_{k,j}C_{j,m}</script><p>回到前面2.4的公式来看，</p>
<script type="math/tex; mode=display">
M_{a, g}=\sum_{t, t^{\prime}} \mathbf{w}_t(a) p_t p_{t \rightarrow t^{\prime}} \mathbf{w}_{t^{\prime}}(g)=\sum_{t, t^{\prime}}W_{t,a}\Lambda_{t,t'}W_{t',g}</script><p>显然，如果能把第一个$W_{t,a}$的行列交换一下，这个公式就可以改写为三个矩阵连乘了，而这恰好就是矩阵转置，即$W_{t,a}=W_{a,t}^\top$。由此，就可以得出$M=W^{\top}\Lambda W$。</p>
<p><strong>关键假设</strong>：上三角(<code>upper-triangular</code>)$\Lambda$. 我们假设，水平较低的人永远无法运行水平较高的预言机。类型$\pi:\lbrace 1,2,3,…,|T| \rbrace \mapsto T$的线性排序将排名位置映射到类型。例如，$\pi(1)\in T$是排序最高的类型。</p>
<p><strong>假设2.5</strong>：我们假设，在类型的适当排序$\pi$下，$\Lambda$是一个上三角矩阵。形式上而言，存在$\pi$使得$\forall i &gt; j, \Lambda_{\pi(i),\pi(j)}=0$。任意能使$\Lambda$为上三角形式的$\pi$都是这些类型的一种有效的思维层次。</p>
<p>在运行示例（例2.2）中，有效的思维层次是$\pi(1)$为类型1，$\pi(2)$为类型0。需要注意的是，在上面的假设中，并不要求$\forall i \leq j, \Lambda_{\pi(i),\pi(j)}&gt;0$，当$\Lambda$为对角矩阵时，类型之间不能相互预测，而且同样复杂，因此任何排序都是有效的思维层次。</p>
<p>给定由未知的<code>w</code>和$\Lambda$生成的<code>M</code>，算法可以寻找其思维层次，并输出矩阵$W^\ast$，它等价于行顺序是有效思维层次的行置换后的<code>W</code>。形式上而言，存在一种有效的思维层次$\pi$使得$W^\ast$的第<code>i</code>行是$W$的第$\pi(i)$行，即$w_i^\ast=w_{\pi(i)}$。</p>
<h3 id="Non-negative-Congruence-Triangularization-NCT"><a href="#Non-negative-Congruence-Triangularization-NCT" class="headerlink" title="Non-negative Congruence Triangularization (NCT)"></a>Non-negative Congruence Triangularization (NCT)</h3><p>在上述模型中，推断思维层次引出了一个新的矩阵分解问题，这个问题类似于对称非负矩阵分解问题(NMF)。</p>
<p><strong>定义2.6</strong>：非负同余三角化(NCT)。给定非负矩阵<code>M</code>，<code>NCT</code>旨在寻找非负矩阵<code>W</code>（是不止一个非负矩阵）和非负上三角矩阵$\Lambda$，使得$M=W^\top\Lambda W$。在一个基于 Frobenius 范数的近似版本中，给定矩阵<code>W</code>的集合，<code>NCT</code>旨在寻找非负矩阵<code>W</code>（是不止一个非负矩阵）和非负上三角矩阵$\Lambda$，从而最小化：</p>
<script type="math/tex; mode=display">\min _{\mathbf{W} \in \mathcal{W}, \boldsymbol{\Lambda}}||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2</script><p>得到的最小值被定义为：<code>M</code>关于$\mathcal{W}$的不适度(lack-of-fit)。</p>
<p>类似NMF，要求结果的严格唯一性是不可能的。令$P_{\Lambda}$表示能使得$\Pi^\top\Lambda\Pi$仍然是上三角的置换矩阵的集合。如果$(W,\Lambda)$是一个解，则当<code>D</code>是所有元素为正数的对角矩阵且$\Pi\in P_\Lambda$时，$(\Pi^{-1}DW, \Pi^\top D^{-1}\Lambda D^{-1}\Pi)$也是一个解。我们将唯一性结果陈述如下，并在附录C中证明。</p>
<p><strong>定理2.7</strong>：唯一性。如果$|T|\leq |A|$，且<code>W</code>的<code>T</code>列包含一个置换正对角矩阵，则$M=W^\top\Lambda W$的<code>NCT</code>是唯一的，因为对于所有的$W’^\top\Lambda’ W’=W^\top\Lambda W$，都存在一个正对角矩阵<code>D</code>和一个$|T|\times |T|$置换矩阵$\Pi\in P_\Lambda$，使得$W’=\Pi^{-1}DW$。</p>
<p>当我们将<code>W</code>限制为半正交时，就可以在不需要寻找最优$\Lambda$的情况下得到<code>NCT</code>的简洁格式。$\mathcal{I}$是所有半正交矩阵<code>W</code>的集合，其中<code>W</code>的每一列有且仅有一个非零元素，且$WW^\top=I$。例如，例2.2中的矩阵<code>W</code>可以被标准化为半正交矩阵，下面的引理来自于 Frobenius 范数的扩展，我们在附录C中进行证明。</p>
<p><strong>引理2.8</strong>：半正交：最小F范数=最大化平方的上三角和。对于所有矩阵$\mathcal{W}\subset \mathcal{I}$的集合，$\min _{\mathbf{W} \in \mathcal{W}, \boldsymbol{\Lambda}}||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2$等价于求解$max_{\mathbf{W} \in \mathcal{W}}\sum_{i\leq j}(\mathbf{W}\mathbf{M}\mathbf{W}^{\top})^2_{i,j}$，且设置$\Lambda$为$Up(\mathbf{W}\mathbf{M}\mathbf{W}^{\top})$，即$\mathbf{W}\mathbf{M}\mathbf{W}^{\top}$的上三角区域。</p>
<p>这里总的来说就是：让回答排名靠前且预测排名靠后的受访者尽量多</p>
<h3 id="Inferring-the-thinking-hierarchy-with-answer-prediction-joint-distribution-M"><a href="#Inferring-the-thinking-hierarchy-with-answer-prediction-joint-distribution-M" class="headerlink" title="Inferring the thinking hierarchy with answer-prediction joint distribution M"></a>Inferring the thinking hierarchy with answer-prediction joint distribution M</h3><p>给定<code>M</code>，推断其思维层次，等价于求解<code>NCT</code>问题。虽然我们并没有<code>M</code>，但我们可以获取其代理。为了简化实际应用，我们基于引理2.8引入了两个简单的排序算法。排序算法以<code>M</code>为输入，输出所有回答的线性排序结果$\pi:\lbrace 1,2,…,|A| \rbrace \mapsto A$，它表示了排序位置到回答的映射。</p>
<p><strong>回答排序算法（默认）</strong>：记作AR(M)，该算法计算</p>
<script type="math/tex; mode=display">
\boldsymbol{\Pi}^* \leftarrow \arg \max _{\Pi \in \mathcal{P}} \sum_{i \leq j}\left(\boldsymbol{\Pi} \mathbf{M} \boldsymbol{\Pi}^{\top}\right)_{i, j}^2</script><p>其中，$\mathcal{P}$是所有$|A|\times |A|$的置换矩阵的集合。对于所有<code>i</code>，在每一个置换矩阵$\Pi$和一个线性顺序$\pi:\Pi_{i,\pi(i)}=1$ 之间都存在一个一对一的映射。因此，最优$\Pi^\ast$会引出所有回答的最优排序，而默认算法也可以表示为：</p>
<script type="math/tex; mode=display">
\pi^* \leftarrow \arg \max _\pi \sum_{i \leq j} M_{\pi(i), \pi(j)}^2</script><p>默认算法隐含假设$|T|=|A|$，且所有预言机都是确定的。为了允许$|T|\leq|A|$和不确定的预言机，我们引入了一个变体，将$\mathcal{P}$推广到半正交矩阵$\mathcal{I}$的一个子集。每一个$|T|\times |A|$的半正交矩阵<code>W</code>表示一个硬聚类，每一类$t\in T$包含了所有使得$W_{t,a}&gt;0$成立的回答。例如，例2.2中的矩阵<code>W</code>可以被标准化为半正交矩阵，并表示一个硬聚类<code>{4},{6,3}</code>。因此，变体算法将把回答划分为多个聚类，并为之分配一个层次结构。</p>
<p><strong>回答排序算法（变体）</strong>：记作$AR^{+}(M,\mathcal{W})$，该算法计算</p>
<script type="math/tex; mode=display">
\mathbf{W}^{*} \leftarrow \arg \max _{\mathbf{W} \in \mathcal{I}} \sum_{i \leq j}\left(\mathbf{W M W}^{\top}\right)_{i, j}^{2}</script><p>其中，$\mathcal{W}\subset \mathcal{I}$。$\mathbf{W}^{\ast}$被标准化为每行之和是1。</p>
<p>$\mathbf{W}^{\ast} \Rightarrow$ Answer rank  输出$\mathbf{W}^{\ast}$表示了所有回答的硬聚类。我们按照如下方式对所有回答进行排序：对于任意$i&lt;j$，聚类<code>i</code>中的回答比聚类<code>j</code>中的回答有着更高的排序。对于所有<code>i</code>，任意两个聚类<code>i</code>中的回答<code>a</code>和<code>a&#39;</code>，如果$W_{i,a}^\ast &gt;W_{i,a’}^\ast$，则<code>a</code>排序高于<code>a&#39;</code>。</p>
<p><strong>理论论证</strong>：当<code>M</code>完全符合模型约束条件，即隐含的<code>W</code>为置换矩阵或硬聚类时，我们的算法就找到了思维层次。否则，我们的算法会找到由 Frobenius 范数度量的“最接近”的解。</p>
<p><strong>定理2.9</strong>：当存在$\Pi_0 \in \mathcal{P}$和非负上三角矩阵$\Lambda_0$使得$\mathbf{M}=\boldsymbol{\Pi}_{0}^{\top} \boldsymbol{\Lambda}_{0} \boldsymbol{\Pi}_{0}$，算法AR(M)可以找到思维层次。一般来说，AR(M)会输出$\boldsymbol{\Pi}^\ast$，其中$\boldsymbol{\Pi}^\ast,\Lambda^\ast = Up(\boldsymbol{\Pi}^\ast M {\boldsymbol{\Pi}^\ast}^\top)$是$\arg \min _{\Pi \in \mathcal{P}, \Lambda}\left|\mathbf{M}-\boldsymbol{\Pi}^{\top} \Lambda \Pi\right|_{F}^{2}$的一个解。把$\mathcal{P}$换成$\mathcal{W}\subset \mathcal{I}$，把AR(M)换成$AR^{+}(M,\mathcal{W})$，上述语句仍然成立。</p>
<p>证明仍然在附录C。</p>
<h3 id="A-proxy-for-answer-prediction-joint-distribution-M"><a href="#A-proxy-for-answer-prediction-joint-distribution-M" class="headerlink" title="A proxy for answer-prediction joint distribution M"></a>A proxy for answer-prediction joint distribution M</h3><p>在实践中，我们没有完美的<code>M</code>。我们使用下面的开放式反应范式来获得<code>M</code>的代理。</p>
<p><strong>回答-预测范式</strong>：受访者会被问两个问题：</p>
<ol>
<li>你的回答是什么？</li>
<li>你认为其他人会回答什么？</li>
</ol>
<p>在圆圈问题中，可能的反馈是：“回答4，预测3”、“回答3，预测6，9，1”等。我们用<code>A</code>表示所有回答的集合。在圆圈问题的例子中，$A=\lbrace 1,2,3,4,6,9 \rbrace$。我们同样允许受访者不进行预测或者预测多个值。</p>
<p><strong>回答-预测矩阵</strong>：我们聚合反馈并通过回答-预测矩阵将其可视化。回答-预测矩阵<code>A</code>是一个$|A|\times |A|$的方阵，其中$|A|$是受访者提供的不同答案的数量。每一项$A_{a,g}, a,g\in A$是回答<code>a</code>且预测<code>g</code>的受访者的数量。</p>
<p>我们将证明，在适当的假设下，回答-预测矩阵<code>A</code>的期望与<code>M</code>成正比。首先，为了便于分析，我们假设每个受访者的预测都是独立样本。其次，由于我们允许人们有选择地提供预测，因此我们还需要假设每个受访者愿意提供的预测数量与她的类型和答案无关。我们将形式化的结果陈述如下，并在附录 C中进行证明。</p>
<p><strong>定理2.10</strong>：当每一个受访者的预测都是独立样本，并且她给出的预测数量与她的类型和答案无关时，回答-预测矩阵<code>A</code> 的期望与<code>M</code>成正比。</p>
<h2 id="Studies"><a href="#Studies" class="headerlink" title="Studies"></a>Studies</h2><p>我们进行了四组研究，分别是：研究1(35道数学题) ，研究2(30道围棋题) ，研究3(44道常识题)和研究4(43道汉字发音题)。</p>
<p><strong>数据收集</strong>：通过在线众包平台发送调查问卷来收集数据，所有受访者被要求不能上网搜索或者与其他人交流，受访者可以填写“我不知道”这样的答案。除围棋问题以外，所有问卷采用定额支付的方式，具体过程在附录A。允许受访者参加多个研究，因为算法分别独立计算每一个问题。</p>
<p><strong>数据处理</strong>：合并等价的答案，例如0.5和50%。忽略那些选择人数小于等于3%或者只有一个人选择的答案。剩下的答案包括“我不知道”共同组成了大小为$|A|$的回答集合。接下来构建回答-预测矩阵并执行算法，伪代码在附录B。本文算法不要求任何先验知识或受访者的专业水平。</p>
<h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>基线算法：投票，即多数一致方案</p>
<p>对比结果：本文的两种算法都比基线算法好</p>
<p>152个问题中，有138个问题变体算法和默认算法得出了相同的思维层次。其他问题中，变体算法得到的排名靠前的答案可能有不止一个。有一个问题，变体算法得到的答案是错的，而默认算法得到的是正确的。</p>
<p>我们同样计算了算法的不适度指标，发现那些算法能输出正确答案的问题都有着低不适度，进而更符合思维层次模型。因此我们可以用不适度作为算法可靠性的指标。</p>
<p>我们还从每个研究中都选取了几个代表性的例子，其矩阵采用默认算法进行排列，对角线区域修改为例1.1所示。所有例子中，多数一致方案得到的答案是错的，而本文算法得到的答案是对的。其他问题的答案在<a href="https://elicitation.info/classroom/1/" target="_blank" rel="noopener">这个网站</a>上有展示。</p>
<p>选出来的题和对应的矩阵如下：</p>
<ol>
<li>Monty Hall 问题（三门问题）：在三个关闭的门中任选一个打开，三个中有一个门后面是车，两个门后面是山羊。当你选好一个以后，Monty Hall会把剩下两个门中的一个打开，并展示说明这个门后面是山羊，然后问你是否要改选另一个门。那么如果你改选了，则你得到车的概率是多少？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-1.png?raw=true" alt="三门问题"></li>
<li>出租车问题：这个城市85% 的出租车是绿色的，其他的都是蓝色的。一个目击者看到一辆蓝色的出租车。她通常正确的概率是80% 。目击者看到的出租车确实是蓝色的概率是多少？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-2.png?raw=true" alt="出租车问题"><br> 说明：这里论文插入的矩阵可能有错，我在数据网站上找到了它的正确矩阵，如下图：<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-9.png?raw=true" alt="出租车问题矩阵"></li>
<li>为黑棋选择一步能使其活下来的走法<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-3.png?raw=true" alt="围棋死活题1"></li>
<li>为黑棋选择一步能使其活下来的走法（原文最后的ko不清楚是指活下来并取胜，还是打错了）<br><img src="https://github.com/likun1208/image/blob/master/ETHP-4.png?raw=true" alt="围棋死活题2"></li>
<li>边界问题：中国和朝鲜交界处的河流是什么？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-5.png?raw=true" alt="常识题1"></li>
<li>中世纪新年问题：中世纪时期新年是哪天？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-6.png?raw=true" alt="常识题2"></li>
<li>“睢”这个字的读音是什么？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-7.png?raw=true" alt="汉字读音题1"></li>
<li>“滂”这个字的读音是什么？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-8.png?raw=true" alt="汉字读音题2"></li>
</ol>
<p>根据这些实验，有以下发现：</p>
<ol>
<li>本文方法能够得到丰富的思维层次，例如在出租车问题中，过往研究认为人们通常会忽略基本比例而报告 “80%”，设想中的层次可以是<code>41%, 80%</code>，而本文则发现了更丰富的思维层次：<code>41%, 50%, 80%, 12%, 15%, 20%</code>。（这里都是按思维水平从专业到普通再到离谱排序的）</li>
<li>最专业的思维水平可能没法预测最离谱的思维水平。例如在出租车问题中，回答了<code>41%</code>的专业人士能预测到常见的错误回答<code>80%</code>，却没法预测到<code>12%, 15%</code>这样比较离谱的回答。反之，回答了<code>80%</code>的普通人却预测到了这种离谱答案。</li>
<li>对于没有明显错误的问题（例如围棋），本文方法仍然有效。</li>
<li>在边界问题中，只有3个人回答了正确答案，但我们的算法仍然在没有任何先验的情况下选出了这个正确答案。</li>
</ol>
<p>上述例子是多数一致方案出错的。在一些多数一致方案正确的问题中，本文算法也能得出更丰富的思维层次。例如，一个题目问：唐太宗李世民什么时候登基？出于启发效应，还补充了一句是大于50岁还是小于50岁？这个题目要求回答年龄，多数一致方案和本文算法都能得出正确答案（28岁）。本文算法得出的思维层次是<code>28,27,30,35,40,50</code>，可以看出来，使用了锚定与调整性法则的回答被本文算法排到了后面，因为其思维层次较简单。</p>
<p>在我们的研究中，人们犯了一些系统性的错误，比如做了一个错误的统计假设(三门问题的“1/2”) ，忽略了基准率(出租车的“80%”) ，使用了可得性启发法，即依赖于易于搜索的记忆(“鸭绿江”，“ Songhua River”，“ju1”，“12月25日，1月1日”) ，回答了一个更容易的替代问题(使用贪婪的动作或看起来优雅的动作，发音成分) ，以及使用锚定与调整性法则(“40,50”李世民问题)[24]。重要的是，我们的实验结果表明，在没有任何先验的情况下，我们的算法将这些错误标记为不那么复杂的思维类型。</p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p><strong>本文算法什么情况下出错</strong>：</p>
<ol>
<li>一些复杂问题，我们没法从任何人那里得到正确答案。</li>
<li>一些回答空间很少的问题，例如只能回答<code>yes</code>或<code>no</code>，每个人都不需要专业知识就能很容易猜到其他人的回答。</li>
<li>不适用于人们同意不同意的情况，因为人们能预测出其他人的回答，但仍然坚持己见。例如在问题“中国古代从哪个朝代开始把最高统治者称为<code>王</code>？”这个问题得出的矩阵如下：<br><img src="https://github.com/likun1208/image/blob/master/ETHP-10.png?raw=true" alt="不合适的问题"><br>正确答案是商，但本文算法排序把周放到了第一位，这可能是因为我们平常总把“夏商周”放到一起提，所以每个人都能猜出来别人的回答，而无需专业知识。如前文所说，可以用不适度来衡量算法是否能找出正确答案。</li>
</ol>
<p><strong>部分顺序与DAG</strong>：我们观察到，在我们的研究中，最专业的人可能不知道最离谱的人的思想。一个潜在的原因是，最专业的人数量很少。另一个潜在的原因是人们有认知限制，他们可能需要大量的努力来推理那些专业程度与他们相去甚远的人。未来的发展方向是通过多种实验来探究其原因。</p>
<p><strong>激励与对手</strong>：本文没考虑激励和奖励设计。同时如果模型中存在对手，对手能比多数一致方案更容易地操控本文的算法。因此未来研究方向一方面是引入激励，另一方面是考虑对手的存在，增加模型稳定性。</p>
<p><strong>开放性问题</strong>：前文所述实验都是已经有确切答案的问题，或虽然是开放性问题，但答案空间由潜在的文字片段或数字组成，我们进一步针对没有确切答案的开放性问题进行了实验，将本文方法扩展到从人群中获取主观意见的场景，例如“为什么酒吧的椅子很高”。这里的关键挑战是自动对人们的意见进行分类，一个可能的方向是与学习算法相结合，另一个挑战是验证得出的层次结构。我们在北大的一个班级里问了酒吧椅子这个问题，并手动统计。回答人数最多的是“因为酒吧柜台很高”，而本文算法排名第一的是“与站着的人有更好的目光接触”。看起来，后者会导致前者进而导致提问中的“椅子很高”，所以本文算法能得到一个更为根本性的回答。</p>
<p><strong>总结</strong>：</p>
<ol>
<li>本文提出了思维层次模型和无先验情况下寻找思维层次的方法</li>
<li>实验说明本文方法的优越性</li>
<li>方法可用于众包的语音识别，图像描述，植物物种识别等</li>
</ol>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><h4 id="默认算法"><a href="#默认算法" class="headerlink" title="默认算法"></a>默认算法</h4><ol>
<li>总体思路是挨个看哪种顺序得到的上三角平方和最大</li>
<li>利用了动态规划的思想，先把矩阵拆成2维的，看2维情况下怎么排列最合适，然后在每一个2维的左上增加三维，看3维怎么排列最合适。</li>
</ol>
<p>这个过程如下图所示：<br><img src="https://github.com/likun1208/image/blob/master/ETHP-11.png?raw=true" alt="默认算法示意图"></p>
<h4 id="变体算法"><a href="#变体算法" class="headerlink" title="变体算法"></a>变体算法</h4><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><h4 id="引理2-8的证明"><a href="#引理2-8的证明" class="headerlink" title="引理2.8的证明"></a>引理2.8的证明</h4><p><strong>引理2.8</strong>：半正交：最小F范数=最大化平方的上三角和。对于所有矩阵$\mathcal{W}\subset \mathcal{I}$的集合，$\min _{\mathbf{W} \in \mathcal{W}, \boldsymbol{\Lambda}}||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2$等价于求解$max_{\mathbf{W} \in \mathcal{W}}\sum_{i\leq j}(\mathbf{W}\mathbf{M}\mathbf{W}^{\top})^2_{i,j}$，且设置$\Lambda$为$Up(\mathbf{W}\mathbf{M}\mathbf{W}^{\top})$，即$\mathbf{W}\mathbf{M}\mathbf{W}^{\top}$的上三角区域。</p>
<script type="math/tex; mode=display">
\begin{array}{l}
||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2 &= Tr((\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W})(\mathbf{M}^\top-\mathbf{W}^{\top} \boldsymbol{\Lambda}^\top \mathbf{W}))\\
& = ||\mathbf{M}||_F^2-Tr(\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}\mathbf{M})-Tr(\mathbf{M}\mathbf{W}^{\top} \boldsymbol{\Lambda}^\top \mathbf{W})+Tr(\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W} \mathbf{W}^{\top} \boldsymbol{\Lambda}^\top \mathbf{W})\\
& = ||\mathbf{M}||_F^2-2Tr(\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}\mathbf{M})+Tr(\mathbf{W}^{\top} \boldsymbol{\Lambda}\boldsymbol{\Lambda}^\top \mathbf{W})\\
& = ||\mathbf{M}||_F^2-2Tr(\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}\mathbf{M})+||\boldsymbol{\Lambda}||_F^2
\end{array}</script><p>接下来，</p>
<script type="math/tex; mode=display">
\begin{array}{l}
||\boldsymbol{\Lambda}-\mathbf{WMW^\top}||_F^2 &=Tr((\boldsymbol{\Lambda}-\mathbf{WMW^\top})(\boldsymbol{\Lambda}^\top-\mathbf{WM^\top W^\top}))\\
&= ||\boldsymbol{\Lambda}||_F^2-2Tr(\mathbf{\Lambda WM^\top W^\top})+||\mathbf{WMW^\top}||_F^2
\end{array}</script><p>需要注意的是：$Tr(\mathbf{\Lambda WM^\top W^\top})=Tr(\mathbf{W^\top \Lambda WM^\top })$，由此可得：</p>
<script type="math/tex; mode=display">
||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2 = ||\boldsymbol{\Lambda}-\mathbf{WMW^\top}||_F^2 -||\mathbf{WMW^\top}||_F^2+||\mathbf{M}||_F^2</script><p>因此，</p>
<script type="math/tex; mode=display">
\underset{\mathbf{W}, \boldsymbol{\Lambda}}{\arg \min }\left\|\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}\right\|_{F}^{2}=\underset{\mathbf{W}, \boldsymbol{\Lambda}}{\arg \min }\left\|\boldsymbol{\Lambda}-\mathbf{W} \mathbf{M} \mathbf{W}^{\top}\right\|_{F}^{2}-\left\|\mathbf{W} \mathbf{M} \mathbf{W}^{\top}\right\|_{F}^{2}</script><p>最优上三角矩阵$\boldsymbol\Lambda^\ast$ 应该是$\mathbf{W} \mathbf{M} \mathbf{W}^{\top}$的上三角部分，即，对于所有$i\leq j$，$\Lambda_{i,j}^\ast=\mathbf{W} \mathbf{M} \mathbf{W}^{\top}_{i,j}$。当$\Lambda$取最优时，$||\boldsymbol{\Lambda}^{*}-\mathbf{W M W}^{\top}||_{F}^{2}-||\mathbf{W M W}^{\top}||_{F}^{2}$就等于$-\sum_{i\leq j}(\mathbf{W M W}^{\top})_{i,j}^2$。因此，$\min _{\mathbf{W} \in \mathcal{W}, \boldsymbol{\Lambda}}||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2$等价于求解$max_{\mathbf{W} \in \mathcal{W}}\sum_{i\leq j}(\mathbf{W}\mathbf{M}\mathbf{W}^{\top})^2_{i,j}$。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>crowdsourcing</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Using game theory to thwart multistage privacy intrusions when sharing data</title>
    <url>/2022/09/23/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Using%20game%20theory%20to%20thwart%20multistage%20privacy%20intrusions%20when%20sharing%20data/</url>
    <content><![CDATA[<h1 id="Using-game-theory-to-thwart-multistage-privacy-intrusions-when-sharing-data"><a href="#Using-game-theory-to-thwart-multistage-privacy-intrusions-when-sharing-data" class="headerlink" title="Using game theory to thwart multistage privacy intrusions when sharing data"></a>Using game theory to thwart multistage privacy intrusions when sharing data</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>问题：针对个人的生物医学数据共享引起的隐私问题，尤其是匿名记录的再识别</p>
<p>思路：再识别风险评估框架</p>
<p>常规方法：数据接收者只使用一种资源</p>
<p>存在问题：攻击者可以访问多种资源来增加攻击成功率</p>
<p>本文方法：构建完全信息双人Stackelberg博弈模型来表示再识别博弈，提出基于隐私-效用权衡的最优数据共享策略</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>背景：生物医学数据共享有很大好处，但带来隐私问题</p>
<p>面临的问题：针对匿名生物医学数据的再识别攻击</p>
<ol>
<li><p>简化的攻击模型会导致隐私风险被高估或低估；</p>
</li>
<li><p>攻击逐渐从过去的单阶段（将去除标识符的数据库与没有去除标识符的数据库通过一些共有属性链接起来）转变为现在的多阶段（每阶段披露目标个体的一部分信息）</p>
</li>
</ol>
<p>本文：通过明确建模和量化数据主体在面对多阶段攻击时的隐私-效用权衡来评估和战略性地减轻风险，弥补了更复杂的攻击模型和数据共享决策之间的差距。</p>
<p>攻击模型：Gymrek提出的两阶段攻击——针对基因组计划数据库的姓氏推断与进一步的其他数据库链接推断</p>
<p>现有方法：</p>
<ol>
<li><p>从监管和技术两个角度出发</p>
</li>
<li><p>关注最坏的情况——影响不明确</p>
<ol>
<li><p>不考虑攻击成本——高估隐私风险</p>
</li>
<li><p>没有测量参数影响就设置参数——牺牲数据效用</p>
</li>
</ol>
</li>
<li><p>由此出现了引入博弈论的风险评估</p>
</li>
</ol>
<p>本文：</p>
<ol>
<li><p>博弈论模型可以向数据主体揭示最佳的共享策略</p>
</li>
<li><p>使用真实世界的数据集或大规模模拟数据集进行反多阶段攻击的实验</p>
</li>
<li><p>博弈论模型可以有效地评估和有效地减轻隐私风险</p>
</li>
<li><p>模型所推荐的细粒度共享策略可以最大限度地减少数据主体被成功再识别的可能性，同时最大限度地提高数据效用，并保持发布的数据集的有效性和数据共享过程的公平性</p>
</li>
</ol>
<h2 id="Materials-and-Methods"><a href="#Materials-and-Methods" class="headerlink" title="Materials and Methods"></a>Materials and Methods</h2><p>研究场景：数据主体选择在公共库中分享多少主体的基因数据</p>
<p>研究目标：决定主体的最优共享策略，平衡数据共享带来的经济效益与再识别风险</p>
<p>再识别风险来源：</p>
<ol>
<li><p>有动机和手段试图确定匿名共享数据集中的主体身份的人</p>
</li>
<li><p>已经向公众提供的关于主体的其他数据</p>
</li>
</ol>
<p>攻击模型：Gymrek攻击</p>
<ol>
<li><p>第一阶段：根据目标基因库和遗传族谱数据库进行姓氏推断</p>
</li>
<li><p>第二阶段：将姓氏推断结果和公共数据库进行链接，从而确定数据主体的身份</p>
</li>
</ol>
<p>博弈模型：Stackelberg 博弈 或 leader-follower 博弈</p>
<ol>
<li><p>假设数据主体和攻击者对攻击成功的概率有相同的信念</p>
</li>
<li><p>数据主体作为leader，选择共享多少数据</p>
</li>
<li><p>攻击者作为follower，选择是否进行再识别攻击</p>
</li>
<li><p>攻击者不知道被隐藏的信息，只能估计成功的概率，而数据主体则掌握更多信息</p>
</li>
</ol>
<p>主体决策：$s=\langle s_1,…,s_j,…,s_m \rangle \in B^m$ 表示要共享的数据，其中<code>m</code>是记录中的属性数量，如果第<code>j</code>个属性被隐藏，则$s_j=0$，反之如果第<code>j</code>个属性被共享，则$s_j=1$</p>
<p>攻击者决策：$a\in \{0,1\}$表示是否进行再识别攻击，<code>a=1</code>表示攻击，<code>a=0</code>表示不攻击</p>
<p>对手攻击方式：两阶段Gymrek攻击，可以有更多个阶段，每阶段推断出一些新的信息</p>
<p>博弈过程：主体（leader）先决定自己的策略<code>s</code>，攻击者（follower）观察数据并基于此决定是否攻击，即攻击者的策略是主体策略的函数</p>
<p>引入新的符号和假设：</p>
<ol>
<li><p>$b(s)$表示策略<code>s</code>为主体带来的经济效益，公开信息，假设该函数非递减</p>
</li>
<li><p>如果一个记录成功被再识别，假设该主体损失<code>L</code>，攻击者获得<code>L</code></p>
</li>
</ol>
<p>攻击成功的概率取决于数据主体采取的策略，数据主体对这个概率以及再识别风险比攻击者更清楚，攻击者只能大致估计。</p>
<p>首先，假设数据主体和攻击者对每个策略分配的成功率都相同，记作$p(s)$。在已知$p(s)$的情况下，数据主体和攻击者可以最大化各自的期望收益。</p>
<p>然后，将期望收益视作真实收益，可得完美信息下的Stackbelberg博弈，并研究均衡。</p>
<p>数据主体的期望收益函数：$v_d(s,a)=b(s)-Lp(s)a$</p>
<p>攻击者的收益函数：$v_a(s,a)=(Lp(s)-C)a$</p>
<p>其中，<code>C</code>是攻击者的攻击成本</p>
<ol>
<li><p>如果攻击者不攻击则其收益为0</p>
</li>
<li><p>可以通过重定义$b(s)$和重识别$p(s)$将该模型推广到其他数据共享的场景中</p>
</li>
</ol>
<p>令$\phi(s)=\{a|(Lp(s)-C)a\geq(Lp(s)-C)(1-a)\}$，函数$\phi(s)$表示攻击者针对主体策略<code>s</code>的最优策略</p>
<p>均衡解对应的主体优化问题：$max_{s,a\in\phi(s)}b(s)-Lp(s)a$</p>
<p>主体求解方法：逆向归纳法——先计算攻击者对所有可能策略<code>s</code>的最优对策$\phi(s)$，然后选择自己的最优策略。</p>
<p>该方法问题：数据主体掌握了完整的数据，因此他们可以计算再识别概率$p(s)$，而攻击者则不能。</p>
<p>解决方法：攻击者使用再识别概率的估计值，记作$\hat{p}(s)$，并以此计算自己的收益和最优对策函数。数据主体同样可以用估计值来计算攻击者的策略，但他们会随后用真实的再识别风险概率计算自己的最优选择。</p>
<p>总结一下：攻击者和数据主体都可以用$\hat{p}(s)$来估计计算$\phi(s)$，记作$\hat\phi(s)=\{a|(L\hat{p}(s)-C)a\ge(L\hat{p}(s)-C)(1-a)\}$，在得到攻击者最优策略后，数据主体使用真实概率计算自己的最优策略$max_{s,a\in\hat\phi(s)}b(s)-Lp(s)a$。</p>
<blockquote>
<p>说明：利用了Stackelberg博弈中leader只能做一次决策这一特点，使得该方法可以在计算过程中使用不同的再识别风险概率函数。</p>
</blockquote>
<p>在两阶段攻击中，给定主体策略<code>s</code>，第一阶段攻击成功概率$p_1(s)$、在一阶段攻击成功基础上的第二阶段攻击成功概率$p_2(s)$、攻击者估计的一阶段成功概率$\hat{p}_1(s)$、攻击者估计的忽略一阶段情况下二阶段成功概率$p’(s)$的计算方式如下：</p>
<script type="math/tex; mode=display">
p(s)=p_1(s)p_2(s)a'(s)+p'(s)(1-a'(s))    \\
\hat{p}(s)=\hat{p}_1(s)p_2(s)a'(s)+p'(s)(1-a'(s))\\
a'(s)=\left\{
\begin{aligned}
1,\hat{p}_1(s)p_2(s) > p'(s)\\
0, \hat{p}_1(s)p_2(s)\le p'(s)
\end{aligned}
\right.</script><p>如果一阶段攻击更好，则$a’(s)$为1，反之则为0. 上面几个参数的具体值取决于攻击模型和攻击中用的数据集。</p>
<p>由此，如果$a’(s)$为1，优化问题可以表达为：</p>
<script type="math/tex; mode=display">
max_{s,a\in\hat{\phi}(s)}b(s)-Lp_1(s)p_2(s)a</script><p>其中，$\hat\phi(s)=\{a|(L\hat{p}_1(s)p_2(s)-C)a\ge(L\hat{p}_1(s)p_2(s)-C)(1-a)\}$</p>
<p>详细推公式过程在附录，稍后再看。</p>
<blockquote>
<p>所有的参数都可以根据用例进行合理的设置。具体来说，它们可以根据特定的数据集、攻击模型或受试者提供的估价进行调整。此外，正如结果所示，广泛的敏感性和稳健性分析（即压力测试）可以帮助验证参数设置对环境或主体知识的不确定性的敏感性和稳健性。</p>
</blockquote>
<p>选择进入博弈：在一些情况，数据主体只有两种选择：加入并完全共享信息 或者 退出不共享任何信息。这样的场景可以由前文定义的博弈来刻画，其数据主体的策略被限制为两个选项：完全共享$s=<1,...1>$和完全不共享$s=<0,...0>$。</p>
<p>遍历求解博弈耗时多，附录中介绍了可以用于加速求解的算法，稍后再看。</p>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><h3 id="Experimental-design"><a href="#Experimental-design" class="headerlink" title="Experimental design"></a>Experimental design</h3><p>分别在真实数据集和仿真数据集上进行实验，后者更大一些</p>
<p>在基因数据集<code>D</code>中共享数据的<code>n</code>个数据主体的平均收益：$\overline{V}=\sum_{i=1}^{n}V_i$，其中$V_i$表示第<code>i</code>个数据主体的最优收益</p>
<p>平均数据效用：$\overline{U}=\sum_{i=1}^{n}U_i$</p>
<p>主体平均隐私：$\overline{P}=\sum_{i=1}^{n}P_i$</p>
<p>第<code>i</code>个数据主体的数据效用：$U_i=b(s_i^\ast)/B$，即部分共享带来的收益除以完全共享带来的收益</p>
<p>第<code>i</code>个数据主体的隐私：$P_i=1-p(s_i^\ast)a_i^\ast$，即1减去隐私风险（被成功攻击的概率）</p>
<p>第<code>i</code>个数据主体的最优收益：$V_i=v_d(s_i^\ast, a_i^\ast)=BU_i-L(1-P_i)=BU_i+LP_i-L$，即数据效用和隐私的线性组合，其中，<code>L</code>是再识别成功带来的损失。</p>
<blockquote>
<p>作为有效性的主要衡量标准，这些主体的平均报酬与效用和隐私的衡量标准呈正相关。</p>
</blockquote>
<p>实验设置：20个模拟数据属性，4个博弈场景，4个baseline场景，8种数据保护情况</p>
<p>攻击者目标：在理性权衡攻击收益的基础上，尽可能再识别数据集<code>D</code>中的所有数据。</p>
<p>8种情况的简要说明：</p>
<ol>
<li><p>no protection：无保护，数据集<code>D</code>中的每个主体都共享其数据记录中的所有属性</p>
</li>
<li><p>demographics only：数据集<code>D</code>中的每个主体仅共享人口统计学属性</p>
</li>
<li><p>random opt-in：数据集<code>D</code>中的每个主体根据实际设置，以一定的概率随机决定共享整个数据记录</p>
</li>
<li><p>random masking：数据集<code>D</code>中的每个主体随机决定以固定的概率分享其数据记录中的每个属性</p>
</li>
<li><p>opt-in game：主体只能决定选择加入共享整个数据记录或选择退出</p>
</li>
<li><p>masking game：主体可以在共享前隐藏一部分数据</p>
</li>
<li><p>no-attack masking game：假设主体不选择任何会使对手攻击的策略</p>
</li>
<li><p>one-stage masking game：假设攻击只有一阶段，二阶段的那个数据集不可用</p>
</li>
</ol>
<p>评估在每种情况下采用的数据保护/共享策略的效果：有用性和公平性</p>
<ol>
<li><p>数据共享方案的有用性是基于共享数据和未受保护数据的分布之间的距离（详见附录S7）。</p>
</li>
<li><p>数据共享方案的公平性（例如，有用性方面的公平性或隐私方面的公平性）是基于每个人口群体对应的具体措施的基尼系数（详见附录S8）。</p>
</li>
</ol>
<h3 id="Experiments-based-on-a-large-scale-simulated-population"><a href="#Experiments-based-on-a-large-scale-simulated-population" class="headerlink" title="Experiments based on a large-scale simulated population"></a>Experiments based on a large-scale simulated population</h3><p>这部分是针对大规模仿真数据的实验</p>
<p>从平均收益来看有以下结论：</p>
<ol>
<li><p>受试者的平均收益在没有保护的情况下是最低的，在有掩膜的博弈中是最高的。</p>
</li>
<li><p>与选择进入博弈相比，受试者的平均收益在掩膜博弈中得到了很大的改善。说明在数据共享过程中提供某种程度的细化选择的基本优势之一。</p>
</li>
<li><p>当攻击者使用较少的数据资源，从而在攻击中保持较少的阶段时，掩膜博弈效果更好。</p>
</li>
<li><p>无论是共享所有的数据还是只分享人口统计资料，或者是一个随机的策略，都会给受试者带来负的或可忽略的平均回报。</p>
</li>
</ol>
<p>从效用与隐私的结合看有以下结论：</p>
<ol>
<li><p>与其他情况相比，掩膜博弈能同时实现高效用和高隐私</p>
</li>
<li><p>受试者在无攻击掩膜博弈中的策略在大量共享数据的情况下保证了完全的隐私保护</p>
</li>
<li><p>当攻击只有一个阶段时，还能实现稍高的数据效用水平</p>
</li>
<li><p>与掩膜博弈相比，随机选择加入场景和随机掩膜场景给受试者带来了类似的隐私水平，但数据效用的水平却低得多</p>
</li>
<li><p>相比之下，与选择加入游戏相比，纯人口统计学方案给受试者带来类似的效用水平，但隐私水平较低</p>
</li>
<li><p>与无保护方案的结果相比，纯人口统计学方案总是为主体提供高得多的隐私水平，这突出了Gymrek攻击中姓氏推理阶段的力量</p>
</li>
<li><p>在博弈论的保护下，姓氏推断阶段的力量可以减少到最低限度，这一点从掩膜博弈和它的单阶段变化之间的差异可以看出</p>
</li>
</ol>
<p>其他实验现象就不细看了，总结下来都是说掩膜博弈在效用、公平性、有用性这几方面更好。</p>
<p>还分析了后向归纳和剪枝贪婪在不同场景的计算效率。</p>
<h3 id="Sensitivity-and-robustness-analyses-on-parameters-and-settings-based-on-simulated-datasets"><a href="#Sensitivity-and-robustness-analyses-on-parameters-and-settings-based-on-simulated-datasets" class="headerlink" title="Sensitivity and robustness analyses on parameters and settings based on simulated datasets"></a>Sensitivity and robustness analyses on parameters and settings based on simulated datasets</h3><p>这部分仍然是大规模仿真数据，分析了在攻击成本、数据集记录数和再识别成功数这三方面的敏感性和稳定性。</p>
<p>实验设置：8个场景，11组实验，针对不同的参数使用不同的测试集进行了20次实验</p>
<p>实验结论：掩膜博弈更好</p>
<p>一些其他与各参数相关的实验不记录了，与博弈无关，更偏向生物医学</p>
<p>此外，分析了少数人支持系数，说明了掩膜博弈在公平性方面同样优秀</p>
<h3 id="Experiments-based-on-Craig-Venter’s-data-and-the-Ysearch-dataset"><a href="#Experiments-based-on-Craig-Venter’s-data-and-the-Ysearch-dataset" class="headerlink" title="Experiments based on Craig Venter’s data and the Ysearch dataset"></a>Experiments based on Craig Venter’s data and the Ysearch dataset</h3><p>这部分是真实数据集的实验，同样说明了掩膜博弈更好。</p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>本文：针对再识别攻击，为数据主体提供共享策略</p>
<p>发现：</p>
<ol>
<li><p>额外阶段会增加再识别的准确率，但同样更有利于我们通过博弈的方式反攻击，因为可以误导攻击者从而使其推断出错误的中间信息，从而减轻隐私风险。</p>
</li>
<li><p>如果数据库不允许进行部分数据共享（即：只能加入并完全共享或者退出），大多数理性的数据主体会选择退出；反之，如果允许部分共享，则大多数主体愿意共享大部分数据，这表明向主体提供选择可以鼓励更大程度的数据共享，同时避免再识别。</p>
</li>
<li><p>本文方案使得主体可以选择共享大量数据，获取高收益，同时不会面临再识别风险。</p>
</li>
<li><p>敏感性分析说明了参数对主体策略的影响，由此能进一步研究：政策制定者如何增加对隐私泄露的惩罚、数据持有者如何增加对数据共享的奖励等。</p>
</li>
</ol>
<p>不足之处和后续研究：</p>
<ol>
<li><p>仅考虑了一个攻击者和两阶段攻击实验</p>
</li>
<li><p>使用的决策模型较为简单，假设数据主体之间的决策相互独立，或所有主体选择相同的策略</p>
</li>
<li><p>目前的博弈模型所模拟的博弈双方并没有完全推理出所有的不确定性。双方都可能有不完全和/或不完善的信息。为了更加现实，可以使用更复杂的博弈论模型，如贝叶斯博弈，来模拟不完全和/或不完善的信息</p>
</li>
<li><p>没有研究数据持有者的最优策略，它们有动机控制付给数据主体的报酬</p>
</li>
<li><p>博弈模型可能会在发布的数据集中引起非随机缺失（MNAR）的值，这对数据集的使用可能会有不可忽略的影响</p>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>stackelberg game</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Budgeted Unknown Worker Recruitment for Heterogeneous Crowdsensing Using CMAB</title>
    <url>/2022/09/11/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Budgeted%20Unknown%20Worker%20Recruitment%20for%20Heterogeneous%20Crowdsensing%20Using%20CMAB/</url>
    <content><![CDATA[<a id="more"></a>
<p>这篇论文是在<a href="https://likun1208.github.io/2020/07/05/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Combinatorial%20Multi-Armed%20Bandit%20Based%20Unknown%20Worker%20Recruitment%20in%20Heterogeneous%20Crowdsensing/https://likun1208.github.io/2020/07/05/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Combinatorial%20Multi-Armed%20Bandit%20Based%20Unknown%20Worker%20Recruitment%20in%20Heterogeneous%20Crowdsensing/">之前看过的论文</a>的基础上扩展的，因此前面的内容暂时先不看，直接看多出来的部分，这部分针对的问题是一些workers总被分配任务而另一些则没有任务。</p>
<h2 id="FAIRNESS-CONSTRAINT-OF-WORKERS"><a href="#FAIRNESS-CONSTRAINT-OF-WORKERS" class="headerlink" title="FAIRNESS CONSTRAINT OF WORKERS"></a>FAIRNESS CONSTRAINT OF WORKERS</h2><p>公平性：众包平台必须保障每一个worker的最小选择频率，从而避免出现一些workers任务很多而另一些没有任务的场面。</p>
<p>因为：没任务的workers会永久性离开平台，导致workers数量减少，这有损于其他requesters的数据结果。因此公平性约束潜在地保障了所有requesters的全局长期传感性能。</p>
<p>方法：</p>
<ol>
<li><p>引入参数$\eta_i$：多轮招募中第$i$个worker至少被招募的部分</p>
</li>
<li><p>公平性约束：$\liminf _{B \rightarrow \infty} \mathbb{E}\left[n_i(\tau(B))\right] \geq \tau(B) \cdot \eta_i$, for $\forall i \in \mathcal{N}$</p>
<p>其中，$\tau(B)$表示预算为B时招募的总轮数，$n_i(\tau(B))$表示预算为B时第i个worker被招募的总轮数</p>
</li>
<li><p>引入虚队列，队列长度计算：$V_i(t)=\max \left\{0, V_i(t-1)+\eta_i-\mathbb{I}\left\{i_{t-1}=i\right\}\right\}$</p>
</li>
<li><p>将队列长度也纳入多臂赌博机的计算公式中：</p>
<script type="math/tex; mode=display">
p_{i}^{l}=\underset{p_{i^{\prime}}^{l^{\prime}} \in\left(\mathcal{P} \backslash \mathcal{P}^{t}\right)}{\operatorname{argmax}}\left\{\frac{u_{\left[\widehat{q}_{i}(t-1)\right]}\left(\mathcal{P}^{t} \cup\left\{p_{i^{\prime}}^{l^{\prime}}\right\}\right)-u_{\left[\widehat{q}_{i}(t-1)\right]}\left(\mathcal{P}^{t}\right)}{c_{i^{\prime}}^{l^{\prime}}}+\varrho \cdot V_{i}(t)\right\}</script></li>
</ol>
<ol>
<li>其余内容没有改变</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>Combinatorial Multi Armed Bandit</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Theories of Bargaining Delays</title>
    <url>/2022/08/31/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Theories%20of%20Bargaining%20Delays/</url>
    <content><![CDATA[<h1 id="Theories-of-Bargaining-Delays"><a href="#Theories-of-Bargaining-Delays" class="headerlink" title="Theories of Bargaining Delays"></a>Theories of Bargaining Delays</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>各类争端的解决过程中可能会出现罢工、谈判等延迟现象，而这是有代价的。博弈论说明程序性特征可能会导致拖延，但主要原因可能是各方之间的信息差异。本文描述了几个模型，并与罢工的数据相关。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>商业和法律场景广泛存在着讨价还价，而这带来了各方面的有代价的延迟。如果参与者知道最终达成的结果本应能在更早的时候以更低的代价达成，则会觉得遗憾。这是发生冲突的双方在利益分配上的对立所引起的，每个人都相信坚持自己的利益值得付出延迟的代价。</p>
<p>以其他领域的类似的场景为例：</p>
<ol>
<li><p>昂贵的经济和政治斗争发生在竞争公司之间的市场份额竞争（价格战）</p>
</li>
<li><p>国家之间的军备竞赛和战争</p>
</li>
<li><p>其他 “霍布斯式 “的背景下的事情</p>
</li>
</ol>
<p>这些例子是缺乏可执行合同和支付手段的讨价还价的变种。同样，动物之间为争夺配偶或猎物而进行的战斗也会选择赢家；其代价是受伤或能量消耗。</p>
<p>然而，在一些物种中，会通过事先进行的锦标赛建立等级制度；在其他物种中，会通过仪式化的战斗降低竞争成本。这些例子表明，一些优势的竞争是信息性的，揭示了参与者的相对实力。在经济背景下，公平分配的行为规范和道德规则模仿了仪式化解决冲突的效果。</p>
<p>前文所提到的个人激励（也就是利益）会促进双方为分蛋糕而付出高昂的代价，这促使人们尝试改善讨价还价的过程——替代性争议解决方案：</p>
<ol>
<li><p>雇用第三方调解员来加强沟通并提出妥协方案</p>
</li>
<li><p>由仲裁员对争论进行判断并作出有约束力的决定</p>
</li>
</ol>
<p>针对替代程序的潜力分析，现有研究侧重于如何快速解决谈判的基本障碍。本文提出了来自博弈论的一些结论：</p>
<ol>
<li><p>在实践中，讨价还价受到公平观念和强烈情绪的影响。博弈论的表述从这些方面进行了抽象，以找到与每一方不懈的优化行为相一致的结果范围。</p>
</li>
<li><p>一个主要目的是确定允许或要求延迟达成协议的情况。拖延是低效率的一个重要来源，在这些数据中可以观察到的是罢工时间，但它不是唯一的一个。其他的可能性是低效的合同条款，以及当存在互利协议时却未能达成协议。</p>
</li>
</ol>
<p>博弈论所引用的假设是严格的。最大化行为的假设通过以下假设得到了加强：各方都确切地知道管理这一过程的程序规则，并且他们有强大的计算能力。程序的固定性排除了用自然语言的自由流动来传达信息和意图的谈判；相反，语言被限制在提议、接受或拒绝，以及诸如罢工的补充决定。然而，它使人们能够研究替代程序的效果和各方之间的信息差异。计算包括选择自己的策略，以及不太可信的对对方策略的预期。这种均衡的假设——各方的策略都是对对方的最佳反应——是博弈论的一个标志。它不是一个规范性的公理，也不是对经验事实的近似，充其量是模糊的，它是识别快速解决谈判的根本障碍的先决条件。为了获得有用的结果，需要一个更强有力的假设：每一方的策略不仅在最初是最优的，而且在随后的每一个突发事件中也是最优的。这一限制排除了一种策略：其最初的最优性取决于用一种不可思议的威胁来恐吓另一方，从这个意义上说，执行这种威胁并不是最优。</p>
<p>虽然是限制性的，但这些假设使我们能够把讨价还价作为一个策略问题来分析，并以程序规则和有关各方的偏好和信息的数据为条件。这种分析模式与基于公理的规范或道德标准的分析，或基于从行为规律性得出的经验预测的分析形成了对比。我们首先回顾了强调程序性规则影响的模型，然后描述了信息差异的影响。</p>
<h2 id="Models-of-Procedural-Effects"><a href="#Models-of-Procedural-Effects" class="headerlink" title="Models of Procedural Effects"></a>Models of Procedural Effects</h2><p>一个基本的例子：买卖双方针对价值为$v$的商品进行讨价还价，卖家的供应成本是$c$，且$v&gt;c$。</p>
<p>$t$时刻双方就价格$p$达成共识这一结果意味着：这次交易的利润在分蛋糕（总量为$v-c$）时，卖家分到的是$p-c$，买家分到的是$v-p$。一个简单的过程是双方交替报价：以$\Delta$为时间间隔将讨价还价的时间划分为离散的时间段，一方报价后另一方在下一个时间段立即选择同意或者再次报价。</p>
<p>我们考虑所有延迟代价的可能性中的两种极端情况：</p>
<ol>
<li><p>代价与延迟成正比，因此卖方净赚$p-c-d_st$，买方净赚$v-p-d_bt$，其中参数$d_s$和$d_b$是卖方和买方在每个延迟时间段里产生的成本。</p>
</li>
<li><p>它们代表了投资收益中放弃的利息收益，即卖方净赚$[p-c]\delta_s^t$，买方净赚$[v-p]\delta_b^t$。参数$\delta_s$和$\delta_b$是反映利率$r_s$和$r_b$的贴现因子。例如：$\delta_s=e^{-r_s\Delta}$。</p>
</li>
</ol>
<p>法律和仲裁的背景增加了一个特点，即在某个时候，如果双方仍有分歧，则由法官对争议进行裁决。</p>
<p>它规定了一个明确的程序，并且偏好表现出对解决的不耐烦，在这个意义上，延迟是昂贵的。这个例子的一个主要预测是，协议立即发生，均衡价格是唯一的。唯一性需要详细的证明，但由此产生的没有延迟是合理的：延迟的协议会被双方预料到，因此在任何较早的时间，提议的一方可以提供对双方有利的条款。例如，卖方可以提前提出一个较高的价格，而买方宁愿接受这个价格，也不愿承担等待以后预期的较低价格的成本。</p>
<p>均衡价格取决于谁第一个报价。如果卖家报价$p_s$，买家报价$p_b$，则$p_s$是买家为了在下一轮能报价$p_b$的不能拒绝的最高价格，而$p_b$是卖家不能拒绝的最低价格并在下一轮中报价$p_s$。</p>
<p>在第2种情况下（延迟成本等价于投资收益中放弃的利息收益），这两个价格由下面的公式决定：</p>
<script type="math/tex; mode=display">
v-p_s=[v-p_b]\delta_b\\
p_b-c=[p_s-c]\delta_s</script><p>这个公式粗浅的理解如下：左边是最初报价就达成共识的收益，右边是讨价还价后用贴现因子折算之后的收益，如果上述等式成立，则说明，如果第一轮是卖家报价，则该报价所对应的买家收益，与之后买家自己报价折算后的收益相等；如果第一轮是买家报价，则该报价所对应的卖家收益，也与之后卖家自己报价折算后的收益相等。由此达成均衡。在这种情况下，当利率相近且报价之间的时间间隔较小时，任何一种价格都能提供几乎均匀的分红。</p>
<p>而在第一种情况下，则会产生一种不对称的分蛋糕结果：成本较小的一方如果能先报价，则会得到整个蛋糕，反之，则会得到除了能抵消对方成本以外的剩下蛋糕。如果某一方有替代选项，例如买家能去其他地方以价格$p$购买该商品，则当卖家先报价时，预测价格是$p$和$p_s$中较小的一个。</p>
<p>在这个例子中，拖延显然是没有必要的。如果各方能预见到最终的分裂，而且程序允许更早的解决，那么他们就有动力迅速决定事情。类似的主张也适用于Mnookin和Kornhauser(7)研究的 “法律阴影下的讨价还价”。在法律索赔的审前讨价还价中，如果法院对纠纷的最终解决方式事先是明确的，那么当事人就有强烈的动机去和解。Bulow和Rogoff(8)提供了这些观点的另一个应用，即银行和主权国家之间关于重组债务合同的讨价还价。</p>
<p>然而，这个命题需要限定，为了说明这一点，我们描述了一个支持多个均衡的程序性修改，从而使得延迟是必要的。假设时间是连续的，且参数$\Delta$和$\Delta’$表示两个固定的时间段。每一方可以在任意时间$t\ge0$提出一个价格，只要他在对方上一轮报价后至少等待了$\Delta$，且在他自己上一轮报价后至少等待了$\Delta’$（如果自己有上一轮报价的话）。当一方重复另一方的报价或他们同时提出相同的价格时，就达成了协议。这种修改后的程序有一个优点，即它减轻了对报价时间的限制。然而，作为均衡结果，它允许在零时和更晚的时间有广泛的价格；因此，延迟是可能的，但不是必须的。拖延的近因是立即达成协议的多样性，允许对任何试图提前解决的人附加 “烙印”。</p>
<p>假设当他们都保持沉默直到同时报价$p^0$时，一个价格为$p^0$的延迟协议出现，接下来的内容完全没有看懂，大致意思是说，这个修改了程序的讨价还价博弈由于有着多重均衡，而使得博弈双方总是无法达成共识，从而导致了延迟的出现。这种延迟是所有允许多重均衡的博弈的特点。事实上，如果同时提出的建议被排除在外，比如说通过忽略其中一个建议，那么同样存在着一个唯一的均衡，没有延迟。</p>
<p>多重性也会在其他博弈程序中出现。Fernandez和Glazer[10]分析了以工会和公司之间的讨价还价为例的在固定间隔内交替报价的程序，新增的一个特点是在每个没有就新合同达成协议的时期，工会可以选择罢工或者按前一个合同规定的工资工作[11]。工会可利用的这种报复性选择的多重性，允许有一系列的即时工资协议；因此，就像前面的例子一样，仪式性的延迟也是可能的。</p>
<p>第二个条件是，各方必须能够预见最终的协议。当任何一方拥有关于该过程的某些方面的私人信息时，这一点就失效了。例如，在法律背景下，一方可能知道受制于证据或随后在审判证词中披露的信息。其他的可能性是，程序是模糊的，或者任何一方对另一方的偏好不确定。我们用后者来说明私人信息的影响。</p>
<h2 id="Models-of-Informational-Effects"><a href="#Models-of-Informational-Effects" class="headerlink" title="Models of Informational Effects"></a>Models of Informational Effects</h2><p>关于信息差异如何导致延迟，有三个主要例子被研究。根据参考文献[12]，我们把它们称为损耗、筛选和信号的模型。</p>
<h3 id="Attrition-损耗"><a href="#Attrition-损耗" class="headerlink" title="Attrition 损耗"></a>Attrition 损耗</h3><p>损耗模型假设偏好符合情况1，但是每一方都不确定其他人的延迟成本，只假设其符合一个确定的概率分布。虽然是为了描述动物之间为生存或繁殖而竞争而开发的，但损耗模型也适用于讨价还价。因为它的成本是相互的，延迟类似于一场战斗，以确定较强的一方（成本较小的一方），然后像上面的基本模型一样要求得到整个蛋糕。损耗模型恰当地描述了为生存或市场份额而竞争的公司之间的军备竞赛和价格战，以及其他隐性议价的情况。它们捕捉到了回顾性的遗憾感：如果一开始就确定较强的一方，那么战斗的浪费是可以避免的；但悲剧的是，战斗可能是对实力的唯一可信的测试。双方的动机前瞻性地说明了一类更广泛的声誉模式：每一方的持续斗争都是对可能更强大的声誉的投资，如果对方先投降，就能获得有利的回报。</p>
<p>损耗模型似乎与工资和价格的明确讨价还价不太相关，因为它们依赖于影响利润的延迟成本的信息隐私，而且它们对赢家通吃结果的预测似乎不现实。</p>
<h3 id="Screening-筛选"><a href="#Screening-筛选" class="headerlink" title="Screening 筛选"></a>Screening 筛选</h3><p>筛选模型通常假设偏好符合情况2，在最简单的版本中，卖方对买方的估价是不确定的。尽管$v$对买方来说是已知的，但卖方认为它是一个符合某一公开的概率分布的随机变量。我们进一步简化，假设卖方在离散时间$t=0,\Delta,2\Delta,…$时进行报价。</p>
<p>在这个版本中，卖方使用 “撇脂 “策略对买方的可能类型进行排序。也就是说，他提供连续较低的价格，直到买方接受。这种策略利用了高价值买家对交易的不耐烦。买家等待低于其估值的价格，然后在进一步拖延的成本超过等待下一个更低价格的优势时接受。预测到买方的行为，卖方设计了一个最佳的报价序列，均衡基本上是唯一的，假设卖方的成本严格小于买方的所有可能的值，所以交易的收益肯定是正的。</p>
<p>然而，这个模型对延迟的预测是短暂的。随着报价之间的间隔$\Delta$的缩短，最大的延迟缩减为零，卖方的报价下降到买方的最小可能值。只要均衡具有上述唯一均衡的一些一般特征，这一引人注目的属性就会在更一般的版本（包括交替报价）中持续存在。因此，只有在报价不频繁的情况下，重大延迟才是必要的。</p>
<p>关于报价频率的理论（除了简单的物理限制和 “继续尝试 “的诱因）必须与重要的声誉方面相抗衡。在罢工期间，公司拒绝工会提出的工资会产生一种激励，即迅速提出更低的工资以缩短罢工时间。但是，工会可以预见到科斯属性：准备好的提议经常鼓励公司预见到并等待更低的工资提议，这最终会产生快速的协议，但条件对工会是不利的。通过在提供更低的工资之前忍受相当长的罢工时间，使公司为拒绝的后果付出代价，这是工会获得可观份额的力量的来源。因此，筛选模型有一个微妙的含义：建立一个强硬的声誉（被理解为维持成员的士气以在相当长的时间内不妥协地维持工资要求的能力）是一个成功战略的主要特征。建立声誉可能涉及到与一家公司或一个行业中的许多公司在连续的合同谈判中反复讨价还价。在这个意义上，延迟是由于买方价值的不确定性而加剧的，这就证明了卖方的撇脂策略，以及建立声誉的首要动机是不经常修改报价。</p>
<h3 id="Signaling-信号"><a href="#Signaling-信号" class="headerlink" title="Signaling 信号"></a>Signaling 信号</h3><p>与上述声誉解释一样，信号模型提供了报价之间的重要间隔的解释。然而，它通过解决买方的动机来证明低价是合理的，从而避免了科斯产权理论。该模型中允许随时报价，但必须双方轮流，一方报价后另一方要等一段时间。假设买方的价值是私有的。</p>
<p>现有一种信号装置，其运作方式如下：在收到卖方提出的价格后，买方可以在间隔时间$\Delta$后接受，或者等待更长的时间，以表明他的价值很小，然后提出一个更低的价格。为了使这种信号可信，他必须等待足够长的时间来反驳任何关于他的价值可能很高的猜想。因此，他等待的时间和他提出的价格必须是这样的，如果他的价值更高，那么这样做是无利可图的。只要强制区间$\Delta$足够短，弱技术假设就意味着有这种形式的唯一均衡。特别是，如果卖方的价值足够高，他最初提出一个被买方接受的价格，否则，他通过等待一个适当长的时间间隔来提出他的价值（因为现在他的价值已经被可信地发出信号），即最初描述的没有不确定性的基本模型所预测的价格。</p>
<p>在双方都有私人信息的情况下，也会得到类似的结果。更没有耐心的一方，比如说卖方，在提出最初的建议之前，会等待足够长的时间来发出可信的成本信号；然后，如果买方的价值非常高，他会迅速接受，否则会等待足够长的时间来发出可信的价值信号，然后提出反建议，卖方会迅速接受。根据这种情况，双方通常在没有私人信息的情况下就预测的价格达成一致：与筛选模型不同，信息差异对商定的条款影响不大。延迟的作用仅仅是可信地传达彼此的私人信息。后悔的因素体现在事后意识到早期对卖方的成本和买方的价值进行可信的核查可以避免延迟的成本。</p>
<p>根据这一设想，拖延是信息不对称的必然结果。特别是，最多只有两个正式报价，其余的都是多余的拖延，例如在工资谈判中，公司发出的信号，即它无法承担高工资。从严酷的形式来看，这种观点违反了偶然的观察，但一些特征，如可变的反应间隔和稀少的认真报价是现实的。此外，工资是公平的，因为在没有信息差异的情况下，工资是相同的。筛选模型有很大的不同，因为它们预测工资和延迟主要取决于程序性参数，如报价的频率，反过来又取决于对士气或声誉的辅助考虑；此外，如果报价频繁，那么结果就会对拥有优势信息的一方非常有利。</p>
<p>这三种延迟模式代表着极端情况，其中有可能出现各种混合情况。例如，如果当事人的延迟成本是(i)和(ii)的混合物，那么结果也是损耗和信号结果的混合物：与纯粹的损耗模型相比，延迟可能更短，分割更公平。新的特征也出现了。买方的最高值意味着立即接受，但最低值也会导致买方终止谈判，即使交易的收益是正面的：可信的信号传递太昂贵了。如果卖方的成本和买方的价值是相关的或有因果关系的，就会出现更多的可能性；特别是，即使双方都知道收益必须是正的，也可能阻止收益的实现。</p>
<h2 id="Strike-Data"><a href="#Strike-Data" class="headerlink" title="Strike Data"></a>Strike Data</h2><p>损耗模型预测，平均工资结算与罢工持续时间无关，加拿大的数据就是如此，尽管美国的数据显示工资随着持续时间的增加而有所下降。他们还预测，解决率（每天在仍未解决的问题中解决的百分比）会下降，这与数据基本一致。如果只有公司有私人信息，筛选和信号模型预测工资会随着时间的推移而下降，如前所述，这在美国的数据中也有发生，但它们在下降的速度上有所不同。筛选模型的合理规格可以预测适当幅度的结算率（每天2％或3％），如果包括非罢工放缓（如下所述），信号模型也可以。这些模型预测的结算率大多随着时间的推移而增加，但这与总体数据中观察到的结算率下降并不矛盾：因为不同的工会-公司对可以有不同的结算率，而那些有高结算率的公司倾向于早期结算，总体结算率仍然可以在很长一段时间内下降。</p>
<p>信号模型可以适应对其他特征的考虑，如工会在放缓或罢工之间的战术选择，以向公司施压。事实上，罢工和停工在合同到期和结算之间所占的平均时间不到一半；另外，大多数合同的续签都会发生延误，但其中只有不到三分之一涉及罢工，而罢工通常是迅速启动的。信号模型很好地预测，只有在旧工资较低的情况下，工会才会在最初选择罢工。值得注意的是，合理的假设意味着减速和罢工以类似的速度传递信息，以被延迟成本耗尽的部分来衡量；因此，当旧工资不是太低时，减速是相对有效的，对工会有吸引力。</p>
<p>还需要进一步的工作来确定每个模型在整体上对数据的适合程度。一些孤立的事实支持了这些模型的一般假设，即战略行为，因信息不对称而变得复杂，是很重要的。这些模型预测，在纽约，工人在8周后有资格获得失业补偿，这鼓励了较高的早期结算率和较低的后期结算率，事实上也是如此。他们还预测，魁北克省禁止企业雇用替代工人的法律增加了平均工资和罢工持续时间，事实上，平均持续时间的估计增长超过了50%。这种影响在筛选模型中是最明显的，在这种情况下，排除替代工人会增强工会根据企业的盈利能力进行歧视的权力，而不受来自非工会工人的竞争的阻碍。另一方面，在实践中，延迟成本似乎比这些模型预测的要低。在美国，只有大约15%的劳动合同谈判涉及罢工（在加拿大为22%），与持续3年的合同相比，中值持续时间通常为3周。同样地，约有10%的法律索赔进入审判阶段（儿童监护权等问题的比率更高）。在接受强制性约束性仲裁的政府工作人员的合同谈判中，约有三分之一涉及仲裁听证，但这些谈判的成本比罢工或审判要低。对这些现象的一个可能的解释是，只有少数争端受到信息不对称的困扰。</p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>这里描述的模型对昂贵的讨价还价延迟的根本原因提出了建议。没有信息差异的模型表明，拖延不是固有的。合理的程序能够避免任何拖延的必要性。然而，有信息差异的三个模型表明，拖延可能是可能的或必要的。尽管它们依赖于偏好的不同结构特征，但损耗和信号模型都有一个共同的预测，即延迟主要是一种激发信息的手段。拖延的成本性确保了其作为信号的可信度，所以如果没有其他的验证手段，那么各方可能会依赖它。另一方面，筛选模型则提出了允许操纵延迟的程序。频繁的报价使延迟最小化，这在社会上是有效的，但却使条件对信息较差的一方有偏见。</p>
<p>这些不同类型和数量的延迟的可能性也反映在对任何议价过程的任何均衡所隐含的基本激励兼容条件的研究中。这些条件与程序性规则无关，但它们对信息不对称很敏感。一个基本的含义是，关于贸易收益是否为正数的相互不确定性需要一些无效率，要么是延迟，要么是谈判的破裂。在满足这些条件的方式中，发现了大量的可能性，每一种都会对各方获得的相对优势、延迟成本和结果的整体效率产生影响。一个实际的建议是，通过建立（在信息差异出现之前）长期合同来调节争端，从而避免这些条件的咬合。另外，单方支付可以补偿预期的不利因素；例如，在一个筛选模型中，报价之间的短间隔对卖方不利，但可以减少延迟，因此作为补偿，买方可以向卖方支付费用以加快进程。</p>
<p>这些评论并不意味着所提到的延迟来源是详尽的。由于情感和认知反应，如不信任或归因于恶意，造成的延迟是很常见的。即使在匿名的情况下，每一方都可能不愿意放弃他应得的、期望的或承诺给选民的份额。即使对于 “超理性 “的一方，也有相互竞争的假说。其中一个重要的假设是，受雇于各方的代理人可能有动机去拖延（如果他们有报酬去谈判）或避免达成协议（如果这将对他们的未来产生不利影响）。后者的一个可能的例子是，在职管理层或董事有动机阻挠敌意收购或兼并要约，或阻挠股东诉讼的解决。一个常见的观点是，在问题成熟时才会结束谈判。就上述模型而言，成熟性可以被解释为进一步拖延或获取或推断新信息的成本增加；但也可能是拖延使后果或偏好得到澄清。在法律背景下的一个相关例子是，延迟提供了进行发现或辅助性法庭测试的机会，如上诉。</p>
<p>最后一段我也没理解，大致意思应该是说关于讨价还价博弈中的延迟分析依赖于各方的理性，而这限制了其应用。它对程序和偏好的详细说明的依赖也带来了应用上的限制性。接下来举了几个例子说明这种限制。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
      </tags>
  </entry>
  <entry>
    <title>获取B站数据说明</title>
    <url>/2022/05/29/%E8%8E%B7%E5%8F%96B%E7%AB%99%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="获取B站数据说明"><a href="#获取B站数据说明" class="headerlink" title="获取B站数据说明"></a>获取B站数据说明</h1><h2 id="用到的包"><a href="#用到的包" class="headerlink" title="用到的包"></a>用到的包</h2><ol>
<li><p><code>bilibili_api</code>：必用，获取视频数据的接口</p>
</li>
<li><p><code>json</code>：选用，用于格式化输出获取的字典数据</p>
</li>
<li><p><code>time</code>：选用，用于转换获取的时间戳数据</p>
</li>
<li><p><code>csv</code>：选用，用于将数据输出到csv文件</p>
</li>
<li><p>其他说明：如果需要更高级的表格数据输出，建议用pandas</p>
</li>
</ol>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>通过下列代码可以获取指定<code>bv</code>号的视频数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = video.Video(bvid)        <span class="comment"># 实例化video类</span></span><br><span class="line">info = <span class="keyword">await</span> v.get_info()    <span class="comment"># 获取信息</span></span><br></pre></td></tr></table></figure>
<p><code>info</code>是一个字典类型的数据，包含了视频的标题、作者、播放量等等大量信息，我们可以用以下代码格式化输出来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(json.dumps(info,indent=<span class="number">4</span>,ensure_ascii=<span class="literal">False</span>))    <span class="comment"># 格式化输出</span></span><br></pre></td></tr></table></figure>
<p>输出结果如下图，这个字段信息很多，就不一一列出说明了。</p>
<p><img src="https://s2.loli.net/2022/05/29/oHEL1jBekdJzXZ2.png" alt=""></p>
<p><img src="https://s2.loli.net/2022/05/29/IVlywznM7u9cdJK.png" alt=""></p>
<p>目前我们需要获取的是标题、发布时间、播放量和三连数据，可以看出，标题对应的字段是<code>title</code>，发布时间是<code>pubdate</code>，而播放量和三连数据则是在<code>stat</code>中的<code>view, favorite, coin, like</code>，需要注意的是这里发布时间是用的时间戳，因此要使用<code>time</code>来转换成标准时间。总的来说，就是以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title = info[<span class="string">'title'</span>]                                    <span class="comment"># 获取标题</span></span><br><span class="line">view = info[<span class="string">'stat'</span>][<span class="string">'view'</span>]                              <span class="comment"># 获取播放量</span></span><br><span class="line">like = info[<span class="string">'stat'</span>][<span class="string">'like'</span>]                              <span class="comment"># 获取点赞</span></span><br><span class="line">coin = info[<span class="string">'stat'</span>][<span class="string">'coin'</span>]                              <span class="comment"># 获取投币</span></span><br><span class="line">favorite = info[<span class="string">'stat'</span>][<span class="string">'favorite'</span>]                      <span class="comment"># 获取收藏</span></span><br><span class="line">time_tmp = info[<span class="string">'pubdate'</span>]                               <span class="comment"># 获取发布时间</span></span><br><span class="line">timeArray = time.localtime(time_tmp)                     <span class="comment"># 时间戳转为标准时间的数组形式</span></span><br><span class="line">time_pub= time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, timeArray)  <span class="comment"># 时间数组转为常见的可直接输出的字符串形式</span></span><br></pre></td></tr></table></figure>
<p>在得到数据以后，可以直接打印输出、写入本地文件或者进行后续其他需要的操作，这里我们要把数据作为函数返回值，因此把它们放到一个列表中，从而一起返回，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">videoinfo = [title, time_pub, view, like, coin, favorite]</span><br><span class="line"><span class="keyword">return</span> videoinfo</span><br></pre></td></tr></table></figure>
<p>获取数据的部分到此结束，需要注意的是，由于最初获取数据用到了<code>awati</code>，因此该函数是异步的，在声明的时候需要用如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(bvid)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>接下来是如何把数据写入文件。</p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>首先是设置<code>bv</code>号，然后异步地调用前面写好的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bvid = <span class="string">"BV1MR4y1K7Tv"</span></span><br><span class="line">info = asyncio.get_event_loop().run_until_complete(main(bvid))</span><br></pre></td></tr></table></figure>
<p>如果要连续获取多个视频的信息，就可以直接循环。</p>
<p>接下来由于输出的文件格式比较特殊，所以要对获取到的数据列表进行处理，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="literal">None</span>,<span class="literal">None</span>,info[<span class="number">0</span>],<span class="string">"https://www.bilibili.com/video/"</span>+bvid,info[<span class="number">1</span>],<span class="literal">None</span>,<span class="literal">None</span>,info[<span class="number">2</span>],<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>,str(info[<span class="number">3</span>])+<span class="string">'/'</span>+str(info[<span class="number">4</span>])+<span class="string">'/'</span>+str(info[<span class="number">5</span>])]</span><br></pre></td></tr></table></figure>
<p>这行代码的含义是把列表的前两个字段设置为空，接着是<code>info</code>中的第一个数据即标题，随之是视频链接，再次是投稿时间，接着继续两个空，然后是播放量，在四个空位之后是<code>点赞/投币/收藏</code>这种形式的三连数据。之所以置空，是因为要写入表格中在这些位置有其他列，需要用其他方式写入数据。</p>
<p>数据按格式排好后就可以写入了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"bilibili.csv"</span>, <span class="string">'a'</span>, newline=<span class="string">''</span>, encoding=<span class="string">'utf-8-sig'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.writer(f)</span><br><span class="line">    f_csv.writerow(list)</span><br></pre></td></tr></table></figure>
<p>第一行表示以追加写入的方式打开<code>bilibili.csv</code>这个文件，文件编码是<code>utf-8-sig</code>，<code>a</code>表示是追加写入，也就是在文件最后一行新增要写入的内容，<code>newline</code>表示换行符为空，最后的<code>as f</code>表示把打开的这个文件变量命名为<code>f</code>，这个名字只影响后面对文件变量的操作，不影响文件名本身。</p>
<p>第二行是调用函数表示要对文件<code>f</code>进行写入操作，第三行是指将名为<code>list</code>的列表作为新的一行直接写入到csv文件中。</p>
<p>写入文件以后就结束。 </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bili.moyu.moe/#/" target="_blank" rel="noopener">bilibili-api 开发文档</a></p>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Web3行业总结</title>
    <url>/2022/05/06/Web3%E8%A1%8C%E4%B8%9A%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Web3-0总结"><a href="#Web3-0总结" class="headerlink" title="Web3.0总结"></a>Web3.0总结</h1><h2 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h2><p>2014年 Gavin Wood：</p>
<ol>
<li><p>让互联网更去中心化、可验证、安全而发起的一组广泛的运动和协议；</p>
</li>
<li><p>愿景是实现无服务器、去中心化的互联网，即用户掌握自己身份、数据和命运的互联网；</p>
</li>
<li><p>将启动新全球数字经济系统，创造新业务模式和新市场，打破平台垄断，推动广泛的、自下而上的创新。</p>
</li>
</ol>
<p>Web3.0 是信息聚联与价值共享的用户互联网，是下一代互联网技术体系，是 用户共建、隐私保护、平台开放的生态体系，是去平台中心化的组织形式所构建的新型经济系统，是以用户为中心的互联网，用户既是内容的生产者和所有者，也是内容的传播者和价值拥有者。</p>
<p>概述：</p>
<ol>
<li><p>Web3.0 是信息聚联与价值共享的用户互联网</p>
</li>
<li><p>Web3.0 是下一代互联网技术体系，是 用户共建、隐私保护、平台开放的生态体系</p>
</li>
<li><p>Web3.0 是去平台中心化的组织形式所构建的新型经济系统</p>
</li>
<li><p>Web3.0 是以 用户 为中心的互联网，用户既是内容的生产者和所有者，也是内容的传播者和价值拥有者</p>
</li>
</ol>
<p>特点：开放、隐私、共建</p>
<p>核心特征：将去平台中心化 实现用户自主价值创造 、价值确权 、 价值交换三位一体 使现实世界与虚拟世界双向渗透</p>
<p>主要特点：</p>
<ol>
<li><p>用户或将拥有更高的权限</p>
</li>
<li><p>用户有可能通过所拥有的数据获利</p>
</li>
<li><p>虚拟世界与现实世界融合</p>
</li>
<li><p>实现价值安全、透明、可信的转移</p>
</li>
</ol>
<p>Web3.0生态主要组成要素及特点：</p>
<ol>
<li><p>用户身份：传统中心化身份容易产生安全和隐私风险，web3构建了一个去中心化的身份标识，以DID作为web3的用户身份表现形式；</p>
</li>
<li><p>组织形式：web3的核心观点是用户共建、用户所有，所以会形成用户共建自治的组织形式，即DAO；</p>
</li>
<li><p>经济系统：数字资产是web3的核心要素，数据资产将以通证的形式构成整个经济系统。截至2021年4月2日，DeFi各项目总计拥有约712万活跃用户，相比自2021年1月的160.78万增长了约3.5倍，NFT主流项目资产规模合计也超过100亿美元，成为元宇宙项目中发展最为迅猛的领域；</p>
</li>
<li><p>呈现形式：web3中的所有活动和交互都需要依赖于特定的应用来实现，通过dApp的交互最终构成动态的web3世界；5）从中心化存储到去中心化存储：去中心化的存储方案即IPFS，为web3提供基础支撑。在web3生态中，区块链是核心支撑，其具有的技术、金融和社会属性将帮助构建一个去中心化的、可信的数字化价值交互网络。</p>
</li>
</ol>
<p>5个特征：</p>
<ol>
<li><p>计算和特定的计算设备解绑分离：Web3.0构成了一种全新的计算范式，计算和存储行为并不会因为特定的设备出现问题，这个计算和服务就被关停。</p>
</li>
<li><p>基于密码学技术实现身份认证及数据确权：不同于以往传统互联网基于中心化机构和数据库来进行授权和认证。身份必将成为一种主权资产。这个身份不管是人的身份，同时还包含机器等终端在Web3.0中的身份。</p>
</li>
<li><p>数据的记录和存储都是通过不可篡改的方式进行：Web3.0中，数据的存储倾向于永不删除和修改，而是不断累加数据，但是这种模式的前提是，存储成本极低，规模极大。</p>
</li>
<li><p>资源分配通过基于通证的市场机制来进行：区别于以往的中心化授权调配的方式，而是双方通过通证的交易来进行资源的配置优化。</p>
</li>
<li><p>权益分配上的去中心化和透明化。</p>
</li>
</ol>
<p>Web3背景下的商业逻辑：</p>
<ol>
<li><p>去中心化的通用数字身份认证体系</p>
</li>
<li><p>数据确权</p>
</li>
<li><p>价值分配结构优化</p>
</li>
<li><p>产品设计和服务定价权向用户转移</p>
</li>
</ol>
<p>Web3.0的发展路径应该是资产、身份和数据</p>
<h2 id="历史与发展"><a href="#历史与发展" class="headerlink" title="历史与发展"></a>历史与发展</h2><p><img src="https://s2.loli.net/2022/05/06/bNOo6RnIBpYLXEQ.png" alt=""></p>
<h3 id="Web1：单向、只读互联网"><a href="#Web1：单向、只读互联网" class="headerlink" title="Web1：单向、只读互联网"></a>Web1：单向、只读互联网</h3><p>1991年—2004年，门户网站提供信息，用户被动浏览，内容创造者很少，绝大多数用户只能接受平台信息的投喂。</p>
<h3 id="Web2：双向、可读写互联网"><a href="#Web2：双向、可读写互联网" class="headerlink" title="Web2：双向、可读写互联网"></a>Web2：双向、可读写互联网</h3><p>2004年至今，允许用户自主生成内容，与网站和他人进行交互和协作。网络是专有的、封闭的，属于某个互联网公司的，用户自身并未真正拥有这些平台上的用户数据。</p>
<h3 id="Web3：聚联、价值互联网"><a href="#Web3：聚联、价值互联网" class="headerlink" title="Web3：聚联、价值互联网"></a>Web3：聚联、价值互联网</h3><p>内容由用户创造，数据归用户所有，每个人都能掌握自己的（数字）身份、资产和数据，进而掌握自己的命运。</p>
<h3 id="和国外对比"><a href="#和国外对比" class="headerlink" title="和国外对比"></a>和国外对比</h3><p>市场差异：中国是战略驱动型 美国是产业驱动型<br>应用场景：中国以元宇宙 、 沉浸式体验和可视化相关产业为主 美国优势在于基础设施和 链上经济发展</p>
<h2 id="发展Web3的必要性"><a href="#发展Web3的必要性" class="headerlink" title="发展Web3的必要性"></a>发展Web3的必要性</h2><h3 id="从Web2的现状问题出发"><a href="#从Web2的现状问题出发" class="headerlink" title="从Web2的现状问题出发"></a>从Web2的现状问题出发</h3><ol>
<li><p>Web2.0 的中心化平台遵循可预测的生命周期，平台与网络参与者的关系已经从正和变为零和；</p>
</li>
<li><p>Web2.0 发展到后期逐渐显现的寡头垄断局面，让用户的数据安全和隐私保护问题变得更加尖锐；</p>
</li>
<li><p>Web1.0 到Web2.0，用户实现了内容的消费者向内容生产者的转变，但并未相应地转变生产关系。</p>
</li>
</ol>
<h3 id="Web3的作用"><a href="#Web3的作用" class="headerlink" title="Web3的作用"></a>Web3的作用</h3><p>Web3.0 将解决 Web2.0 时代互联网大多数控制权集中在各个中心化公司的核心问题，实现价值向用户的安全、透明、可信转移</p>
<p><img src="https://s2.loli.net/2022/05/06/ORoW7FsyB3w2Vax.png" alt=""></p>
<h3 id="发展驱动力"><a href="#发展驱动力" class="headerlink" title="发展驱动力"></a>发展驱动力</h3><ol>
<li><p>战略层面：美国的战略推动者是产业界，中国则应发挥自身战略驱动型市场优势，顶层设计先行；Web3.0已成美国构建虚拟世界金融话语权的手段，中国需要建立自身特色的 Web3.0 体系</p>
</li>
<li><p>政策层面：反垄断监管持续推进，用户数据安全、隐私保护成为关注重点</p>
</li>
<li><p>技术层面：区块链技术特性适配Web3.0 设想，且技术趋于成熟，应用场景不断落地</p>
</li>
<li><p>产业层面：Web3.0行业发展周期即将从幼稚期迈入成长期，未来各个细分领域将会迎来快速发展</p>
</li>
<li><p>金融层面：数字货币逐渐获主流经济体认可，各国倾向于自主发行数字货币，对加密货币监管态度不一</p>
</li>
</ol>
<h2 id="行业市场现状"><a href="#行业市场现状" class="headerlink" title="行业市场现状"></a>行业市场现状</h2><p>Web3.0协议栈的各部分都是以去中心化、点对点的加密协议为特征，是一个无信任交易或协作基础设施，以达到用户能控制自己的资产、身份和数据的目的。从这个角度看，一定是资产是先行，因为资产相关领域具有可投机性，可以吸引大批资金和人员进入。如果从资产入手，下一步可能会解决的是身份，如果不解决身份问题是没办法解决数据问题的，因为没有个人的标识就没有办法去掌握自己的数据。所以应该是从资产、身份和数据这样的时间线去推进。</p>
<h3 id="商业趋势"><a href="#商业趋势" class="headerlink" title="商业趋势"></a>商业趋势</h3><ol>
<li><p>将Web2.0 的Apps 升级为Web3.0 的DApps。</p>
</li>
<li><p>重构Web3.0 网络的基础设施和应用协议，并初步形成Web3.0 的核心堆栈。</p>
</li>
<li><p>Web3.0 的新项目获客模式创新：定向奖励精准用户。</p>
</li>
</ol>
<h3 id="典型项目"><a href="#典型项目" class="headerlink" title="典型项目"></a>典型项目</h3><ol>
<li><p>开放：ENS、MASK Network 和Polkdot</p>
</li>
<li><p>隐私：Horizen、NuCypher</p>
</li>
<li><p>共建：Mirror、Gitcoin</p>
</li>
</ol>
<h3 id="生态体系现状"><a href="#生态体系现状" class="headerlink" title="生态体系现状"></a>生态体系现状</h3><ol>
<li><p>底层基础设施：行业整体产业链各环节已比较完备，部分环节海外仍处垄断地位</p>
</li>
<li><p>软件层与交互层现状：VR/AR行业发展迎来拐点，终端硬件出货量将持续走高</p>
</li>
<li><p>应用层现状：应用集中游戏和社交，致力于沉浸体验、观看体验、交互体验</p>
</li>
<li><p>NFT：NFT资产类型不断丰富中，但仍存在资产无法满足流动性需求的庞氏骗局风险；中国NFT 生态应用尚在孕育中，中国本土化之路刚刚开始，建议先建立监管体系</p>
</li>
<li><p>GameFi：GameFi将加速用户和 NFT 资产积累，推动更多企业和资本深入布局 Web3.0</p>
</li>
<li><p>DAO：去中心化组织应该更侧重于去平台化，让用户从被平台捆绑的状态中解放</p>
</li>
<li><p>DeFi：DeFi作为 Web3.0 生态中的金融体系，维持虚拟世界的核心信任体系，但未来尚不明朗</p>
</li>
</ol>
<h3 id="中美对比"><a href="#中美对比" class="headerlink" title="中美对比"></a>中美对比</h3><ol>
<li><p>国家层面：中国从顶层设计自上而下布局，美国从产业端自下而上推动</p>
</li>
<li><p>产业层面：美国优势领域在于底层基础设施和应用层，中国着力发展软件层和交互层</p>
</li>
<li><p>企业层面：中国企业更注重底层赛道布局，应用层布局不足，美国企业布局更为全面；美国科技巨头布局时间跨度更长；中国近三年才开始布局并加大海外投资收购力度</p>
</li>
</ol>
<h3 id="元宇宙"><a href="#元宇宙" class="headerlink" title="元宇宙"></a>元宇宙</h3><ol>
<li>Web3.0与元宇宙是一体两面的关系，二者具有多样状态，可重合、可交叉、可分离</li>
</ol>
<h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><p>区块链是Web 3 0 的关键技术 其去中心化 、防篡改特征是价值归属用户 、 用户隐私保护的基础；此外 操作系统 、分布式存储等底层技术VR/AR 、 3 D 建模等沉浸式 、 可视化技术也需与 Web 3 0 发展相适配.</p>
<p><img src="https://s2.loli.net/2022/05/06/fX2NdFY3x5RbHlB.png" alt=""></p>
<h3 id="分类方法1"><a href="#分类方法1" class="headerlink" title="分类方法1"></a>分类方法1</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ol>
<li>应用层通常都是去中心化应用协议，类别繁多，目前已经有所发展的主要包括：DEFI、GameFi、Social Messaging、Media、Ecomerce、Security。</li>
</ol>
<h4 id="用户控制层"><a href="#用户控制层" class="headerlink" title="用户控制层"></a>用户控制层</h4><ol>
<li>用户控制层包括：Exchange、Wallet、DAO、Broswers 等。</li>
</ol>
<h4 id="可扩展传输层"><a href="#可扩展传输层" class="headerlink" title="可扩展传输层"></a>可扩展传输层</h4><ol>
<li>统称为Layer2 协议。主要包括6 类：侧链、状态通道、Plasma、Optimisitc Rollup、ZK Rollup、Volidium等。</li>
</ol>
<h4 id="组件层"><a href="#组件层" class="headerlink" title="组件层"></a>组件层</h4><ol>
<li><p>组件建立在计算层上，重复使用标准化的智能合约模版。</p>
</li>
<li><p>组件层不是必不可少的。</p>
</li>
<li><p>可选组件主要包括：查询层（The Graph、dfuse）、预言机（Chainlink、Band Protocol）、DID、DDNS、Digital Assets（BTC、ETH 等）、Crypto Currencies（ERC20、ERC721 等）、Stablecoin（USDC、DAI）等。</p>
</li>
</ol>
<h4 id="计算层"><a href="#计算层" class="headerlink" title="计算层"></a>计算层</h4><ol>
<li>计算层允许人类指示状态层做他们想做的事。具体指状态转换机，如EVM、WASM 等。</li>
</ol>
<h4 id="状态层"><a href="#状态层" class="headerlink" title="状态层"></a>状态层</h4><ol>
<li><p>状态层主要是公链的集合，如Bitcoin、Ethereum、Solana等；</p>
</li>
<li><p>状态层还可以细分为状态转化层、共识层、分片层、P2P 层等。</p>
</li>
</ol>
<h4 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h4><ol>
<li>成本高，链外分布式存储，IPFS、Arweare 和Swarm。</li>
</ol>
<p>除了上述核心堆栈外，Web3.0 还有一些距离终端用户较远的基础设施，比如：可信执行环境（TEE）、互联网协议（IP）、混合网络数据包路由等。</p>
<h3 id="分类方法2"><a href="#分类方法2" class="headerlink" title="分类方法2"></a>分类方法2</h3><ol>
<li><p>协议层</p>
</li>
<li><p>应用层</p>
</li>
<li><p>网络基础层</p>
</li>
</ol>
<h3 id="分类方法3"><a href="#分类方法3" class="headerlink" title="分类方法3"></a>分类方法3</h3><ol>
<li><p>交互层</p>
</li>
<li><p>平台层</p>
</li>
<li><p>基础层</p>
</li>
</ol>
<h3 id="分类方法4"><a href="#分类方法4" class="headerlink" title="分类方法4"></a>分类方法4</h3><p><img src="https://s2.loli.net/2022/05/06/sUKBNh65QxqeMvk.png" alt=""></p>
<h3 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h3><ol>
<li><p>零知识证明</p>
</li>
<li><p>EVM</p>
</li>
<li><p>跨链</p>
</li>
<li><p>分片、L2、链外计算</p>
</li>
<li><p>预言机</p>
</li>
<li><p>人工智能超算</p>
</li>
<li><p>去信任的交互协议和平台</p>
</li>
<li><p>分布式存储</p>
</li>
</ol>
<h3 id="隐私相关技术"><a href="#隐私相关技术" class="headerlink" title="隐私相关技术"></a>隐私相关技术</h3><ol>
<li><p>隐私匿名币</p>
</li>
<li><p>智能合约隐私</p>
</li>
<li><p>Layer1 和 Layer2 各自的技术</p>
</li>
<li><p>多方安全技术</p>
</li>
<li><p>同态加密</p>
</li>
<li><p>可信执行环境TEE</p>
</li>
</ol>
<h2 id="未来趋势"><a href="#未来趋势" class="headerlink" title="未来趋势"></a>未来趋势</h2><p>中国经济未来的增长点在于数字经济Web3.0是数字经济发展的关键。目前海外Web3.0 体系仍存在一定经济金融风险。中国应发挥战略驱动作用完善监管体系,在合规框架下探索Web3.0的中国化之潞。</p>
<h3 id="发展挑战"><a href="#发展挑战" class="headerlink" title="发展挑战"></a>发展挑战</h3><p>商业逻辑变化可能导致经济风险，监管需相应适配</p>
<ol>
<li><p>国家层面：探索带来认知升级挑战，各国发展路径不一</p>
</li>
<li><p>产业层面：底层技术需持续攻破</p>
</li>
<li><p>经济层面：具有一定资本操纵和经济风险，监管难度加大</p>
</li>
<li><p>企业层面：短期内互联网中心化特征难以打破</p>
</li>
</ol>
<h3 id="投融资分析"><a href="#投融资分析" class="headerlink" title="投融资分析"></a>投融资分析</h3><p>海外Web3.0 投资如火如荼，中国侧重元宇宙“沉浸式应用”</p>
<h3 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h3><ol>
<li><p>全球或将分区发展，全新商业模式亟待探索</p>
<ol>
<li><p>海外投资：海外机构将加大对Web3.0的投资</p>
</li>
<li><p>商业模式：流量价值依旧重要，激励机制对流量影响较大</p>
</li>
<li><p>企业探索：大量Web2.0的公司或将尝试进入 Web3.0</p>
</li>
<li><p>国家监管：各国在本国合规政策下探索不同的发展道路</p>
</li>
</ol>
</li>
<li><p>中国化之路：数字经济体系下构建中国Web3.0生态，新型科技在合规市场提供服务</p>
<ol>
<li><p>中国经济未来的增长点在于数字经济</p>
</li>
<li><p>Web3.0是数字经济发展的关键</p>
</li>
<li><p>Web3.0在中国发展首先需要发展新型科技</p>
</li>
<li><p>中国需在合规框架下探索路线</p>
</li>
</ol>
</li>
</ol>
<h3 id="监管趋势"><a href="#监管趋势" class="headerlink" title="监管趋势"></a>监管趋势</h3><ol>
<li><p>对于沟通Web3.0 和Web2.0 两个世界的通道/业务，将首当其冲，寻求适合的监管模式，以适应Web3.0 的发展；</p>
</li>
<li><p>隐私和匿名方面，有可能存在底层实现KYC，应用层实现适度匿名；</p>
</li>
<li><p>DAO 治理过程中，势必会引入监管作为治理一方。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>行业总结</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-众包相关论文调研</title>
    <url>/2022/05/06/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-%E4%BC%97%E5%8C%85%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h3 id="1-Two-Stage-Auction-Mechanism-for-Long-Term-Participation-in-Crowdsourcing"><a href="#1-Two-Stage-Auction-Mechanism-for-Long-Term-Participation-in-Crowdsourcing" class="headerlink" title="1-Two-Stage Auction Mechanism for Long Term Participation in Crowdsourcing"></a>1-Two-Stage Auction Mechanism for Long Term Participation in Crowdsourcing</h3><p>针对小型任务的众包（例如：图像打标签、录音），workers愿意完成的任务数量上限不同，并且会在投标阶段谎报；拍卖随时间推移重复多轮，失败的workers可能退出系统。</p>
<p>针对的问题：workers竞标时说的任务数量不一定真的能完成。workers通常可以负担大量的工作，尽管由于时间限制和边际收益递减会有一定的限制。此外，workers很难确保他们所有的工作都符合requester设定的质量标准，因此，requester需要根据工作的实际数量支付报酬。</p>
<p>本文思路：workers的投标包括单个任务的报酬、自己愿意完成的最大任务数量和自己实际完成的任务数量。基于迈尔森拍卖机制推广得到两阶段博弈机制（这部分公式非常相似），证明了该机制的激励相容和个体理性；提出了使得requester能在成本效率和公平性之间取得平衡的任务分配机制，从而让wokers有意愿长期留在系统中参与众包。</p>
<p>使用参数进行了仿真实验分析。</p>
<blockquote>
<p>这篇文章后面出现了直接成本和间接成本，还没有细看是什么。</p>
</blockquote>
<h3 id="2-Quality-Aware-Incentive-Mechanisms-Under-Social-Influences-in-Data-Crowdsourcing"><a href="#2-Quality-Aware-Incentive-Mechanisms-Under-Social-Influences-in-Data-Crowdsourcing" class="headerlink" title="2-Quality Aware Incentive Mechanisms Under Social Influences in Data Crowdsourcing"></a>2-Quality Aware Incentive Mechanisms Under Social Influences in Data Crowdsourcing</h3><p>利用用户之间的社会影响作为激励来激励用户的参与，以降低招募用户的成本。设计了激励机制，以实现高质量的众包数据和低成本的激励用户参与为目标。</p>
<p>把用户的社会影响力看作是一个影响用户完成任务所需成本的参数。设计两阶段博弈，第一阶段通过任务分配最大化质量，第二阶段通过决定招募用户的顺序来最小化成本。</p>
<p>在完全信息情景下，设计了任务分配和用户招聘机制，以优化数据质量，同时降低激励成本。在部分信息场景中，用户的质量和成本是未知的。由用户上报质量和成本，假设是异构任务，利用任务之间的相互关系来克服信息不对称。在动态社会影响场景中，考察了用户社会影响力的动态性，并为用户设计额外的奖励，以充分利用社会影响力，实现最大限度的成本节约。</p>
<p>使用数值结果来评估激励机制。</p>
<h3 id="3-SocialRecruiter-Dynamic-Incentive-Mechanism-for-Mobile-Crowdsourcing-Worker-Recruitment-With-Social-Networks"><a href="#3-SocialRecruiter-Dynamic-Incentive-Mechanism-for-Mobile-Crowdsourcing-Worker-Recruitment-With-Social-Networks" class="headerlink" title="3-SocialRecruiter: Dynamic Incentive Mechanism for Mobile Crowdsourcing Worker Recruitment With Social Networks"></a>3-SocialRecruiter: Dynamic Incentive Mechanism for Mobile Crowdsourcing Worker Recruitment With Social Networks</h3><p>现有研究大都在大量workers的场景下分析如何选择workers，本文则针对有限人数的众包系统中的参与不足问题，提出利用社会网络招募完成任务的员工，扩大员工库。提出了一种动态激励机制，SocialRecruiter，鼓励众包平台上的工作人员通过社交网络传播任务，从而邀请朋友加入众包平台，进一步传播和完成任务。</p>
<p>受SIR传染病模型的启发，本文提出了一个新的任务特定的传染病模型来刻画用户在任务传播和通过社会网络完成任务时的状态变化。为了鼓励员工完成和传播任务，根据员工的行为给予宣传奖励和完成奖励。特别是，为了在财务预算内最大限度地完成任务，根据实时员工招聘进度，在每个周期动态更新奖励的宣传和完成情况。</p>
<p>在两个真实数据集上的大量实验结果表明，社会化招聘者在员工招聘和任务完成方面的表现优于最先进的方法。</p>
<blockquote>
<p>这个和任务分配以及众包其实关系不大，有点拼多多拉新用户砍一刀的感觉。</p>
</blockquote>
<h3 id="4-A-Game-Theoretical-Approach-for-Secure-Crowdsourcing-Based-Indoor-Navigation-System-With-Reputation-Mechanism"><a href="#4-A-Game-Theoretical-Approach-for-Secure-Crowdsourcing-Based-Indoor-Navigation-System-With-Reputation-Mechanism" class="headerlink" title="4-A Game Theoretical Approach for Secure Crowdsourcing Based Indoor Navigation System With Reputation Mechanism"></a>4-A Game Theoretical Approach for Secure Crowdsourcing Based Indoor Navigation System With Reputation Mechanism</h3><p>本文的共谋场景在于：恶意接包方和发包方勾结从而在声誉系统中刷好评。针对众包中的共谋问题，引入完全可信的雾服务器平台进行众包数据交易。提出了一种新的基于响应者行为的声誉激励机制，使用攻防博弈来建模雾服务器平台和响应者之间的相互作用，通过这种相互作用建立一个社会福利最佳化问题，使系统的社会福利最大化。其次，利用复制动力学方程求出了博弈均衡，并讨论了博弈的稳定性。进行了仿真实验。</p>
<blockquote>
<p>从摘要看也和任务分配没什么关系。</p>
</blockquote>
<h3 id="5-Hierarchical-Pricing-Mechanism-With-Financial-Stability-for-Decentralized-Crowdsourcing-A-Smart-Contract-Approach"><a href="#5-Hierarchical-Pricing-Mechanism-With-Financial-Stability-for-Decentralized-Crowdsourcing-A-Smart-Contract-Approach" class="headerlink" title="5-Hierarchical Pricing Mechanism With Financial Stability for Decentralized Crowdsourcing A Smart Contract Approach"></a>5-Hierarchical Pricing Mechanism With Financial Stability for Decentralized Crowdsourcing A Smart Contract Approach</h3><p>传统众包平台的集中性会带来信息披露和审计不透明问题，本文引入区块链系统，通过两个专用的智能合约集成了任务分配和资源借贷的功能。其次，为了保证区块链激活市场的金融稳定性，并使接受任务的难度与工作人员的能力相匹配，我们设计了一种基于经济建模方法和异质代理理论的动态分层定价机制。在这种机制下，根据顾客报酬和员工资源的市场价值，市场被动态地划分为多个层次。提出了额外的限制，以避免工人在资源借贷过程中可能的恶意交易行为。我们从理论上证明了模型的合理性，并对模型的动力学性质进行了论证。我们证明了市场价格和需求是收敛的，并测试了执行这两个智能合同的成本。最后，大量的实验结果验证了该平台的正确性和可行性，并证实了分层定价机制能够保持市场的稳定性。</p>
<blockquote>
<p>时间问题没来得及看这篇中分配任务的合约是怎么设计的。</p>
</blockquote>
<h3 id="第6篇是我的，略"><a href="#第6篇是我的，略" class="headerlink" title="第6篇是我的，略"></a>第6篇是我的，略</h3><h3 id="7-Strategic-Information-Revelation-Mechanism-in-Crowdsourcing-Applications-Without-Verification"><a href="#7-Strategic-Information-Revelation-Mechanism-in-Crowdsourcing-Applications-Without-Verification" class="headerlink" title="7-Strategic Information Revelation Mechanism in Crowdsourcing Applications Without Verification"></a>7-Strategic Information Revelation Mechanism in Crowdsourcing Applications Without Verification</h3><p>这篇是看过的黄建伟老师的论文。</p>
<ul>
<li>本文研究：无需验证解决方案、激励员工提供高质量解决方案的众包平台</li>
<li>本文假设：信息不对称、平台具有信息优势——平台知道有关workers解决方案的平均准确性的更多信息，可以向workers策略性披露信息。根据平台公开的信息，workers判断自己认真完成任务后所获得的奖励。</li>
<li>workers类型：<ol>
<li>naive workers：完全信任平台公开的信息</li>
<li>strategic workers：基于平台公开信息更新自己的先验信念</li>
</ol>
</li>
<li>本文发现：<ol>
<li>对于naive workers：始终宣布高平均精度</li>
<li>对于strategic workers：有动机宣布低于实际值的平均精度</li>
<li>平台的回报可能减少高精度workers</li>
</ol>
</li>
</ul>
<h3 id="8-Generalized-Lottery-Trees-Budget-Balanced-Incentive-Tree-Mechanisms-for-Crowdsourcing"><a href="#8-Generalized-Lottery-Trees-Budget-Balanced-Incentive-Tree-Mechanisms-for-Crowdsourcing" class="headerlink" title="8-Generalized Lottery Trees Budget-Balanced Incentive Tree Mechanisms for Crowdsourcing"></a>8-Generalized Lottery Trees Budget-Balanced Incentive Tree Mechanisms for Crowdsourcing</h3><p>现有研究大多假设用户已经处于众包系统中并知道众包任务，然而，在没有这种假设的现实生活场景中，更有效的做法是利用激励树机制，激励用户的直接贡献和对其他用户的诱惑。本文提出预算平衡激励树机制，称为广义彩票树。</p>
<blockquote>
<p>也和任务分配没有关系</p>
</blockquote>
<h3 id="9-Incentive-Mechanism-for-Spatial-Crowdsourcing-with-Unknown-Social-Aware-Workers-A-Three-Stage-Stackelberg-Game-Approach"><a href="#9-Incentive-Mechanism-for-Spatial-Crowdsourcing-with-Unknown-Social-Aware-Workers-A-Three-Stage-Stackelberg-Game-Approach" class="headerlink" title="9-Incentive Mechanism for Spatial Crowdsourcing with Unknown Social-Aware Workers A Three-Stage Stackelberg Game Approach"></a>9-Incentive Mechanism for Spatial Crowdsourcing with Unknown Social-Aware Workers A Three-Stage Stackelberg Game Approach</h3><p>在空间众包场景下，大多数现有的工作假设工人的素质是事先知道的，或不能考虑到所有各方的效用一起，特别是没有考虑到社会网络的影响。针对同时招募高素质的工人和最大限度地发挥各方的效用这一目标，提出了一种基于多臂老虎机和三阶段 Stackelberg 博弈的激励机制，称为 TACT。首先设计了一个贪婪选臂方案来招募工人，这不仅可以解决探索-剥削的困境，而且考虑到工人的社会关系。在招聘结果的基础上，进一步设计了考虑劳动者社会利益的效用函数，并将支付计算问题建模为三阶段 Stackelberg 博弈。接下来，推导出最优策略群，使每一方都能最大化自己的效用，从而形成一个多赢的局面。并从理论上证明了Stackelberg 均衡的唯一存在性和最坏后悔界的存在性。</p>
<p>我们在一个真实的轨迹上进行了广泛的模拟，以证实 TACT 的性能。</p>
<blockquote>
<p>这个主要是招募workers，具体是否有任务分配还不了解。</p>
</blockquote>
<h3 id="列表中的第10篇和前面第3篇重复了。"><a href="#列表中的第10篇和前面第3篇重复了。" class="headerlink" title="列表中的第10篇和前面第3篇重复了。"></a>列表中的第10篇和前面第3篇重复了。</h3><h3 id="11-Differentially-Private-Mechanisms-for-Budget-Limited-Mobile-Crowdsourcing"><a href="#11-Differentially-Private-Mechanisms-for-Budget-Limited-Mobile-Crowdsourcing" class="headerlink" title="11-Differentially Private Mechanisms for Budget Limited Mobile Crowdsourcing"></a>11-Differentially Private Mechanisms for Budget Limited Mobile Crowdsourcing</h3><p>本文考虑了在激励用户参与众包这一过程中的隐私问题。在本文的场景中，移动众包平台的目标是在一个预算限制下最大化众包收入，而用户期望是最大化他们的效用，同时保护他们的成本隐私。大致浏览了一下应该是用多臂赌博机在预算限制下实现最大化收入，用差分隐私实现隐私保护。</p>
<blockquote>
<p>偏重隐私保护，不确定是否有任务分配和定价等内容。</p>
</blockquote>
<h3 id="12-Privacy-Preserving-Incentive-Mechanisms-for-Truthful-Data-Quality-in-Data-Crowdsourcing"><a href="#12-Privacy-Preserving-Incentive-Mechanisms-for-Truthful-Data-Quality-in-Data-Crowdsourcing" class="headerlink" title="12-Privacy-Preserving Incentive Mechanisms for Truthful Data Quality in Data Crowdsourcing"></a>12-Privacy-Preserving Incentive Mechanisms for Truthful Data Quality in Data Crowdsourcing</h3><p>接包方的任务质量与数据是隐私信息，因此她有动机谎报。此外，接包方的质量和数据可能依赖于一些敏感信息（例如位置），这可以从对手的任务分配和数据聚合的结果中推断出来（没理解这句话）。本文设计了保护隐私的机制（PDQE）来获取接包方的质量和数据。在这些机制中，本文设计了不同的私有任务分配和数据聚合算法，以防止从这些算法的结果推断接包方的质量和数据。与此同时，这些机制还鼓励接包方如实报告质量和数据，并做出预期的努力。我们首先关注单个任务的机制(S-PDQE)，然后将其扩展到多个任务的情况(M-PDQE)。我们进一步证明，这两种机制实现了一个有限的性能差距相比，最优策略。</p>
<p>我们使用基于真实数据的仿真来评估所提出的机制，这些仿真证实了它们在真实数据质量提取、数据准确性和隐私保护等方面的优良性能。</p>
<blockquote>
<p>这篇应该有涉及任务分配的内容，时间关系没有详细看了。</p>
</blockquote>
<h3 id="13-Reward-or-Penalty-Aligning-Incentives-of-Stakeholders-in-Crowdsourcing"><a href="#13-Reward-or-Penalty-Aligning-Incentives-of-Stakeholders-in-Crowdsourcing" class="headerlink" title="13-Reward or Penalty Aligning Incentives of Stakeholders in Crowdsourcing"></a>13-Reward or Penalty Aligning Incentives of Stakeholders in Crowdsourcing</h3><p>本文针对二值众包问题场景（例如接包方只需要回答是或者否），考虑三方利益：接包方、发包方和众包平台，分析四个评价指标：质量、成本、延迟和平台改进。从整个众包系统的角度出发，设计了一个众包机制，将利益相关者的动机结合起来。具体来说，根据接包方的报告解决方案给予其奖励或处罚，在此基础上，找到了一系列合适的奖惩函数对，并计算出接包方的个人秩序值，这些秩序值可以根据接包方的报告信念和个人历史绩效提供不同的奖惩数额，同时保持接包方的激励。该机制有助于延迟控制，促进众包系统的质量和平台演进，并改进上述四个关键评价指标。理论分析和实验结果分别验证和评价了提出的机理。</p>
<blockquote>
<p>没有细看方法，粗略浏览感觉像是根据先验信念等估计接包方的准确性等。</p>
</blockquote>
<h3 id="14-Strategic-Social-Team-Crowdsourcing-Forming-a-Team-of-Truthful-Workers-for-Crowdsourcing-in-Social-Networks"><a href="#14-Strategic-Social-Team-Crowdsourcing-Forming-a-Team-of-Truthful-Workers-for-Crowdsourcing-in-Social-Networks" class="headerlink" title="14-Strategic Social Team Crowdsourcing Forming a Team of Truthful Workers for Crowdsourcing in Social Networks"></a>14-Strategic Social Team Crowdsourcing Forming a Team of Truthful Workers for Crowdsourcing in Social Networks</h3><p>本文针对的场景是社交网络中的团队众包，即发包方雇佣一个专业workers团队，而团队内的接包方有社交关联，可以协同工作。在传统的最大化社会福利的机制下，存在自私的接包方会损害发包方的利益，为避免这一问题，本文提出了两种有效机制来优化社会福利，同时降低不同规模应用的时间复杂度。对于小规模的应用，如果任务需要少量的技能，则首先从社会网络中提取出一个二叉树网络，然后在二叉树中形成一个基于动态规划的最优团队。对于任务需要大量技能的大规模应用，根据工人的社会结构、技能和工作成本使用贪婪算法形成团队。</p>
<blockquote>
<p>这篇应该有任务分配问题，不过还没看是怎么分配的。</p>
</blockquote>
<h3 id="15-Eliciting-Information-from-Heterogeneous-Mobile-Crowdsourced-Workers-Without-Verification"><a href="#15-Eliciting-Information-from-Heterogeneous-Mobile-Crowdsourced-Workers-Without-Verification" class="headerlink" title="15-Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification"></a>15-Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification</h3><p>本文场景：</p>
<ol>
<li>workers求解准确率异构（即，不同workers以不同概率生成高质量数据）</li>
<li>考虑数据质量与平台成本之间的平衡</li>
</ol>
<p>本文方法：多数投票机制</p>
<p>需要解决的问题：</p>
<ol>
<li>给定奖励，多数投票机制下，异构workers会如何行动；</li>
<li>workers的异构性如何影响平台的最优奖励设计和均衡；</li>
<li>在提升平台均衡方面，知道workers异构方案准确性有什么价值。</li>
</ol>
<p>本文的两阶段博弈：</p>
<ol>
<li>平台决定多数投票机制的奖励等级，目标是最大化收益，该收益考虑了workers解决方案质量和平台总支出之间的均衡；</li>
<li>每个worker选择自己的努力等级和报告策略，目标是最大化自己收益。</li>
</ol>
<p>本文考虑两种情况：</p>
<ol>
<li>不完全信息博弈（平台不知道workers的准确率）</li>
<li>完全信息博弈（平台知道workers的准确率）</li>
</ol>
<p>本文贡献：</p>
<ol>
<li>分析了IEWV问题中异构workers场景下的平台均衡</li>
<li>分析了多均衡共存的场景</li>
<li>刻画了workers的最优策略</li>
<li>刻画了workers异构性对平台均衡的影响</li>
<li>刻画了得知workers异构性的价值</li>
</ol>
<h3 id="16-Data-Poisoning-Attacks-and-Defenses-in-Dynamic-Crowdsourcing-with-Online-Data-Quality-Learning"><a href="#16-Data-Poisoning-Attacks-and-Defenses-in-Dynamic-Crowdsourcing-with-Online-Data-Quality-Learning" class="headerlink" title="16-Data Poisoning Attacks and Defenses in Dynamic Crowdsourcing with Online Data Quality Learning"></a>16-Data Poisoning Attacks and Defenses in Dynamic Crowdsourcing with Online Data Quality Learning</h3><p>为了提高数据的准确性和成本效益，工人的数据质量可以通过在线方式从他们的数据中学习，可以用于任务分配和数据聚合。然而，众包很容易受到数据病毒攻击，攻击者报告恶意数据以降低聚合数据的准确性。</p>
<p>本文研究了任务按顺序分配和执行的动态众包中的恶意数据攻击，探讨了作为一种防御机制的在线质量学习如何通过发现低质量的恶意工作者来抵御攻击。首先关注每个接包方的质量都被请求者准确学习的渐近设置，然后在此基础上转向一般的有误差非渐近设置。对于每个设置，首先描述了攻击策略可以有效降低聚合数据准确性的条件。结果表明，恶意噪声方差需要在一定范围内的攻击是有效的。然后分析了有效攻击策略的危害。研究结果表明，由于有效的攻击，在线质量学习算法的遗憾性会增加。为了进一步减轻攻击，研究了基于估计的数据聚合作为防御机制的中值和最大影响。研究结果为数据中毒攻击的影响提供了有用的见解，当在线高质量学习被用来抵御攻击时。我们通过基于真实数据的大量仿真结果对提出的攻击和防御方案进行了评估，验证了攻击和防御方案的有效性。</p>
<blockquote>
<p>这篇论文偏向数据污染问题，和我们可能关系不大。</p>
</blockquote>
<h3 id="17-Using-Truth-Detection-to-Incentivize-Workers-in-Mobile-Crowdsourcing"><a href="#17-Using-Truth-Detection-to-Incentivize-Workers-in-Mobile-Crowdsourcing" class="headerlink" title="17-Using Truth Detection to Incentivize Workers in Mobile Crowdsourcing"></a>17-Using Truth Detection to Incentivize Workers in Mobile Crowdsourcing</h3><p>众包模式相比于传统机构的工作模式，其工人通常是高度分散的，且工作过程也是不受监督的，这给他们上报低质量的解决方案提供了温床。并且这种现象在众包平台无法验证工人解决方案的质量时尤为突出。比如，在慕课上的学生作业互评，就曾出现过网上学生恶意打分的现象。</p>
<p>在平台无法验证工人提交的解决方案时，现有的众包激励机制主要通过对比不同工人上报方案之间的相似性来进行奖励，而这有可能造成众包工人共谋。比如，目前比较流行的激励方法是输出一致机制。在输出一致机制中，当一个工人和其他工人的上报方案高度一致时，这个工人会获得奖励。可是，在上述机制下，如果平台不能对工人进行有效的管控，那么工人之间可以共谋上报相同但低质量的方案。这种情况对平台来说是灾难性的，因为不仅平台得到的方案质量低，而且还需要给每一个工人发放奖励。</p>
<p>为了缓解上述的工人共谋问题，我们创新性地提出一种测谎机制。具体而言，工人们不再因为自己的上报方案和其他工人相似而获得奖励，而是根据工人回答一个指定测谎问题的答案进行计算。我们可以发现，基于该测谎问题的激励设计会可以有效缓解工人共谋。这是因为，众包工人能否获得奖励只和自己对测谎问题的回答有关，而不和他人的上报方案有关。</p>
<p>其实在现实世界中，我们已经发现测谎技术的一些应用场景了。比如一些欧洲国家在边境检查的时候利用测谎技术来对过境人士的身份进行认证（详情请见：<a href="https://iborderctrl.no/%EF%BC%89%E3%80%82%E7%84%B6%E8%80%8C%EF%BC%8C%E6%B5%8B%E8%B0%8E%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF%E8%BF%98%E4%B8%8D%E5%A4%9F%E6%88%90%E7%86%9F%EF%BC%8C%E4%B8%80%E8%88%AC%E8%80%8C%E8%A8%80%E8%83%BD%E8%BE%BE%E5%88%B0%E7%9A%84%E5%87%86%E7%A1%AE%E7%8E%87%E4%B9%9F%E4%B8%8D%E9%AB%98%EF%BC%88%E6%99%AE%E9%81%8D%E4%BD%8E%E4%BA%8E65%%EF%BC%89%E3%80%82%E4%B8%BA%E4%BA%86%E6%9C%80%E5%A4%A7%E5%8C%96%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%88%A9%E7%9B%8A%EF%BC%8C%E6%88%91%E4%BB%AC%E6%8F%90%E5%87%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E8%BF%91%E4%BC%BC%E5%87%B8%E7%9A%84%E6%B5%8B%E8%B0%8E%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E6%A1%86%E6%9E%B6%E3%80%82%E5%9C%A8%E8%AF%A5%E6%A1%86%E6%9E%B6%E4%B8%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%91%E7%8E%B0%E5%8D%B3%E4%BD%BF%E6%B5%8B%E8%B0%8E%E7%B2%BE%E5%BA%A6%E5%8F%AA%E6%9C%8960%%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%B9%B3%E5%8F%B0%E6%94%B6%E7%9B%8A%E5%8F%AF%E4%BB%A5%E8%B6%85%E8%BF%87%E5%9C%A8%E6%B5%8B%E8%B0%8E%E7%B2%BE%E5%BA%A6%E4%B8%BA100%%E4%B8%8B%E5%B9%B3%E5%8F%B0%E6%94%B6%E7%9B%8A%E7%9A%8485%%E3%80%82%E8%BF%99%E8%A1%A8%E6%98%8E%E6%88%91%E4%BB%AC%E6%8F%90%E5%87%BA%E7%9A%84%E6%B5%8B%E8%B0%8E%E6%9C%BA%E5%88%B6%E6%9C%89%E8%89%AF%E5%A5%BD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%8E%B0%E3%80%82" target="_blank" rel="noopener">https://iborderctrl.no/）。然而，测谎机制的底层技术还不够成熟，一般而言能达到的准确率也不高（普遍低于65%）。为了最大化平台的利益，我们提出了一个近似凸的测谎机制优化框架。在该框架下，我们发现即使测谎精度只有60%，我们的机制实现的平台收益可以超过在测谎精度为100%下平台收益的85%。这表明我们提出的测谎机制有良好的系统表现。</a></p>
<blockquote>
<p>这篇是黄建伟老师团队的，上述总结为公众号直接复制。看参考文献有贝叶斯实话血清的那个论文，推测是用了一样的方法。</p>
</blockquote>
<h3 id="18-Towards-Personalized-Task-Oriented-Worker-Recruitment-in-Mobile-Crowdsensing"><a href="#18-Towards-Personalized-Task-Oriented-Worker-Recruitment-in-Mobile-Crowdsensing" class="headerlink" title="18-Towards Personalized Task-Oriented Worker Recruitment in Mobile Crowdsensing"></a>18-Towards Personalized Task-Oriented Worker Recruitment in Mobile Crowdsensing</h3><p>移动众包系统中的任务通常具有时间敏感性和位置依赖性，这在员工招募中也起着至关重要的作用。基于此，本文提出了一种新颖的基于个性化任务驱动的移动众包系统员工招募机制，该机制基于对员工偏好的详细刻画，充分利用内容信息(例如，任务类别，任务描述)与上下文信息(例如，任务时间，任务位置)从工人出勤的隐性反馈，以准确地模型工人对任务的偏好。大致方法是做了一个分类器，识别workers所属的类别，进而分配相同类别的任务。</p>
<h3 id="19-Eliciting-Joint-Truthful-Answers-and-Profiles-from-Strategic-Workers-in-Mobile-Crowdsourcing-Systems"><a href="#19-Eliciting-Joint-Truthful-Answers-and-Profiles-from-Strategic-Workers-in-Mobile-Crowdsourcing-Systems" class="headerlink" title="19-Eliciting Joint Truthful Answers and Profiles from Strategic Workers in Mobile Crowdsourcing Systems"></a>19-Eliciting Joint Truthful Answers and Profiles from Strategic Workers in Mobile Crowdsourcing Systems</h3><p>在移动众包场景中，workers需要上传自己的个人信息（例如位置、专业能力等），本文设计激励机制保证workers上传的是真实信息，并招募志愿者进行了真实实验。</p>
<p>这篇论文也是针对二值回答的众包问题，用的方法基于贝叶斯推断，看上去和黄建伟老师那个有点像，没细看。</p>
<h3 id="20-Heterogeneous-Multi-Task-Assignment-in-Mobile-Crowdsensing-Using-Spatiotemporal-Correlation"><a href="#20-Heterogeneous-Multi-Task-Assignment-in-Mobile-Crowdsensing-Using-Spatiotemporal-Correlation" class="headerlink" title="20-Heterogeneous Multi-Task Assignment in Mobile Crowdsensing Using Spatiotemporal Correlation"></a>20-Heterogeneous Multi-Task Assignment in Mobile Crowdsensing Using Spatiotemporal Correlation</h3><p>现有的多任务分配方法大多侧重于同类任务，由于不同的时空任务需求和感知环境，众包系统中的任务往往在许多方面存在差异(如空间覆盖率、时间间隔)。为此，本文提出并形式化了移动众包系统中一个重要的异构多任务分配问题（HMTA），并尝试最大化数据质量和最小化总的激励预算。利用异构任务之间的隐含时空相关性，提出了一种两阶段 HMTA 问题求解方法，有效地处理共享资源池中的多个并发任务。最后，为了提高分配搜索效率，设计了一个分解组合框架来适应大规模的问题/情景。我们广泛地使用两个大规模的真实世界数据集来评估我们的方法。实验结果验证了该方法的有效性和有效性。</p>
<blockquote>
<p>具体是怎么解决的还没细看。</p>
</blockquote>
<h3 id="21-Secure-Crowdsensed-Data-Trading-Based-on-Blockchain"><a href="#21-Secure-Crowdsensed-Data-Trading-Based-on-Blockchain" class="headerlink" title="21-Secure Crowdsensed Data Trading Based on Blockchain"></a>21-Secure Crowdsensed Data Trading Based on Blockchain</h3><p>本文提出了一个基于区块链的众包数据交易(BCDT)系统，该系统靠智能合约保证数据交易的可靠性，采用基于区块链的反向拍卖(BRA)将感知任务分配给接包方，该机制可以保证数据收集者如实报告数据收集成本，防止卖方操纵拍卖。此外还实现了一个基于同态密码的安全真相发现和可靠性评级机制(STDR) ，该机制可以激励接包方上传真实数据，鼓励发包方在不泄露数据隐私的情况下，根据收集到的数据对接包方的可靠性进行真实评级。在以太坊测试网络上进行了智能合约的性能测试。</p>
<h3 id="列表中的第22篇和前面第2篇重复了。"><a href="#列表中的第22篇和前面第2篇重复了。" class="headerlink" title="列表中的第22篇和前面第2篇重复了。"></a>列表中的第22篇和前面第2篇重复了。</h3><h3 id="23-Two-Stage-Game-Design-of-Payoff-Decision-Making-Scheme-for-Crowdsourcing-Dilemmas"><a href="#23-Two-Stage-Game-Design-of-Payoff-Decision-Making-Scheme-for-Crowdsourcing-Dilemmas" class="headerlink" title="23-Two Stage Game Design of Payoff Decision-Making Scheme for Crowdsourcing Dilemmas"></a>23-Two Stage Game Design of Payoff Decision-Making Scheme for Crowdsourcing Dilemmas</h3><p>为了解决发包方和众包平台之间的合作困境，首先提出了一种基于信誉质量规则的发包方动态支付方法，然后开发了一种估算平台成本的合作评估算法，最后设计了一个共同确定算法来判断平台是否采用了合作策略。</p>
<p>为了解决众包平台与员工之间的服务质量困境，首先提出了一种拍卖筛选方法来估算员工的合理招聘范围，并利用成本评价算法对其进行优化，然后利用报酬分配方法来激励员工按时、高质量地完成任务。</p>
<h3 id="24-Data-Driven-Pricing-for-Sensing-Effort-Elicitation-in-Mobile-Crowd-Sensing-Systems"><a href="#24-Data-Driven-Pricing-for-Sensing-Effort-Elicitation-in-Mobile-Crowd-Sensing-Systems" class="headerlink" title="24-Data-Driven Pricing for Sensing Effort Elicitation in Mobile Crowd Sensing Systems"></a>24-Data-Driven Pricing for Sensing Effort Elicitation in Mobile Crowd Sensing Systems</h3><p>一些众包场景通过数据聚合来评估接包方的数据质量，但面临接包方策略性降低传感工作效率（存疑，原文是strategic reduction of their sensing effort）的问题，基于此，本文提出了一种名为 Theseus 的支付机制，它处理工人的这种战略行为，并激励工人的高努力感知。我们确保，在Theseus诱导的非合作博弈的贝叶斯纳什均衡点中，所有参与的工作人员都将尽可能地花费在感知上，从而提高了他们的数据质量。</p>
<blockquote>
<p>该机制具体是怎么实现的没有看。</p>
</blockquote>
<h3 id="25-Truthful-Mobile-Crowdsensing-for-Strategic-Users-With-Private-Data-Quality"><a href="#25-Truthful-Mobile-Crowdsensing-for-Strategic-Users-With-Private-Data-Quality" class="headerlink" title="25-Truthful Mobile Crowdsensing for Strategic Users With Private Data Quality"></a>25-Truthful Mobile Crowdsensing for Strategic Users With Private Data Quality</h3><p>众包数据准确性与接包方的私有信息相关，接包方可能出于个人利益控制这些信息和自己的努力程度，进而导致发包方对数据准确性有错误认知。本文设计了质量和努力启发(QEE)的真实众感机制，激励策略型用户如实地揭示他们的个人质量，如实地按照请求者的要求做出努力。QEE机制通过克服用户数据对其私有质量和隐藏努力的复杂依赖性来实现真实的设计。在 QEE 机制下，我们证明了发包方的最优努力分配(RO)只分配给具有最小“虚拟估值”的最优用户，这取决于用户的质量和质量的分布。我们还发现，随着用户数量的增加，RO 努力分配和社会最优努力分配之间的性能差距减小，并渐近收敛到0。我们进一步讨论了 QEE 机制的一些扩展。</p>
<blockquote>
<p>具体实现方法没看。</p>
</blockquote>
<h3 id="26-Differentially-Private-Incentive-Mechanism-for-Crowdsourced-Radio-Environment-Map-Construction"><a href="#26-Differentially-Private-Incentive-Mechanism-for-Crowdsourced-Radio-Environment-Map-Construction" class="headerlink" title="26-Differentially Private Incentive Mechanism for Crowdsourced Radio Environment Map Construction"></a>26-Differentially Private Incentive Mechanism for Crowdsourced Radio Environment Map Construction</h3><p>本文提出了一种基于众包的频谱感知的差分私有逆向拍卖机制。提出的机制允许 DBA 选择预算限制的频谱感知参与者，同时提供差别投标隐私、近似真实性和近似准确性最大化。</p>
<h3 id="27-Mechanism-design-games-for-thwarting-malicious-behavior-in-crowdsourcing-applications"><a href="#27-Mechanism-design-games-for-thwarting-malicious-behavior-in-crowdsourcing-applications" class="headerlink" title="27-Mechanism design games for thwarting malicious behavior in crowdsourcing applications"></a>27-Mechanism design games for thwarting malicious behavior in crowdsourcing applications</h3><p>是春池的论文。</p>
<p>采用发包方主导的契约型反恶意众包机制，根据个体恶意众包和集群恶意众包的不同特性，发包方将针对性地提出满足激励相容原则的契约，迫使接包方按照契约根据自己的真实私有信息（包括与恶意攻击相关的真实信息）制定最优策略，并据此可使发包方反推自己的最优策略，实现资源的最佳配置（最优任务量和最优酬金），通过经济手段遏制恶意众包。</p>
<p>设计接包方参与的契约型反恶意众包机制，使得接包方可针对契约制定提出意见、发包方在意见约束下制定契约，最终实现隐私保护的全局帕累托最优。</p>
<h3 id="28-Minimizing-Entropy-for-Crowdsourcing-with-Combinatorial-Multi-Armed-Bandit"><a href="#28-Minimizing-Entropy-for-Crowdsourcing-with-Combinatorial-Multi-Armed-Bandit" class="headerlink" title="28-Minimizing Entropy for Crowdsourcing with Combinatorial Multi-Armed Bandit"></a>28-Minimizing Entropy for Crowdsourcing with Combinatorial Multi-Armed Bandit</h3><p>衡量最终聚合结果的不确定性的工作者结果的经验熵，自然成为评估众包任务结果的一个合适的度量。因此，本文设计了一个工人选择机制，使参与者提交的结果的经验熵最小化。具体来说，我们将连续到达任务下的工作者选择规划为一个组合多臂老虎机问题，该问题将每个工作者视为一只手臂，旨在学习最佳的手臂组合，以最小化累积的经验熵。利用信息论方法，详细推导了经验熵极小化的置信上界估计，并将其应用到最小熵置信上界(ME-UCB)算法中，以平衡勘探与开发。</p>
<blockquote>
<p>总的来说就i是用多臂赌博机的模型，把经验熵作为衡量赌博机的遗憾函数。</p>
</blockquote>
<h3 id="29-Truthful-Incentive-Mechanisms-for-Crowdsourcing"><a href="#29-Truthful-Incentive-Mechanisms-for-Crowdsourcing" class="headerlink" title="29-Truthful Incentive Mechanisms for Crowdsourcing"></a>29-Truthful Incentive Mechanisms for Crowdsourcing</h3><p>针对接包方之间的竞争与合作，建立3种众包模型，并分别设计激励机制。</p>
<p>SS模型：一个发包方，一个投标（指每个接包方报价时只能报一个任务和自己愿意做任务的最低报酬）</p>
<p>SM模型：一个发包方，多个投标（指每个接包方报价时可以报多个任务和对应的最低报酬）</p>
<p>MM模型：多个发包方，多个投标</p>
<blockquote>
<p>具体的方法还需要之后再看。</p>
</blockquote>
<h3 id="30-Crowdsourcing-System-for-Numerical-Tasks-based-on-Latent-Topic-Aware-Worker-Reliability"><a href="#30-Crowdsourcing-System-for-Numerical-Tasks-based-on-Latent-Topic-Aware-Worker-Reliability" class="headerlink" title="30-Crowdsourcing System for Numerical Tasks based on Latent Topic Aware Worker Reliability"></a>30-Crowdsourcing System for Numerical Tasks based on Latent Topic Aware Worker Reliability</h3><p>本文针对的场景是采用依据主题进行任务分配的众包系统，本文旨在对数值任务中潜在主题的细粒度工作者可靠性进行精确估计，以进一步提高结果质量。提出了一种基于工作者行为的贝叶斯概率模型——高斯潜在主题模型(GLTM) ，用于挖掘数值任务的潜在主题，并估计工作者的主题级可靠性。利用该算法，提出了一种真值推理算法 ti-GLTM，可以同时准确推断任务的真值和主题，并动态更新工作者的主题级可靠性。我们还设计了一种在线任务分配机制，称为 MRA-GLTM，该机制利用最大限度减少模糊度原则为工作者分配合适的任务。</p>
<h3 id="31-MOMD-A-multi-object-multi-dimensional-auction-for-crowdsourced-mobile-video-streaming"><a href="#31-MOMD-A-multi-object-multi-dimensional-auction-for-crowdsourced-mobile-video-streaming" class="headerlink" title="31-MOMD A multi-object multi-dimensional auction for crowdsourced mobile video streaming"></a>31-MOMD A multi-object multi-dimensional auction for crowdsourced mobile video streaming</h3><p>针对场景：移动视频流资源共享，让附近的移动视频用户聚合他们的网络资源，以提高视频流的性能。</p>
<p>问题：用户自私，用户的异步下载行为以及对多比特率编码视频的私有估值</p>
<p>本文方法：基于多目标多维拍卖的激励框架，通过这个框架，用户可以下载多个不同比特率的视频片段给多个邻近的用户(和他们自己)。基于这一激励框架，我们提出了维克里分数拍卖，这是第一个多目标多维度拍卖，达到了真实性和效率。</p>
<h3 id="32-Incentivizing-crowdsourcing-systems-with-network-effects"><a href="#32-Incentivizing-crowdsourcing-systems-with-network-effects" class="headerlink" title="32-Incentivizing crowdsourcing systems with network effects"></a>32-Incentivizing crowdsourcing systems with network effects</h3><p>将网络效应看作是内在奖励的影响因素，并研究其对外在奖励设计的影响。我们没有假设参与者是固定的，而是展示了参与用户的数量进化到一个稳定的平衡，这要归功于网络效应和众包者提供的外部奖励之间的微妙互动。考虑到网络效应，我们设计了更复杂的外部奖励机制，并为众包者提出了新的最优策略以获得更高的效用。</p>
<blockquote>
<p>这个网络效应实际上和前面的社会关系、社会影响等是一样的。</p>
</blockquote>
<h3 id="33-Truthful-online-double-auctions-for-dynamic-mobile-crowdsourcing"><a href="#33-Truthful-online-double-auctions-for-dynamic-mobile-crowdsourcing" class="headerlink" title="33-Truthful online double auctions for dynamic mobile crowdsourcing"></a>33-Truthful online double auctions for dynamic mobile crowdsourcing</h3><p>把移动众包场景中发包方和接包方的双向互动建模为在线双向拍卖，明确考虑到用户和供应商的动态特性。我们提出了一个通用框架，用于设计动态移动众包的真实在线双向拍卖。该框架是表达性的，可以与不同的价格时间表。我们提出了四个价格表的价格排序在线双向拍卖来实现该框架，适用于不同的场景。</p>
<h3 id="34-How-to-crowdsource-tasks-truthfully-without-sacrificing-utility-Online-incentive-mechanisms-with-budget-constraint"><a href="#34-How-to-crowdsource-tasks-truthfully-without-sacrificing-utility-Online-incentive-mechanisms-with-budget-constraint" class="headerlink" title="34-How to crowdsource tasks truthfully without sacrificing utility Online incentive mechanisms with budget constraint"></a>34-How to crowdsource tasks truthfully without sacrificing utility Online incentive mechanisms with budget constraint</h3><p>现有的大多数机制仅适用于所有用户信息都是先验知道的离线场景。相反，我们关注的是一个更加现实的场景，在这个场景中，用户以随机顺序一个接一个地到达网上。基于在线拍卖模型，我们研究了用户到达时向众包者提交其私有类型的问题，众包者的目标是在指定的截止日期之前选择一个用户子集，以最大化选定用户在预算线下提供的服务的价值(假设是一个非负的单调子模块函数)。我们设计了两个在线机制，OMZ 和 OMG，分别满足零到达-离开时间和更一般情况下的计算效率、个体理性、预算可行性、真实性、消费者主权和持续竞争性。</p>
<blockquote>
<p>这篇看起来是结合了拍卖和排队论</p>
</blockquote>
<h3 id="35-Reputation-based-incentive-protocols-in-crowdsourcing-applications"><a href="#35-Reputation-based-incentive-protocols-in-crowdsourcing-applications" class="headerlink" title="35-Reputation-based incentive protocols in crowdsourcing applications"></a>35-Reputation-based incentive protocols in crowdsourcing applications</h3><p>内在的激励问题存在于众包应用中，因为员工和请求者都是自私的，他们的目标是战略性地最大化他们自己的利益。本文提出了一种基于重复博弈的新的博弈论模型来激励员工努力工作。针对工人追求自身利益时出现的非合作均衡与理想帕累托有效结果之间的社会福利差距，本文提出了一类基于社会规范的激励协议，将声誉机制与众包网站目前实施的定价机制相结合，以改善这类应用中出现的非合作均衡的性能。我们首先在一个众包网站上制定交换双边市场，请求者和工作者相互匹配，并重复博弈。随后，我们研究了协议设计者如何为该网站寻找一个最优且可持续的(均衡)协议以获得最高的社会福利的问题。我们证明了提议的激励协议可以使网站运行接近帕累托最优。此外，我们还研究了另一个场景，其中协议设计者的目标是最大化网站的收入，并评估最优协议的性能。</p>
<h3 id="36-TRAC-Truthful-auction-for-location-aware-collaborative-sensing-in-mobile-crowdsourcing"><a href="#36-TRAC-Truthful-auction-for-location-aware-collaborative-sensing-in-mobile-crowdsourcing" class="headerlink" title="36-TRAC: Truthful auction for location-aware collaborative sensing in mobile crowdsourcing"></a>36-TRAC: Truthful auction for location-aware collaborative sensing in mobile crowdsourcing</h3><p>在这篇文章中，我们解决了激励智能手机用户加入智能手机移动众包应用程序的问题。与现有的机构设计工作不同，我们在智能手机传感任务分配时，独特地考虑了位置信息的关键维度。然而，位置感知在很大程度上增加了理论和计算的复杂度。在本文中，我们引入了一个逆向拍卖框架来建立平台和智能手机之间的交互模型。我们严格地证明，最佳地确定中标是 NP 难的。本文设计了一种由两个主要部件组成的 TRAC 机构。第一部分是一个近似最优的近似算法，用于确定中标的多项式时间计算复杂度，它逼近的最优解在1 + ln (n) ，其中 n 是一个智能手机可以容纳的感知任务的最大数量。第二个组成部分是一个关键的支付方案，它保证提交的智能手机报价反映了执行感应任务的实际成本。</p>
<blockquote>
<p>这篇具体是什么方法还没看。</p>
</blockquote>
<h3 id="37-Incentivize-crowd-under-budget-constraint"><a href="#37-Incentivize-crowd-under-budget-constraint" class="headerlink" title="37-Incentivize crowd under budget constraint"></a>37-Incentivize crowd under budget constraint</h3><p>在这篇论文中，我们关注于激励群体工作者将一系列二元任务标记为严格的预算线。在众包系统中，我们正确地描述了任务的难度级别和工人的质量，在众包系统中，收集到的标签用序列贝叶斯方法进行聚合。为了激励员工进行群体标记任务，员工和平台之间的互动被建模为一个反向拍卖。我们揭示了平台效用最大化可能是难以解决的，为此我们提出了一个激励机制，用多项式时间计算复杂度来确定中标和付款。并从理论上证明了我们的机制是真实的、个体理性的、预算可行的。</p>
<h3 id="38-Free-Market-of-Crowdsourcing-Incentive-Mechanism-Design-for-Mobile-Sensing"><a href="#38-Free-Market-of-Crowdsourcing-Incentive-Mechanism-Design-for-Mobile-Sensing" class="headerlink" title="38-Free Market of Crowdsourcing Incentive Mechanism Design for Mobile Sensing"></a>38-Free Market of Crowdsourcing Incentive Mechanism Design for Mobile Sensing</h3><p>现有研究没有考虑到智能手机用户在感兴趣的领域的机会主义性质。具体来说，对于一般的智能手机感应应用程序，该平台会在每个用户到达时分配任务，并根据用户的回复立即做出决定。为了适应这种一般情况，我们设计了三种基于在线逆向拍卖的在线激励机制： TBA、 TOIM 和 TOIMAD。TBA 旨在追求平台效用最大化，TOIM 和 TOIM-ad 则实现了真实性的关键属性。所有的机制都具有期望的计算效率、个体理性和收益性。此外，与最佳离线解决方案相比，它们具有很强的竞争力。</p>
<blockquote>
<p>这篇也是用了拍卖，看上去可能还考虑了前面的社会关系。</p>
</blockquote>
<h3 id="39-Expertise-Aware-Truth-Analysis-and-Task-Allocation-in-Mobile-Crowdsourcing"><a href="#39-Expertise-Aware-Truth-Analysis-and-Task-Allocation-in-Mobile-Crowdsourcing" class="headerlink" title="39-Expertise-Aware Truth Analysis and Task Allocation in Mobile Crowdsourcing"></a>39-Expertise-Aware Truth Analysis and Task Allocation in Mobile Crowdsourcing</h3><p>针对众包数据准确性问题，现有方案大多从噪声数据中推断和利用移动用户的可靠性来识别真实性的技术，并将任务分配给具有较高可靠性的用户。但是存在问题：用户可能只对某些问题(在某些领域)具有专业知识，而对其他问题没有专业知识，从而导致真值分析的估计精度低和任务分配无效。</p>
<p>基于此，本文提出了专家意见真值分析和任务分配(ETA 2) 方案，它可以有效地推断用户的专家意见，然后根据推断出的专家意见评估真相和分配任务。ETA 2依赖于一种新颖的语义分析方法来识别专家，以及一种专家意识的真理分析方法来发现真理。针对 ETA 2中基于专家意识的任务分配问题，本文提出并解决了两个基于优化目标的问题: 最大质量任务分配问题和最小成本任务分配问题。基于两个实际数据集和一个合成数据集的实验结果表明，ETA 2的性能明显优于现有的解决方案。</p>
<blockquote>
<p>这篇具体是怎么进行任务分配的还需要再看看。</p>
</blockquote>
<h3 id="40-Online-mobile-Micro-Task-Allocation-in-spatial-crowdsourcing"><a href="#40-Online-mobile-Micro-Task-Allocation-in-spatial-crowdsourcing" class="headerlink" title="40-Online mobile Micro-Task Allocation in spatial crowdsourcing"></a>40-Online mobile Micro-Task Allocation in spatial crowdsourcing</h3><p>现有的研究大多集中在离线场景上，给出了微任务和群体工作者的所有时空信息。然而，由于微任务和群体工作者在实际应用中是动态出现的，而且他们的时空信息是不能事先知道的，因此这种方法是不切实际的。针对现有离线方法的不足，本文首先提出了一个更为实用的微任务分配问题，称为空间众包(GOMA)中的全球在线微任务分配问题。我们首先将在线最大加权二部匹配问题的最新算法扩展到<br> GOMA 问题作为基线算法。虽然基线算法为最坏情况提供了理论保证，但由于最坏情况发生的概率在现实世界中非常低，其实际平均性能不够好。因此，我们考虑了在线算法的平均性能，即在线随机序列模型，提出了一个基于两阶段的框架，在此基础上我们提出了在线随机序列模型下1/4竞争比的 TGOA 算法。为了提高其效率，我们进一步设计了 TGOA-Greedy 算法，该算法运行速度快于 TGOA 算法，但竞争比为1/8。</p>
<h3 id="41-Multi-Objective-Optimization-based-Allocation-of-Hetrogeneous-Spatial-Crowdsourcing-Tasks"><a href="#41-Multi-Objective-Optimization-based-Allocation-of-Hetrogeneous-Spatial-Crowdsourcing-Tasks" class="headerlink" title="41-Multi-Objective Optimization based Allocation of Hetrogeneous Spatial Crowdsourcing Tasks"></a>41-Multi-Objective Optimization based Allocation of Hetrogeneous Spatial Crowdsourcing Tasks</h3><p>在本文中，我们考虑一个空间众包场景：除了特定的空间约束，每个任务有一个有效的持续时间，操作复杂性，预算限制，和所需的工人数量。每个志愿工作者在完成日常工作的同时完成指定的任务。该系统具有期望的任务概率覆盖率和预算线。在这种情况下，我们研究了一个重要的问题，即异质空间众包任务分配问题(HSC-TA)，该问题致力于为多目标最佳化问题搜索一组具有代表性的帕累托最优分配方案，使分配的任务覆盖最大化，同时激励成本最小化。为了适应异质空间众包中的多种约束条件，我们建立了一个与分配过程相一致的工作者移动行为预测模型。证明了 HSC-TA 问题是 np 难问题。我们提出了有效的启发式方法，包括多轮线性权重优化和增强的多目标粒子群优化算法，以实现足够的帕累托最优分配。</p>
<h3 id="42-Group-Oriented-Task-Allocation-for-Crowdsourcing-in-Social-Networks"><a href="#42-Group-Oriented-Task-Allocation-for-Crowdsourcing-in-Social-Networks" class="headerlink" title="42-Group-Oriented Task Allocation for Crowdsourcing in Social Networks"></a>42-Group-Oriented Task Allocation for Crowdsourcing in Social Networks</h3><p>以往的众包研究通常采用面向个人的方法，将任务外包给个人员工或基于团队组成的方法，将任务外包给人为组成的员工团队。如今，工人们通常通过社交网络自然而然地组织成群。为了解决实际众包系统中的群体工作者这一常见问题，本文探讨了一种新颖的众包范式，其中任务分配目标是自然存在的工作者群体，而不是像以前那样是个体工作者或人工组成的团队。由于一个自然群体可能不具备完成复杂任务所需的所有技能，并且需要与社会网络环境中的其他群体进行协调，因此提出了语境众包价值的概念，通过与其语境群体进行协调来衡量一个群体完成任务的能力，语境群体决定了该群体被分配任务的优先级;然后，设计了任务分配算法，包括分配群体和实际参与执行任务的工人。在现实数据集上的实验表明，与以往的基准个体导向和团队组建方法相比，我们提出的面向群体的方法几乎总是能够获得更好的协同性能、一致性能、冲突性能、适应性和降低成本的有效性。</p>
<h3 id="43-Target-Tracking-via-Crowdsourcing-A-Mechanism-Design-Approach"><a href="#43-Target-Tracking-via-Crowdsourcing-A-Mechanism-Design-Approach" class="headerlink" title="43-Target Tracking via Crowdsourcing A Mechanism Design Approach"></a>43-Target Tracking via Crowdsourcing A Mechanism Design Approach</h3><p>本文提出了一种基于众包的近视目标跟踪框架，在无线传感器网络中设计了一种最优的激励相容机制，该机制包含自私和利益驱动的传感器。在传感器带宽有限的典型无线传感器网络中，融合中心(FC)必须在传感器之间分配传输到 FC 的总比特数。在这里考虑的公式中，FC 通过向自私的传感器征求出价来进行拍卖，这反映了它们对能源成本的估值。此外，该模型还保证了传感器的合理性和真实性。最后一个问题是多项选择背包问题问题(MCKP) ，这个问题用动态规划方法在伪多项式时间中得到了解决。仿真结果表明了该方法在跟踪性能和传感器网络生存期方面的有效性。</p>
<blockquote>
<p>这篇是针对近视目标跟踪的，不清楚是否涉及任务分配等。</p>
</blockquote>
<h3 id="44-Crowdsourcing-Sensing-to-Smartphones-A-Randomized-Auction-Approach"><a href="#44-Crowdsourcing-Sensing-to-Smartphones-A-Randomized-Auction-Approach" class="headerlink" title="44-Crowdsourcing Sensing to Smartphones A Randomized Auction Approach"></a>44-Crowdsourcing Sensing to Smartphones A Randomized Auction Approach</h3><p>因为对于来自众包者的某个给定的传感作业，只选择一小部分智能手机执行传感任务，其余的则不予选择，所以向移动用户提供众包的最先进的拍卖机制通常具有确定性。这种确定性拍卖机制的一个明显缺点是减少了感知作业的多样性。因此，收集到的传感数据的质量也下降了。这是由于未能利用移动众包网络中大量不同的移动用户的内在优势。针对社会成本最小化问题，提出了一种随机组合拍卖机制，证明了该机制是 np 难的。设计了一种近似最优的任务分配算法，该算法具有多项式时间复杂度，并以此为基础构造了整个随机拍卖机制。与确定性拍卖机制相比，提出的随机拍卖机制增加了给定感知任务的贡献用户的多样性。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Fast randomized consensus using shared memory</title>
    <url>/2022/03/03/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Fast%20randomized%20consensus%20using%20shared%20memory/</url>
    <content><![CDATA[<h1 id="使用共享内存的快速随机共识"><a href="#使用共享内存的快速随机共识" class="headerlink" title="使用共享内存的快速随机共识"></a>使用共享内存的快速随机共识</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>我们提出了一个新的随机算法，用于在读写共享寄存器进行通信的异步进程之间达成共识。过去已知的最快的算法时间复杂度为指数运行时间，我们的算法是多项式的，$O(n^4)$。该算法的应用包括从并发数据结构中消除关键部分，以及构建渐进无偏的共享硬币。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>共识协议</strong>：一组$n$个通过将操作应用于<strong>共享对象</strong>进行通信的异步处理器。</p>
<p>​    对象：信道、读写寄存器数组等</p>
<p><strong>进程</strong>：从输入值开始（0或1），运行到选择决策值后停止</p>
<p>当共识协议是<strong>一致</strong>、<strong>有效</strong>、<strong>无等待</strong>时，就是<strong>正确</strong>的。</p>
<p>​    共识协议的<strong>一致</strong>：没有两个进程选择不同的决策值。</p>
<p>​    共识协议的<strong>有效</strong>：决策值是某些进程的输入值。</p>
<p>​    共识协议的<strong>无等待</strong>：每个进程都在有限数量步骤后决定。</p>
<p>编码共享数据的并发访问的传统方式：依赖于<strong>临界区</strong></p>
<p>​    <strong>临界区</strong>：同一时间只允许一个进程操作对象</p>
<p>临界区不适用于异步、容错系统：如果在一个临界区中，错误进程停止或延迟了，非容错进程也会被停止和延迟。反之，如果并发数据对象的实现保证任何进程将在$n$个步骤中完成任何操作，而不受其他停止故障或速度变化的进程的影响，则该实现是免等待的。如果针对对象$X$存在一个共识协议，则我们可以使用$X$构建针对任一并发数据对象的无等待实现。</p>
<p>如果共享对象$X$是提供读写操作的寄存器数组，那就无法达成共识了。如果$X$是提供TAS指令（把给定的内存地址设置为1，然后返回之前的旧值的原子操作）或FAA指令（内存位置增加一个数量的原子操作）的寄存器数组，则可以在两个进程间达成共识，但不能在三个进程间达成共识。然而，在这两种情况下，任意数量的进程之间仍然可以在概率上达成共识。本文提出了两种新的随机共识协议，一种是进程通过读取和写入共享寄存器进行通信，另一种是通过应用FAA操作进行通信。这些协议是一致的，非平凡的，它们保证每个进程在有限的预期步骤数之后决定。读写协议中，目前最快的算法时间复杂度是$2^{O(n^2)}$，本文则改进为$n^2$次写操作和$n^4$次读操作；FAA协议则预期需要$n^2$次FAA操作。</p>
<p>我们描述了一个简单的协议，如果对手调度程序以同步方式运行进程，该协议具有指数级的预期运行时间。每个进程在每轮中掷出一个无偏的硬币，当所有$n$个进程同时掷出”正确”值时，协议停止。在任何特定回合终止的概率为$\frac{1}{2}^n$。因此，在终止之前的预期回合数为$2^n$。加速协议的一种方法是用进程共享的单个无偏硬币替换$n$个独立的硬币翻转。但是，在异步系统中实现无偏的共享硬币被证明是不可能的（见下文第8节）。</p>
<p>类似于Chor，Merritt和Shmoys[13]提出的见解，它足以确保进程有足够的可能性翻转相同的值，并且对手调度程序对选择哪个值的影响足够弱。我们的共识协议的核心是一个弱共享硬币协议，它保证：</p>
<ol>
<li>进程可能观察到相同的结果；</li>
<li>对手调度程序对该结果的影响很小；</li>
<li>协议在进程数量上具有预期的运行时间多项式。</li>
</ol>
<p>共识通常被视为一种博弈。进程一方试图与对手调度器达成协议。进程将读和写操作应用到共享寄存器，对手选择操作实际发生的时间。我们的对手非常强大，它拥有关于进程协议、它们的内部状态和共享内存状态的完整信息。它不局限于多项式资源，因此它不能被加密方案所超越。然而，对手无法预测未来的硬币投掷。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Best reply structure and equilibrium convergence in generic games</title>
    <url>/2021/11/11/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Best%20reply%20structure%20and%20equilibrium%20convergence%20in%20generic%20games/</url>
    <content><![CDATA[<h1 id="最优回复结构和泛型博弈中的均衡收敛"><a href="#最优回复结构和泛型博弈中的均衡收敛" class="headerlink" title="最优回复结构和泛型博弈中的均衡收敛"></a>最优回复结构和泛型博弈中的均衡收敛</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>博弈论是决策者之间战略互动的一组数学模型，应用于各种问题，如合作的出现、语言形成、道路和互联网的拥堵。同样的数学工具也被用来模拟生态学和种群生物学中的进化。一个长期存在的问题是，当玩家通过重复进行博弈来学习时，他们是否会收敛到一个均衡点。对于一般情况，人们知之甚少，因为答案取决于博弈的性质和学习算法。在这里，我们引入了一个形式主义，我们称之为最佳回复结构，它给出了一个对于一个广泛类型的学习算法在任意两个正则形式的博弈中的收敛概率的粗略估计。类似于我们的方法在其他领域中应用的例子是生态学中的定性稳定性理论和使用雷诺数来理解流体动力学中的湍流。</p>
<p>解决博弈论均衡收敛问题的标准方法是关注具有特殊数学性质的博弈类，选择它们作为现实世界情景的程式化模型。例如，在位势博弈（potential games，也翻译成潜在博弈）中，单方面改变策略的所有收益差异都可以用一个全局势函数来表示;  拥塞博弈<sup><a href="#fn_1" id="reffn_1">1</a></sup>属于这一类，所以位势博弈可以作为交通的程式化模型。位势博弈中大多数学习算法收敛到一个纳什或相关的均衡在潜在的对策，在优势可解博弈（dominance-solvable game）、协调博弈（coordination game）、超模博弈（supermodular game）和弱环博弈（weakly acyclic game）中也是如此。研究具有特殊属性的博弈在机制设计等某一方玩家可以选择博弈形式的情况下是非常有用的。在这些情况下，也可以设计玩家将要使用的学习算法，并选择最有可能收敛到均衡的算法，例如在线拍卖和网络路由。</p>
<p>然而，仍然有一些问题，其博弈和学习算法不是由某一方设计的，而是由博弈本身的属性特点决定的。例如，一个金融市场可以被看作是一种博弈，其中有许多与交易者买卖资产相关联的可能行为。结果可能会收敛到一个均衡，或者它可能内生波动。如果这个系统不是为了鼓励收敛而设计的，那么我们应该期待这两种行为中的哪一种？</p>
<p>为了解决这个问题，我们采用了一种在20世纪90年代理论生态学和90年代发育生物学非常有效的方法，这种方法在物理学中非常普遍。这种方法的一个例子是May发表在理论生态学的一篇开创性论文。他研究了一个随机产生的捕食者-被捕食者相互作用的集合，他把这个集合作为一般生态系统的零模型。他的主要结论是随机的生态系统会随着它们的变大而变得更加不稳定。当然，梅很清楚，真正的生态系统不是随机的;  相反，它们是由进化选择和其他力量塑造的。许多大型生态系统已经存在了很长一段时间，这表明它们实际上是稳定的。因此，这一矛盾表明，真正的生态系统并不是梅模型中使用的随机整体的典型成员，这就提出了一个重要问题:  这些生态系统究竟是如何非典型化的，以及它们是如何以及为什么进化到稳定。四十五年后，正确回答这个问题仍然是一个活跃的研究课题。例如，约翰逊等人最近发现，真正的生态系统具有一种他们称之为营养连贯性的特性，并表明，将这种特性作为随机生成的生态系统集合的约束条件，可以确保稳定性。</p>
<p>在本文中，我们将类似的方法应用到博弈论中，将随机生成的两人博弈集合作为一个零模型。为了方便处理，我们研究标准形式的博弈，因为它可以系统地列举所有可能的博弈。通过增加可变的约束以理解它们对收敛到均衡的影响，零模型得到了改进。在这里，我们详细研究了一个参数$G$，它调节了两个参与者的收益之间的相关性。这调节了博弈中的竞争强度，包括零和博弈作为$G=-1$的一个特例。我们也勾勒出一个玩家如何构造其他的约束，例如，研究潜在博弈的偏差。通过这种方法，我们可以看到在特定类别的博弈中的偏差是如何影响学习动态的稳定性的。</p>
<p>随机生成的博弈和一般的学习算法没有可以得到精确解的数学性质。为了克服这个局限性，我们发展了一个形式主义，以获得近似收敛概率，这个近似概率是一个简单指标的函数。与流体动力学的类比阐释了这些近似解是如何发挥作用的。当流体离开平衡时，它通常会从稳定(或层流)流动过渡到不稳定(或紊流)流动。虽然描述流体动力学的纳维－斯托克斯方程没有解析解，但是这种转变仍然可以用一个叫做雷诺数的无量纲参数来粗略地描述。雷诺数越大，湍流发生的可能性越大。尽管这个预测并不准确ーー它只是一个经验法则ーー但它仍然非常有用。我们对博弈的类似估计并没有一个简单的封闭形式，但它具有类似的预测能力。我们的方法的另一个类比是理论生态学的定性稳定性理论。生态学中的许多模型都考虑食物网中不同物种之间相互作用的程度。例如，这些模型考虑了兔子吃多少草和狐狸吃多少兔子。质量稳定性方法只考虑了捕食者-被捕食者关系的特征，即兔子吃草，狐狸吃兔子。这使得仅仅从生态系统食物网的拓扑特性就可以获得生态系统稳定性的近似评估成为可能。与定性稳定性理论一样，我们的方法只依赖于对策的拓扑性质，而不依赖于收益的细节。</p>
<p>我们的形式主义是基于最优回复动态，在这种动态下，每个玩家都以最优回复对手的最后一次行动。最优回复动力学在博弈论中是众所周知的，它被广泛用于发展学习的直觉，但是我们以一种新的方式使用它，以获得一般博弈中收敛的近似概率。在最优回复动态下，系统要么渐近收敛到一个对应于纯策略纳什均衡的固定点，要么陷入一个循环。我们考虑在基于最优回复循环与博弈固定点相对大小的博弈中的一个非常简单的非收敛指标。请注意，我们并没有假设玩家遵循最优回复动态。相反，我们假设收益矩阵的最优回复结构构成了一阶骨架，构成了玩家们试图学习的博弈骨干，这对于理解许多学习算法的收敛性是有用的。</p>
<p>为了验证这一假设，我们选择了一组从真人博弈实验中得到的学习算法，包括强化学习、虚拟博弈<sup><a href="#fn_2" id="reffn_2">2</a></sup>、有噪声和无噪声的经验加权、k-level学习。我们也引入了（二种群）复制因子动力学在生态学和种群生物学中的重要性。基于最优回复动力学的方法预测了这些算法在R2≥0.78时的不收敛频率。</p>
<p>在这里，我们想强调的是，我们的目标是描述性的，而不是规范性的。在机制设计中，人或机器使用具有良好收敛性能的算法。例如，一些算法收敛到相关均衡——一种纳什均衡的概括，允许玩家在所有博弈中对一个共同的信号进行协调。其中一种算法是遗憾匹配算法，在这种算法中，玩家考虑所有过去的比赛历史，并计算如果他们采取任何其他行动，他们的回报会是什么。虽然这些算法可能由机器或具有足够记录能力的人执行，但除非经过专门训练，否则它们似乎不太可能被真人使用。据我们所知，这些算法只有间接的经验支持。我们关注的是经过实验测试的算法。当它们到达一个固定点时，这些算法会收敛到一个纳什均衡点，或者一个接近一个的点，而不是一个更一般的相关平衡。</p>
<p>在展示了最优回复结构形式主义的工作原理之后，我们分析了最优回复循环或不动点如何随着博弈中两个属性的变化而变化。我们根据玩家可用的动作数$N$来定义一个游戏的复杂程度。一个简单的游戏只有几个动作，而一个复杂的游戏有许多动作。博弈的竞争力由两个参与者的收益之间的相关性$G$来定义。负相关越多，竞争就越激烈。最优回复循环与固定点相比之下的相对占有率跟踪了我们所考虑的六种算法的收敛频率，因为我们改变了这些博弈的两个性质，除了竞争性博弈中的虚拟博弈。</p>
<p>我们发现，上述观点的一个极端——简单且非竞争性的博弈——不太可能具有循环，而另一个极端——复杂且竞争性的博弈——则很可能有循环。前文提到的几种博弈（位势博弈、优势可解博弈、协调博弈、超模博弈、弱环博弈）在构造上都是非循环的。这几类中的任何一个都可能是简单且非竞争性博弈的典型案例，但它们肯定不是复杂且竞争性博弈中的典型例子。这与人们的直觉相吻合，即复杂的博弈更难学，当一个玩家的收益意味着另一个玩家的损失时，玩家之间更难合作。我们的形式化方法使这一直觉定量化。例如，如果每个玩家有两个动作，且两个玩家的收益没有相关性，则非循环博弈占据了其中的85%，反之，如果有10个动作，收益相关性为-0.7，则非循环博弈只占有2.7%。</p>
<p>我们还展示了如何使用最优回复形式来研究某一类博弈的稳定性，例如位势博弈，以了解它们在偏离给定情景下的稳定性。我们证明了这种稳定性的变化可以是非线性的，例如，位势博弈的小扰动会导致不收敛的概率大幅度增加。</p>
<p>在收益不相关的情况下，我们使用受统计力学启发的组合方法来分析计算不同长度的最佳回复循环的频率。受统计力学启发而产生的方法在博弈论中并不新鲜。先前的研究已经量化了纯策略纳什均衡点(22-25)、混合策略均衡(26,27)和帕帕累托均衡(28)的性质，但是我们是第一个量化最佳回复循环的频率和长度并显示它们与博弈论策略学习的相关性的研究。</p>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><h3 id="Best-reply-structure"><a href="#Best-reply-structure" class="headerlink" title="Best reply structure"></a>Best reply structure</h3>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Optimal and Quantized Mechanism Design for Fresh Data Acquisition</title>
    <url>/2021/11/01/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Optimal%20and%20Quantized%20Mechanism%20Design%20for%20Fresh%20Data%20Acquisition/</url>
    <content><![CDATA[<h1 id="新鲜数据采集的优化量化机制设计"><a href="#新鲜数据采集的优化量化机制设计" class="headerlink" title="新鲜数据采集的优化量化机制设计"></a>新鲜数据采集的优化量化机制设计</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h2 id="System-Model-and-Problem-Formulation"><a href="#System-Model-and-Problem-Formulation" class="headerlink" title="System Model and Problem Formulation"></a>System Model and Problem Formulation</h2><h3 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h3><p>数据源集合：$\mathcal{I}=\{1\leq i\leq I\}$，生成数据包并发送给目标</p>
<p>目标：需要平衡与数据新鲜度相关的成本和与数据本身的货币成本</p>
<p>数据源：需要平衡收益、采样成本和更新频率</p>
<ol>
<li><p>数据更新与调度：</p>
<p>随时生成模型——数据源可以在目标要求时生成并发送数据；忽略数据传输延迟。</p>
<p>目标的数据获取策略：更新策略$\mathcal{X}$和调度策略$\mathcal{S}$</p>
<p>​    更新策略：表示两次更新间隔时间的集合，$\mathcal{X}=\{x_k\}_{k\in \mathbb{N}}$，$x_k$表示第k-1次更新和第k次更新之间的时间间隔</p>
<p>​    调度策略：用来指定选哪个数据源来更新的二值集合，$\mathcal{S}=\{s_{i,k}\}_{i\in\mathcal{I},k\in\mathbb{N}}$，$s_{i,k}=1$表示第k次更新选了第i个数据源，反之为0表示没选这个数据源，每次更新只选择一个源，因此$\sum_{i\in \mathcal{I}} s_{i,k}=1, s_{i,k}\in\{0,1\}$</p>
<p>​    第i个数据源的第k-1次更新到第k次更新之间的时间间隔用$y_{i,k}$表示，计算方法是把中间的$x_k$加起来</p>
<p>​    每个数据源的更新受限于最大更新频率：$f_{i,max}$</p>
</li>
<li><p>信息年龄AoI：时间t的AoI定义：$\Delta_t\{\mathcal{X}\}=t-U_t$，$U_t$表示在t时刻之前的最近一次更新时间</p>
</li>
<li><p>数据源采样成本和隐私信息：</p>
<p>第i个数据源的单位采样成本是$c_i$，是私有信息，认为该成本在$\mathcal{C}_i=[\underline{c}_i,\hat{c}_i]$，</p>
<p>累计分布函数和概率密度函数分别是$\Gamma_i(c_i)$和$\gamma_i(c_i)$，是公开信息</p>
</li>
<li><p>目标的AoI成本：</p>
<p>AoI成本函数$g(\Delta_t(\mathcal{X}))$，用于表示目标对数据陈旧的不满程度，是以AoI为自变量的一个非负增函数</p>
<p>目标的累计AoI成本：$G(x)=\int_0^x g(\Delta_t)d\Delta_t$，表示时间范围x内的累计成本，是凸函数（二阶导大于0的那种）</p>
</li>
</ol>
<h3 id="Mechanism-Design-and-Reporting-Game"><a href="#Mechanism-Design-and-Reporting-Game" class="headerlink" title="Mechanism Design and Reporting Game"></a>Mechanism Design and Reporting Game</h3><p>数据源和目标之间的两阶段博弈：</p>
<ol>
<li>目标设计机制$m=(\mathcal{P},\mathcal{X},\mathcal{S})$，并发布给数据源，分别是支付策略、更新策略和调度策略，这三个都是以数据源的报告成本$\widetilde{c}_i$为自变量的函数，目标支付的报酬会根据更新频率和数据源的选择而不同。</li>
<li>数据源提交自己的采样成本$\widetilde{c}_i$，可能是假的</li>
</ol>
<h4 id="多源系统"><a href="#多源系统" class="headerlink" title="多源系统"></a>多源系统</h4><p>报告博弈(Reporting Game) $\mathcal{G}=\{\mathcal{I},\{\mathcal{C}_i\}_{i\in I},\{\mathcal{P}_i\}_{i\in I}\}$</p>
<p>玩家：所有数据源$\mathcal{I}$的集合</p>
<p>策略空间：每个数据源$i$的报告策略是$\widetilde{c}_i\in C_i$</p>
<p>收益：每个数据源$i$的收益函数如下</p>
<script type="math/tex; mode=display">
P_i(\widetilde{c}_i,\widetilde{c}_{-i},m)=lim\ inf_{K->\infty}\frac{\sum_{k=1}^K s_{i,k}(\widetilde{c})(p_{i,k}(\widetilde{c})-c_i)}{\sum_{k=1}^K x_k(\widetilde{c})}</script><p>这个收益函数的解释：每个数据源的收益是一个长时间累积收益的单位时间平均值（这里是净收益，也就是到手的报酬减去成本）</p>
<p>根据一些参考文献，一个深思熟虑的数据源并不是策略性的，而是短视的，即：并不会最大化他们可见的 长期收益（也就是上面这个公式）</p>
<p>由于每个数据源都不知道其他数据源的具体成本$\widetilde{c}_{-i}$，只知道相关的先验分布，因此可得到下述贝叶斯均衡：</p>
<p><strong>定义1</strong>（贝叶斯均衡）：贝叶斯均衡是：对于每一个数据源$i$，在机制$m$和其他数据源的报告$\widetilde{c}_{-i}$不改变的情况下，使得该数据源收益最大的那个报告<script type="math/tex">\tilde{c}^{*}(m)=\left\{\tilde{c}_{i}^{*}(m)\right\}_{j \in \mathcal{T}}</script></p>
<p>而目标的目的是设计一个最优机制来最小化自己的总期望支出（长期平均值），总支出由AoI支出和数据源支出组成，函数如下：</p>
<script type="math/tex; mode=display">
J(m)=\mathbb{E}_{\boldsymbol{c}} \left[\operatorname { lim sup} _ { K \rightarrow \infty } \left(\frac{\sum_{k=1}^{K} G\left(x_{k}\left(\tilde{\boldsymbol{c}}^{*}(m)\right)\right)}{\sum_{k=1}^{K} x_{k}\left(\tilde{\boldsymbol{c}}^{*}(m)\right)}\right.\right.
+\left.\left.\frac{\sum_{k=1}^{K} \sum_{i \in \mathcal{I}} s_{i, k}\left(\tilde{\boldsymbol{c}}^{*}(m)\right) p_{i, k}\left(\tilde{\boldsymbol{c}}^{*}(m)\right)}{\sum_{k=1}^{K} x_{k}\left(\tilde{\boldsymbol{c}}^{*}(m)\right)}\right)\right],</script><p>其中$\tilde{\boldsymbol{c}}^{*}(m)$是贝叶斯均衡。</p>
<p>每个数据源都有动机谎报成本，根据显示原理，对于任意机制$m$，一定存在一个激励相容机制$\tilde{m}$，使得$J(m)=J(\tilde{m})$</p>
<p>总结一下这里就是说，我们设计出的机制要满足激励相容约束和个体理性约束，前者保证数据源如实上报，后者保证数据源期望收益非负，这两个约束写成公式的形式如下：</p>
<script type="math/tex; mode=display">
\mathrm{IC}: \quad c_{i} \in \arg \max _{\tilde{c}_{i} \in \mathcal{C}_{i}} \mathbb{E}_{\boldsymbol{c}_{-i}}\left[P_{i}\left(\tilde{c}_{i}, \boldsymbol{c}_{-i}, m\right)\right], \quad \forall i \in \mathcal{I}</script><script type="math/tex; mode=display">
\operatorname{IR}: \quad \max _{\tilde{c}_{i} \in \mathcal{C}_{i}} \mathbb{E}_{c_{-i}}\left[P_{i}\left(\tilde{c}_{i}, \tilde{\boldsymbol{c}}_{-i}^{*}(m), m\right)\right] \geq 0, \quad \forall i \in \mathcal{I}</script><h4 id="单源系统"><a href="#单源系统" class="headerlink" title="单源系统"></a>单源系统</h4><p>只有一个数据源的特殊情况下，不存在数据源之间的博弈，激励相容和个体理性简化成下述形式：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\mathrm{IC}-\mathrm{S}: & c \in \arg \max _{\tilde{c} \in \mathcal{C}} P(\tilde{c}, m) \\
\mathrm{IR}-\mathrm{S}: & \max _{\tilde{c} \in \mathcal{C}} P(\tilde{c}, m) \geq 0
\end{array}</script><h3 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h3><p>目标需要找一个在满足约束的前提下最小化自己支出$J(m)$的机制$m$，约束包括：</p>
<ol>
<li>一轮选一个数据源；</li>
<li>更新频率不能超过数据源的上限；</li>
<li>激励相容约束</li>
<li>个体理性约束</li>
</ol>
<p>接下来证明了一类最优机制。</p>
<p><strong>定义2</strong>（等间距和统一费率机制）：一个机制$m=(\mathcal{P},\mathcal{X},\mathcal{S})$在满足以下条件时，我们称之为等间距和统一费率机制：</p>
<script type="math/tex; mode=display">
p_{i, k}(\cdot)=p_{i}(\cdot) \text { and } x_{k}(\cdot)=x(\cdot), \quad \forall k \in \mathbb{N}, i \in \mathcal{I}</script><p>其中，$p_{i}: \mathcal{C} \rightarrow \mathbb{R}_{+}$ ，$x: \mathcal{C} \rightarrow \mathbb{R}_{+}$。</p>
<p>意思就是对于数据源$i$，每一轮支付给它的钱都是一样的；而每一轮的更新频率也设置成一样的。</p>
<p><strong>定义3</strong>（<em>随机</em>固定调度）：一个调度策略$\mathcal{S}$在满足下述描述时，我们称之为固定调度：如果对于所有的数据源$i$，给定任意成本$c$，每个时间$k$的调度策略$s_{i,k}(c)$都是随机选择且在$k$上独立同分布，并且满足：</p>
<script type="math/tex; mode=display">
\operatorname{Pr}\left(s_{i, k}(\tilde{\boldsymbol{c}})=1\right)=\pi_{i}(\tilde{\boldsymbol{c}}), \quad \forall \tilde{\boldsymbol{c}} \in \mathcal{C}, k \in \mathbb{N}, i \in \mathcal{I}</script><p>其中，$\pi_{i}: \mathcal{C} \rightarrow[0,1]$ 满足 $\sum_{i \in \mathcal{T}} \pi_{i}(\tilde{\boldsymbol{c}})=1$</p>
<p>意思就是固定调度每一轮的调度策略与这一轮的时间$k$无关。</p>
<p>接下来说明最优机制的一些特性。</p>
<p><strong>引理1</strong>：</p>
<h2 id="Single-Source-Optimal-Mechanism-Design"><a href="#Single-Source-Optimal-Mechanism-Design" class="headerlink" title="Single-Source Optimal Mechanism Design"></a>Single-Source Optimal Mechanism Design</h2><h2 id="Multi-source-Optimal-Mechanism"><a href="#Multi-source-Optimal-Mechanism" class="headerlink" title="Multi-source Optimal Mechanism"></a>Multi-source Optimal Mechanism</h2><h2 id="Quantized-Optimal-Mechanism"><a href="#Quantized-Optimal-Mechanism" class="headerlink" title="Quantized Optimal Mechanism"></a>Quantized Optimal Mechanism</h2><h2 id="General-Virtual-Cost-Function"><a href="#General-Virtual-Cost-Function" class="headerlink" title="General Virtual Cost Function"></a>General Virtual Cost Function</h2><h2 id="Performance-Comparison"><a href="#Performance-Comparison" class="headerlink" title="Performance Comparison"></a>Performance Comparison</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>mechanism design</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-An Efficient Anonymous Authentication and Reputation Management Scheme for Mobile Crowdsensing in Vehicular Networks</title>
    <url>/2021/10/19/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-An%20Efficient%20Anonymous%20Authentication%20and%20Reputation%20Management%20Scheme%20for%20Mobile%20Crowdsensing%20in%20Vehicular%20Networks/</url>
    <content><![CDATA[<h1 id="车联网中的高效匿名认证与信誉管理框架"><a href="#车联网中的高效匿名认证与信誉管理框架" class="headerlink" title="车联网中的高效匿名认证与信誉管理框架"></a>车联网中的高效匿名认证与信誉管理框架</h1><p>这篇是投稿到<a href="mailto:onbehalfof@manuscriptcentral.com">IEEE Transactions on Vehicular Technology</a>的论文，现在要写审稿意见。</p>
<p>作者：三个暨南大学，一个澳门城市大学</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>车联网的众包系统中，匿名认证和信誉管理很重要，也面临很多问题。本文提出了一个既提高参与者相互认证效率，又实现传感车辆声誉管理的新方案。具体来说，匿名身份验证机制用于实现数据请求者、云服务器和传感车辆之间的相互认证，信誉评分更新方法将评分转化为模糊的信誉评级，以提高不可连接性（？）。传感数据使用Paillier算法保护。模拟实验中分析了隐私、计算和通信成本，表明效率优于现有方案。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>MCS（移动群智感知）越来越重要，车联网中的实时传感提升了传感结果精度；但是由于数据上传和匿名认证过程中的庞大、开放、稀疏、高度动态性的特点，车联网在面对攻击时是脆弱的；此外，多个传感器同时参与传感任务会增加计算和通信的负担。因此，如何获取高质量数据和实现高效匿名认证是亟待解决的问题。信誉评分系统可以用于构建可信车联网，但因为传感车辆的轨迹和驾驶模式可以通过接入信誉评分来推断，仅仅使用这个系统是不够的。信誉评分系统和匿名认证过程中面临的隐私问题直接影响传感车辆接入车联网的意愿和采集数据的精度。综上，本文提出了一个新方案，主要贡献如下：</p>
<ol>
<li>通过采用定期更新和模糊化方法，实现了假名和信誉评分的不可链接性。</li>
<li>提出了一种有效的匿名认证方法，根据该方法，可以减少计算和通信费用，提高身份验证效率。</li>
<li>通过分发诚实传感车辆的高信誉分数和恶意车辆的低声誉分数，实现了高效、实时的声誉管理。</li>
<li>对隐私和安全性进行了理论分析，模拟实验表明本文方法的计算和通信开销以及信誉更新算法的性能优于现有方案。</li>
</ol>
<h2 id="Related-Word"><a href="#Related-Word" class="headerlink" title="Related Word"></a>Related Word</h2><h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><h3 id="Bilinear-pairing（双线性配对）"><a href="#Bilinear-pairing（双线性配对）" class="headerlink" title="Bilinear pairing（双线性配对）"></a>Bilinear pairing（双线性配对）</h3><p>对称加密技术。$G_1$、$G_2$、$G_T$是三个素数$p$阶群乘法循环群，双线性配对是有这下列属性的$\hat{e}:G_1\times G_2 \rightarrow G_T$：</p>
<ol>
<li>双线性：对于所有$g\in G_1, h\in G_2, a,b \in Z_p,\hat{e}(g^a,h^b)=\hat{e}(g,h)^{ab}$</li>
<li>非退化性：对于所有$g\neq1_{G_1},h\neq1_{G_2},\hat{e}(g,h)\neq 1_{G_T}$</li>
<li>可计算性：$\hat{e}$是可计算的</li>
</ol>
<h3 id="Beta-distribution"><a href="#Beta-distribution" class="headerlink" title="Beta distribution"></a>Beta distribution</h3><p>Beta分布是定义在区间<code>(0,1)</code>的连续概率分布，两个参数分别是$\alpha$和$beta$。随机变量X服从Beta分布记作$X~Beta(\alpha,\beta)$，其概率密度函数$f(x|\alpha,\beta)$是Gamma函数的函数：</p>
<script type="math/tex; mode=display">
f(x|\alpha,\beta)=\frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}x^{\alpha-1}(1-x)^{\beta-1}</script><p>其中，</p>
<script type="math/tex; mode=display">
\Gamma(\alpha)=\int_0^\infty x^{\alpha-1}e^{-x}dx,0\leq x\leq 1,\alpha>0,\beta>0</script><p>Beta分布的数学期望$E(x)=\frac{\alpha}{\alpha+\beta}$。</p>
<h3 id="Paillier-algorithm"><a href="#Paillier-algorithm" class="headerlink" title="Paillier algorithm"></a>Paillier algorithm</h3><p>是同态加密算法，内容如下：</p>
<ol>
<li>初始化：选择两个大质数$p$和$q$，计算$n=p\cdot q$</li>
<li>密钥生成：计算$\delta = LCM(p-1,q-1)$，选择随机数$g_a\in Z_{n^2}^*$，计算非公开参数$\eta=(L(g_\alpha^\delta\ \ mod\ \ n^2))^{-1}mod\ \ n$，其中L是$L(x)=(x-1)/n$。公钥和私钥分别是$P_k=(n,g_a)$和$S_k=(\delta,\eta)$</li>
<li>加密：选择随机数$r\in Z_{n^2}^*$，对信息$m$使用公钥$P_k$加密，得到密文C：$C=g_a^m\cdot r_i^n\ \ mod\ \ n$</li>
<li>解密：使用密钥对密文C解密，得到信息m：$m=L(C^\delta\ \ mod\ \ n^2)\cdot \eta\ \ mod\ \ n$</li>
</ol>
<h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><h3 id="System-architecture"><a href="#System-architecture" class="headerlink" title="System architecture"></a>System architecture</h3><ol>
<li>可信认证（TA）：完全被信任，有强大算力，具体来说，TA 负责系统参数设置、实体注册以及车辆网络中的恶意 SV 跟踪和撤销。此外，TA 还分发和更新 SV 的信誉评分和身份证明。此外，它存储其他实体的注册信息，并保存其私钥，其公钥为 SV 所知。</li>
<li>数据请求者：分配传感任务</li>
<li>云服务器：有强大的存储空间和算力，收集和处理来自SV的密文，对SV的传感数据进行评分并反馈给TA</li>
<li>传感车辆（SV）：装备多种传感器、可互相通信的实体</li>
</ol>
<p>匿名认证和信誉管理系统步骤如下：</p>
<ol>
<li>实体注册：数据请求者、云服务器和SV在TA进行注册从而参与传感任务</li>
<li>任务分配：数据请求者在云服务器上分配传感任务，云服务器向SV广播</li>
<li>车辆选择：注册后，每个SV向云服务器发送认证信息，云服务器根据信誉评分和身份认证选择SV</li>
<li>数据收集：SV收集数据并加密发送到云服务器</li>
<li>数据处理：云服务器验证并聚合密文</li>
<li>结果提交：云服务器把聚合密文交给数据请求者</li>
<li>反馈报告：云服务器生成所有参与传感任务的SV的信誉反馈报告并发送给TA</li>
<li>更新评分和认证：TA更新SV的信誉评分和身份认证，并将其发送给相应的SV</li>
</ol>
<h3 id="Security-model"><a href="#Security-model" class="headerlink" title="Security model"></a>Security model</h3><p>TA完全被信任；数据请求者和云服务器诚实却对SV的隐私感到好奇；SV对其他SV的传感数据感到好奇，</p>
<p>信誉/假名攻击：当SV上传数据时，攻击者可能会链入信誉评分系统和假名进行攻击</p>
<p>中间人攻击：恶意SV会窃取认证信息欺骗云服务器并提供假数据</p>
<p>女巫攻击：恶意SV会建立多个实体从而传输多份假数据</p>
<p>替换攻击：恶意SV会用错误数据替换正确数据从而通过数据评估</p>
<h3 id="Design-goals"><a href="#Design-goals" class="headerlink" title="Design goals"></a>Design goals</h3><p>隐私目标：</p>
<ol>
<li>认证隐私：SV的真实身份不会暴露，假名不会被恶意攻击链接</li>
<li>数据隐私：传感数据受保护，除数据请求者以外的其他实体无法获取</li>
</ol>
<p>安全目标：防止前面提到的四种攻击</p>
<h2 id="The-Design-Of-Our-Scheme"><a href="#The-Design-Of-Our-Scheme" class="headerlink" title="The Design Of Our Scheme"></a>The Design Of Our Scheme</h2><h3 id="System-initialization"><a href="#System-initialization" class="headerlink" title="System initialization"></a>System initialization</h3><ol>
<li>TA初始化：TA首先运行系统生成算法<code>Gen(k)</code>生成系统参数$\{p,q,P_1,P_2,G_1,G_2,G_T,\hat{e}\}$​，该算法中的<code>k</code>是安全参数，$G_1,G_2,G_T$​是三个$p$​阶循环群，$\hat{e}$​是双线性映射，$P_1\in G_1,P_2\in G_2$​. 接下来TA计算$G=\hat{e}(P_1,P_2)$​，定义一个非对称加密算法<code>Ene()</code>和一个加密哈希函数$H(0,1)^<em>\rightarrow Z_n^</em>$​，其中$n=p\cdot q$​，此外，TA初始化密码对$(Sk_T,Pk_T)(Sk_T\in Z_n^*,Pk_T=Sk_T\cdot P_1)$​，并计算认证参数$A=\frac{1}{Sk_T}\cdot P_2$​. 最后，TA将$(p,q,Sk_T)$​作为隐私，公开$(n,P_1,P_2,G_1,G_2,G_T,\hat{e},Pk_T,H,Enc(),A)$​</li>
<li>云服务器注册：TA把密码对$(Sk_C,Pk_C)(Sk_C\in Z_n^*,Pk_C=Sk_C\cdot P_1)$​分配给云服务器</li>
<li>数据请求者注册：当一个新的数据请求者$D_i$​​注册时，TA分配给它一个独一无二的标识$Rid_{D_i}$​​​​​和两个密码对，其中一个是非对称加密，并基于此计算身份认证$Cert_{D_i}$​​，另一个是同态加密，由Paillier算法生成</li>
<li>传感车辆注册：当一个新的传感车辆$V_i$​注册时，TA分配给它一个独一无二的标识$Sid_{V_i}$​。然后TA选择随机数$r_i$​并用<code>Enc()</code>计算假名$Pid_{V_i}$​，同时，TA把密码对$(Sk_{V_i},Pk_{V_i})(Sk_{V_i}\in Z_n^*,Pk_{V_i}=Sk_{V_i}\cdot P_2)$​，并计算身份验认证$Cert_{V_i}$​</li>
</ol>
<p>车联网中有不同类型的车辆。我们可以根据不同的权力级别将其分为三类，分别表示为高级权力（HL）（例如执法车辆）、中级权力（如公共服务车辆）和低级权力（LL）（例如私人控制车辆）。针对这三种，TA对其初始化信誉评分$Rs_{V_i}^0$​时会有不同的值：高级是0.9，中级是0.5，低级是0.1。</p>
<p>精确的信誉评分会转化为信誉评级$Rl_{V_i}^0$，采用k匿名算法来避免信誉链接攻击，每个等级的SV数量至少是k个，具体的评级<sup><a href="#fn_1" id="reffn_1">1</a></sup>：</p>
<script type="math/tex; mode=display">
Rl_{V_i}^0=\left\{
\begin{aligned}
L_1=0,if\ \ 0<Rs_{V_i}^0<\frac{1}{n}\\
L_2=\frac{1}{n},if\ \ \frac{1}{n}<Rs_{V_i}^0<\frac{2}{n}\\
...\\
L_n=\frac{n-1}{n}, otherwise
\end{aligned}
\right.</script><p>最后，TA把$\{Sk_{V_i},Pk_{V_i},Cert_{V_i},Pid_{V_i},Rl_{V_i}^0\}$通过安全信道发给$V_i$。</p>
<h3 id="Sensing-task-assignment"><a href="#Sensing-task-assignment" class="headerlink" title="Sensing task assignment"></a>Sensing task assignment</h3><p>数据请求者$D_i$确定传感数据类型、任务序列号$Tid$、内容$m$、位置$L_m$、到期时间$T_m$和最小信誉等级要求$Rl$。</p>
<p>然后$D_i$​决定任务为$\{Tid,m,L_m,T_m,Rl\}$​并定义传感数据$d$​的标准值$d_0$​和错误值阈值$\Delta d$​。</p>
<p>最后，$D_i$把$m$​和同态加密公钥发送给云服务器。</p>
<p>云服务器验证$D_i$的身份公钥，如果没通过，则身份无效；如果通过，则云服务器向SV广播$\{Tid,T_m,T_{C_2},Rl\}$。</p>
<h3 id="Sensing-vehicle-selection"><a href="#Sensing-vehicle-selection" class="headerlink" title="Sensing vehicle selection"></a>Sensing vehicle selection</h3><p>收到任务的SV们如果想做任务，就发送自己的公钥、信誉评级、身份认证等给云服务器，云服务器经过一番验证，向通过验证的SV们发送$\{C_2,C_3,C_4,H(\vartheta_i)\}$，$H(\vartheta_i)$是用来标识该SV被选中了。</p>
<h3 id="Data-collection-and-processing"><a href="#Data-collection-and-processing" class="headerlink" title="Data collection and processing"></a>Data collection and processing</h3><p>收到传感任务内容的SV们对$\{C_2,C_3,C_4\}$进行解密，得到任务内容$m$，并完成任务得到传感数据$d_{V_i}$。为了实现数据隐私，每个SV对数据进行同态加密。</p>
<p>最后SV们把一系列参数上传云服务器。</p>
<p>云服务器首先检查参数中的时间参数，是否超过任务期限<sup><a href="#fn_2" id="reffn_2">2</a></sup>；其次检查$H(\vartheta_i)$​​是否存在；然后找任务对应的$D_i$获取标准值和错误值阈值，接着$D_i$就把经过一番加密的数据发送给云服务器。</p>
<p>由于传感数据、标准值、错误值阈值都是同态加密，所以云服务器直接对加密后的文本进行运算验证即可。云服务器将通过验证的传感数据聚合起来一起发给对应的$D_i$。</p>
<p>$D_i$用私钥解密得到聚合数据。</p>
<p>云服务器最后要根据传感数据计算信誉评分的反馈值，在错误值阈值范围内的就反馈1，否则反馈0.</p>
<blockquote id="fn_2">
<sup>2</sup>. 这里的问题是，如果时间参数是SV自己传的，那么如何保证是真实的而不是为了避免过期的假参数。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<h3 id="Reputation-and-certificate-updating"><a href="#Reputation-and-certificate-updating" class="headerlink" title="Reputation and certificate updating"></a>Reputation and certificate updating</h3><p> 对于每个车辆$V_i$，TA根据反馈的报告更新其信誉评分和身份认证。反馈报告用连续随机变量X表示信誉评分，并用beta分布评估信誉评分。传感任务成功完成和失败分别用$F_{V_i}=1$和$F_{V_i}=0$来表示。</p>
<p>具体来说，TA收集$\omega$份$V_i$的反馈报告，其中$\omega_i$次成功，$\omega_j$次失败，因此TA用beta分布表示$V_i$的任务表现，分布式中的$\alpha$和$\beta$分别表示成功和失败的次数。由此可知，$V_i$的评分X服从beta分布，期望是$\frac{\alpha}{\alpha+\beta}$，具体评分$Rs_{V_i}=\frac{\alpha}{\alpha+\beta}=\frac{\omega_i}{\omega}$。</p>
<p>为了提升信誉评分的准确率，我们引入了遗忘因子$F_f\in [0,1]$和平衡权重$B_\omega$来减少时间和反馈错误对信誉评分的影响。</p>
<p>因此，最终的评分公式如下<sup><a href="#fn_3" id="reffn_3">3</a></sup>：</p>
<script type="math/tex; mode=display">
Rs_{V_i}^\omega=\frac{F_f\omega_{i-1}+B_\omega s_i}{(F_f\omega_{i-1}+B_\omega s_i)+(F_f\omega_{j-1}+B_\omega u_i)}</script><p>其中，$B_\omega=\frac{s_i}{s_i+u_i}$</p>
<blockquote id="fn_3">
<sup>3</sup>. 这里的问题是，首先这个公式中的s_i和u_i需要解释，虽然前面表格中有了，但这里也应该再说一下。其次这个公式整个都需要解释，比如\omega_{i-1}是表达什么，前一个车辆的成功次数吗？为什么这个车辆的评分会和前一个车辆发生关系？此外，上面这段话中，在车辆V_i那里，字母i表示对第i个车，而到了s_i和u_i的时候，就表示第i次反馈报告，这样的符号很容易引起混淆。<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<p>更新评分以后，TA把评分存到本地数据库并转成评级数，然后更新身份认证，更新过程也是和前面差不多的加密算法。</p>
<h3 id="Sensing-vehicle-revocation"><a href="#Sensing-vehicle-revocation" class="headerlink" title="Sensing vehicle revocation"></a>Sensing vehicle revocation</h3><p>TA计算车辆$V_i$的失败率，如果这个车辆的评分低且失败率高，就不再更新这个车的评分，相当于不允许接入了。<sup><a href="#fn_4" id="reffn_4">4</a></sup></p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>这一部分是分析隐私和安全性问题，都是加密算法保障的，就不详细看了。</p>
<h2 id="Performance-evaluation"><a href="#Performance-evaluation" class="headerlink" title="Performance evaluation"></a>Performance evaluation</h2><p>分析了计算量和通信负担，评估了遗忘因子和平衡权重对评分更新算法的影响。</p>
<p>实验部分的问题有以下几点：</p>
<ol>
<li>没说实验环境和数据来源等；</li>
<li>实验中，参与者最多10个，这对于众包的场景不太合理；</li>
<li>实验展示了遗忘因子和平衡权重对评分的影响，但是没有说明原因，希望能补充解释这两个因素是如何影响评分的。</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ol>
<li>提出了有效的匿名认证机制</li>
<li>提出了新的信誉评分系统，基于beta分布</li>
<li>分析了隐私和安全问题，并进行了模拟实验</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.zhihu.com/question/39641890" target="_blank" rel="noopener">双线性配对</a></li>
</ol>
<h2 id="审稿意见"><a href="#审稿意见" class="headerlink" title="审稿意见"></a>审稿意见</h2><ol>
<li>公式4中的n需要解释</li>
<li>有一些符号表达并没在表1中列出，建议补充完整</li>
<li>加上前面文中的一些问题，总的来说大修吧+</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>审稿意见</tag>
        <tag>车联网</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode记录-3</title>
    <url>/2021/08/25/Leetcode%E8%AE%B0%E5%BD%95-2%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>从今天起，先跟着<a href="https://github.com/changgyhub/leetcode_101" target="_blank" rel="noopener">LeetCode 101</a>做题，首先是贪心算法。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode记录-2</title>
    <url>/2021/06/18/Leetcode%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">链接</a></p>
<p>给你两个<strong>非空</strong>的链表，表示两个非负的整数。它们每位数字都是按照<strong>逆序</strong>的方式存储的，并且每个节点只能存储<strong>一位</strong>数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><p>每个链表中的节点数在范围 <code>[1, 100]</code> 内</p>
</li>
<li><p><code>0 &lt;= Node.val &lt;= 9</code></p>
</li>
<li><p>题目数据保证列表表示的数字不含前导零</p>
</li>
</ol>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode* l3 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* p = l3;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l1val;</span><br><span class="line">            <span class="keyword">int</span> l2val;</span><br><span class="line">            <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l1val = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l1val = l1-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l2val = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l2val = l2-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = l1val+l2val;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">1</span>;</span><br><span class="line">                tmp = tmp%<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* q = <span class="keyword">new</span> ListNode(tmp);</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l3-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ol>
<li>要注意空指针，无论是取值还是往下一个节点移动都要判断是否是空指针；</li>
<li>这里的<code>if else</code>语句其实可以用三目运算符简写成一行；</li>
<li>这个题并不能把链表转数字加起来求和再转链表，因为输入的参数会超出数字长度；</li>
<li>链表本质上是指针+结构体的组合，现在我觉得我又会写链表了！</li>
</ol>
<h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode-solution/" target="_blank" rel="noopener">参考链接</a></p>
<ol>
<li><p>相同思路但写法简单一些</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode root = new ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cursor = root;</span><br><span class="line">        int carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != null || l2 != null || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            int l1Val = l1 != null ? l1.val : 0;</span><br><span class="line">            int l2Val = l2 != null ? l2.val : 0;</span><br><span class="line">            int sumVal = l1Val + l2Val + carry;</span><br><span class="line">            carry = sumVal / <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            ListNode sumNode = new ListNode(sumVal % <span class="number">10</span>);</span><br><span class="line">            cursor.next = sumNode;</span><br><span class="line">            cursor = sumNode;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l1 != null) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != null) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更短的写法，这个写法很巧妙</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode dummyHead = new ListNode(<span class="number">-1</span>), pre = dummyHead;</span><br><span class="line">        int t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != null || l2 != null || t != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 != null) &#123;</span><br><span class="line">                t += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != null) &#123;</span><br><span class="line">                t += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = new ListNode(t % <span class="number">10</span>);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Online Organizing Large-scale Heterogeneous Tasks and Multi-skilled Participants in Mobile Crowdsensing</title>
    <url>/2021/05/26/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Online%20Organizing%20Large-scale%20Heterogeneous%20Tasks%20and%20Multi-skilled%20Participants%20in%20Mobile%20Crowdsensing/</url>
    <content><![CDATA[<h1 id="Online-Organizing-Large-scale-Heterogeneous-Tasks-and-Multi-skilled-Participants-in-Mobile-Crowdsensing"><a href="#Online-Organizing-Large-scale-Heterogeneous-Tasks-and-Multi-skilled-Participants-in-Mobile-Crowdsensing" class="headerlink" title="Online Organizing Large-scale Heterogeneous Tasks and Multi-skilled Participants in Mobile Crowdsensing"></a>Online Organizing Large-scale Heterogeneous Tasks and Multi-skilled Participants in Mobile Crowdsensing</h1><p>是TMC的审稿。</p>
<a id="more"></a>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>目的：在线收集大规模异构任务和多技能参与者</p>
<p>方法：层次树和时间序列</p>
<p>内容：计算模式、树的创建方法和任务分配策略</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>场景：多技能参与者的在线众包平台上实时分配大规模异构任务</p>
<p>面临的问题：</p>
<ol>
<li>丰富的技能类型。技能类型太多，甚至需要一些领域的专业知识才能合理分类，平台应该如何处理。</li>
<li>不规则的任务时空要求。</li>
<li>多任务时空重叠。针对相同内容的任务，平台可以去除冗余；不同内容的任务，平台分给同一个workers可以减少其移动成本。</li>
<li>参与者和任务的动态性。任务和参与者随时到达或者离开平台。考虑参与者接了任务却没完成就离线的情况。任务一旦被分配了就不能被删除。</li>
<li>多技能参与者。</li>
<li>参与感知和机会感知。两种类型的参与者都应该能参与进来。</li>
<li>点推荐和轨迹推荐。两种任务推荐算法共存。</li>
</ol>
<p>现有文献主要在线多任务分配问题的不同方面提出了具体解决方案：</p>
<ol>
<li>针对即时任务分配问题，提出了基于贪婪的任务分配算法</li>
<li>针对时空异构任务分配，提出了分布式参与者选择框架</li>
<li>在任务动态异构的场景，考虑任务成本和能力等约束，选择能满足任务需求的最少数量的参与者</li>
<li>自组织移动众包框架，任务提供者可以主动、实时地向周围的移动参与者发布任务，从而快速获取高质量的传感数据。</li>
<li>两阶段任务分配框架，将机会感知和参与感知的优势结合起来。</li>
<li>多时空约束（包括任务位置、时间窗口、参与者轨迹等）的任务分配问题</li>
<li>不同预算的多任务，满足信息质量需求，考虑不同参与者的激励需求、传感能力和移动性。</li>
</ol>
<p>上述解决方案的问题：没能同时解决这些问题</p>
<p>存在这一问题的原因：数据结构过于简单</p>
<p>本文方案：</p>
<ol>
<li>原子化时间和空间——处理不规则时空问题，简化多任务时空重叠问题</li>
<li>将异构任务划分为原子任务，使用层次树进行组织——包括技能层、时间层、空间层和原子化任务层（叶节点），技能是需求驱动的，并不提前列出所有技能。技能层、时间层和空间层是可扩展、自适应的。</li>
<li>使用时间序列组织动态参与者，将空间、时间和技能约束等封装，根据时间限制加入队列，参与感知和机会感知都可以，点推荐和轨迹推荐共存。</li>
<li>综合上述，得到在线大规模异构任务分配算法。</li>
</ol>
<p>本文贡献：</p>
<ol>
<li>第一个研究这个的</li>
<li>两个数据结构结合</li>
<li>实验表明了有效性</li>
</ol>
<p>本文组织结构：略</p>
<h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>单任务场景：</p>
<p>多任务场景：</p>
<p>数据结构相关：</p>
<h2 id="3-Methodology"><a href="#3-Methodology" class="headerlink" title="3. Methodology"></a>3. Methodology</h2><p>平台架构：</p>
<ol>
<li>资源层：包括任务池和参与者池。任务发布者完善任务内容和技能类型。</li>
<li>数据结构和算法层：包括原子化任务、任务层次树、参与者时间序列队列和任务分配算法。首先，根据任务的技能、时间和空间对任务进行原子化处理；其次把原子化的任务根据技能时间和空间属性插入层次树中；同时封装所有参与者的属性并基于时间属性更新到时间序列队列中；最后根据时间序列队列和层次树进行匹配，输出结果。</li>
<li>输出层：任务成功执行，则返回传感数据；任务失败，如果没到ddl，就加入任务池变成新的任务；如果到了ddl，就删了并返回失败结果。</li>
</ol>
<h3 id="3-1-Atomized-tasks"><a href="#3-1-Atomized-tasks" class="headerlink" title="3.1 Atomized tasks"></a>3.1 Atomized tasks</h3><p>把任务按技能、空间、时间进行原子化处理，技能的原子化是按任务发布者所确定的技能数据库来做，空间和时间原子化是考虑具体场景，比如时间按一分钟划分、空间按一平米划分等。具体来说可以参考下图的任务划分。</p>
<p><img src="https://i.loli.net/2021/05/27/iaSz6o5dOTYZkVl.png" alt="image-20210527143503549"></p>
<h3 id="3-2-Task-hierarchy-tree"><a href="#3-2-Task-hierarchy-tree" class="headerlink" title="3.2 Task hierarchy tree"></a>3.2 Task hierarchy tree</h3><h4 id="3-2-1-Create-task-hierarchy-tree"><a href="#3-2-1-Create-task-hierarchy-tree" class="headerlink" title="3.2.1 Create task hierarchy tree"></a>3.2.1 Create task hierarchy tree</h4><p>任务的层次树有4层：技能层、时间层、空间层、原子任务层（叶节点）</p>
<p>技能层并不提前列好所有技能，而是需求驱动</p>
<p>前面那个图中原子任务们对应的层次树生成过程如下图所示：</p>
<p><img src="https://i.loli.net/2021/05/27/6suQJanpBrbPUxH.png" alt="image-20210527143832471"></p>
<p>具体来说，就是从根节点出发，在第一层找对应的技能节点，接着找对应的时间和空间节点，最后把这个任务放到对应的叶节点上。这中间如果没查到节点，就直接新建。</p>
<h4 id="3-2-2-Creation-methods-of-the-task-hierarchy-tree"><a href="#3-2-2-Creation-methods-of-the-task-hierarchy-tree" class="headerlink" title="3.2.2 Creation methods of the task hierarchy tree"></a>3.2.2 Creation methods of the task hierarchy tree</h4><p>层次树两种建立方式：空间优先和时间优先。具体来说如下图所示：</p>
<p><img src="https://i.loli.net/2021/05/27/kKPF9WLUujsOrSM.png" alt="image-20210527144407143"></p>
<h4 id="3-2-3-Computing-pattern-of-task-allocation"><a href="#3-2-3-Computing-pattern-of-task-allocation" class="headerlink" title="3.2.3 Computing pattern of task allocation"></a>3.2.3 Computing pattern of task allocation</h4><p>两种计算方式：串行和并行，串行效率低，并行要考虑任务分配的互斥锁。</p>
<p>通过多核处理器实现并行：按技能将分层树分成多个子树，这样多个参与者可以遍历不同的子树，实现并行计算。</p>
<p>具体来说，选参与者的时候会避免技能重复，比如选好第一参与者之后，第二个参与者若有相同的技能，就会跳过去看第三个参与者。这样最后选出来的参与者就都是技能不重复的，每人得到一颗子树及其原子任务们。</p>
<p>分给同一个参与者的多个子树要进行合并，即：把相同的时间和空间节点合并成一个节点。具体如下图：</p>
<p><img src="https://i.loli.net/2021/05/27/Fy4rhoamwisuq2P.png" alt="image-20210527150457291"></p>
<h3 id="3-3-Participant-time-series-queue"><a href="#3-3-Participant-time-series-queue" class="headerlink" title="3.3 Participant time-series queue"></a>3.3 Participant time-series queue</h3><p>参与者有7个属性：参与者ID、当前时间、当前位置、目的地、到达目的地的容忍时间、移动速度、技能向量。</p>
<p>根据当前时间将参与者依次加入到时间序列队列中。更新时间序列的过程如下图：</p>
<p><img src="https://i.loli.net/2021/06/01/vUGhYEMTJwiqNCr.png" alt="image-20210601103602834"></p>
<p>具体来说，就是根据<code>current time</code>把参与者排成队列，新来的插进去，分配好任务后把<code>current time</code>改成执行任务结束后的时间，无任务的节点从序列中删去。对于点推荐的任务，就把它分给任务要求时间与<code>current time</code>完全一致的参与者；而对于轨迹推荐的任务，就把它分给时间序列队列中的所有参与者，直到队列空了。</p>
<p>这个图和论文里的文字描述看起来没对应上，主要存在以下问题：</p>
<ol>
<li>对这个图的文字描述里写的是参与者$tf_6$和$tf_7$，而图里出现的是$tf_6$和$tf_5$，这肯定有一个错了；</li>
<li>文字描述里是先把$tf_6$的<code>current time</code>调到<code>10:08</code>，然后再因为$tf_1$没有任务而删除它，图里这俩过程反过来了；</li>
<li>图中第4行和第6行出现了$U_6$和$U_7$两个符号是什么含义，与其他参与者有什么区别？这需要在文字说明部分加以解释。</li>
</ol>
<h3 id="3-4-Task-allocation-algorithm"><a href="#3-4-Task-allocation-algorithm" class="headerlink" title="3.4 Task allocation algorithm"></a>3.4 Task allocation algorithm</h3><p>任务分配约束：</p>
<ol>
<li>参与者技能是否满足任务对技能的需求；</li>
<li>参与者是否能及时赶到任务执行地点；</li>
<li>执行任务是否会导致参与者无法准时到达自己的目的地；</li>
<li>任务地点是否会让参与者离自己的目的地越来越远。</li>
</ol>
<p>任务分配四步：技能匹配、时空匹配、分配策略、参与者更新。这四步如图所示：</p>
<p><img src="https://i.loli.net/2021/06/01/WQcLDaMinhOsIk9.png" alt="image-20210601104812332"></p>
<p>具体来说，首先判定一番，发现$l_4$会让参与者无法按时到目的地，所以排除；$l_1$会让参与者离目的地更远（从5变成5.4），所以排除；$l_2$和$l_3$都可，且此时这俩位置都只有1个任务，在短距离优先的情况下就分配$l_2$了。</p>
<p>任务树采用深度优先遍历的方式。</p>
<h3 id="3-5-Method-summary"><a href="#3-5-Method-summary" class="headerlink" title="3.5 Method summary"></a>3.5 Method summary</h3><p>这部分总结了一下，没啥能说的。</p>
<h2 id="4-Evaluation"><a href="#4-Evaluation" class="headerlink" title="4. Evaluation"></a>4. Evaluation</h2><h3 id="4-1-Data-set"><a href="#4-1-Data-set" class="headerlink" title="4.1 Data set"></a>4.1 Data set</h3><p>两个前提：</p>
<ol>
<li>参与者随时能离线，即便他接了任务没做（这种情况下平台进行任务再分配）；</li>
<li>任务仅能由发布者删除，任务一旦被分配则不能被删除。</li>
</ol>
<p>任务描述：<code>Task={task content, required skill, execution area, execution time period, upload time, deletion time}</code></p>
<p>参与者描述：<code>Participant={participant ID, current time, current location, destination, tolerable time to reach the destination, moving speed, skill vector, and offline time}</code></p>
<p>数据集：将<code>10KM*10KM</code>区域均匀划分为<code>100*100</code>的方格，将<code>60min</code>均匀分为<code>60</code>个时刻，即：时空最小单位是$0.01KM^2/min$</p>
<p>所有参与者和任务根据以下要求随机生成：</p>
<ol>
<li>任务执行区域是具有任何形状的连续区域，其大小不超过$1KM^2$;</li>
<li>任务执行时间是任意长度的连续时间段，长度不超过5分钟；</li>
<li>任务删除时间比任务刷新时间长；</li>
<li>参与者能容忍的到达目的地时间会根据从当前位置到目的地位置的最短时间而随机增加；</li>
<li>参与者最高移动速度不超过<code>1KM/min</code>，最低速度不低于<code>0.5KM/min</code>；（这个速度设置不太合理，没考虑不同交通工具等）</li>
<li>参与者至少1个技能，至多5个技能；</li>
<li>参与者离线时间比当前时间晚；</li>
<li>假设有3种参与者分布：均匀分布、高斯分布（均值50，标准差18）、Check-in分布。任务分布采用均匀分布。</li>
</ol>
<p>由此得到7组数据。（这里的check-in分布没查到，不知道是什么含义）</p>
<h3 id="4-2-Comparison-aspects-and-evaluation-indicators"><a href="#4-2-Comparison-aspects-and-evaluation-indicators" class="headerlink" title="4.2 Comparison aspects and evaluation indicators"></a>4.2 Comparison aspects and evaluation indicators</h3><p>比较3方面：</p>
<ol>
<li>计算模式：串行和并行</li>
<li>任务树建立方式：空间优先和时间优先</li>
<li>任务分配策略：无策略和短距离优先原则</li>
</ol>
<p>关注4个评价指标：</p>
<ol>
<li>算法执行时间</li>
<li>任务和参与者匹配率</li>
<li>参与者行动距离</li>
<li>冗余任务移除</li>
</ol>
<h3 id="4-3-Experiment-Results"><a href="#4-3-Experiment-Results" class="headerlink" title="4.3 Experiment Results"></a>4.3 Experiment Results</h3><p>比较了：</p>
<ol>
<li>不同任务数、参与者数、任务内容、技能类型条件下的效果</li>
<li>参与感知和机会感知、点推荐和轨迹推荐的效果</li>
<li>不同参与者分布下的效果</li>
</ol>
<p>实验图表数据就不列了，都是进行数据对比分析。</p>
<p>总结如下：</p>
<ol>
<li>并行计算能节省算法运行时间；</li>
<li>时间优先的层次树建立方法比空间优先的要更能增加任务和参与者的匹配率；</li>
<li>增加短距离优先原则能减少参与者的行动距离；</li>
<li>任务内容重复率越高，冗余任务去除越多（这不是废话吗）。</li>
</ol>
<h3 id="4-4-Analysis-and-Discussion"><a href="#4-4-Analysis-and-Discussion" class="headerlink" title="4.4 Analysis and Discussion"></a>4.4 Analysis and Discussion</h3><p>前面所说的1和3都很显然，这里分析2的原因。</p>
<p>时间优先的层次树在时间节点那一层是单调增排序的，也就是说时间较早的会先被检索到进而匹配，这样参与者在匹配完该任务后还能继续匹配时间更晚一些的任务；而在空间优先的层次树中，参与者可能会先被匹配到时间较晚的任务，接着其<code>current time</code>就被刷新到更晚，从而无法匹配时间较早的任务了。</p>
<h2 id="5-Conclusion-and-future-work"><a href="#5-Conclusion-and-future-work" class="headerlink" title="5. Conclusion and future work"></a>5. Conclusion and future work</h2><p>在线收集大规模异构任务和多技能参与者可以使任务和参与者实时共享。然而，这将使任务分配非常困难。我们总结了在线收集对任务分配平台的七个要求。它们包括丰富的技能类型、任务的不规则时空要求、多任务的时空重叠、任务和参与者的动力学、多技能参与者、参与式感知和机会主义感知、点推荐和轨迹推荐。为了满足这七个要求，我们设计了一种基于层次树的任务组织方法和一种基于时间序列队列的参与组织方法。基于任务层次树和参与时间序列队列，从计算模式、树生成方法和任务分配策略三个方面研究了任务分配问题。在计算模式上，我们比较了串行计算和并行计算。在树的创建方法中，我们首先比较空间和时间。在任务分配策略中，我们增加了短距离优先原则。最后，对算法运行时间、任务参与者匹配率、参与者行程距离和去除冗余任务四个指标进行了详细的实验评价。实验结果表明，基于任务层次树和参与时间序列队列的任务分配算法能够有效地满足这七个要求。在实验环境中，与串行计算相比，并行计算可以平均减少算法运行时间66.00% 以上。与空间优先相比，时间优先平均可使任务参与者匹配率提高13.00% 以上。增加短距离优先原则可以平均减少参与者出行距离4.00%  以上。</p>
<p>今后还有许多问题需要解决。首先，在进行时空匹配时，我们假设参与者的旅行时间可以被精确估计。然而，即使使用最好的商业地图，也不能准确地估计旅行时间。在这种情况下，如何实现任务分配？我们的想法是，我们可以返回任务的一个周期时间和一个区域，而不是一个时空点。其次，当前树的划分仅根据技能层进行。是否有可能在时间和空间层进一步划分树？我们认为这是可行的。在计算资源充足的情况下，应进一步减少算法运行时间，但效果可能不明显。因为在技能层分割后，树的尺寸并不大。第三，任务不仅具有技能、时间、空间三个属性，而且还具有主题属性，这三个属性对应着参与者的偏好。任务层次树是否可以添加主题属性并考虑参与者的首选项？我们认为这是可行的。在添加了主题属性之后，树的层数从4层改为5层。此外，考虑参与者的偏好会导致任务与参与者之间的概率匹配问题。任务分配问题的复杂性将进一步增加。</p>
<h2 id="审稿意见部分"><a href="#审稿意见部分" class="headerlink" title="审稿意见部分"></a>审稿意见部分</h2><p>本文认为当前针对在线多任务分配问题的诸多解决方案无法同时解决不同的问题，其原因在于它们采用的数据结构过于简单，针对这一点本文提出了基于层次树的任务组织模式和基于时间序列队列的参与者组织模式，并在此基础上设计了任务分配算法。针对不同的计算模式、任务树建立方式和任务分配策略，本文采用随机生成的数据集进行了仿真实验分析，根据算法运行时间、任务参与者匹配率、参与者行程距离和去除冗余任务这四个指标对算法性能进行评估，从而得出结论：并行计算能够减少算法运行时间；时间优先的层次树能提高任务和参与者的匹配率；增加短距离优先原则可以减少参与者出行距离。</p>
<p>strength:</p>
<ol>
<li>作者清晰地阐述了本文的主要思想，完成了研究工作，包括详细的性能分析；</li>
<li>本文从数据结构的角度入手分析在线多任务分配问题，并提出了基于层次树和时间序列队列的任务分配算法，有一定创新性；</li>
<li>本文对算法思想的描述十分详细，图表清晰地解释了算法过程和实验数据，有利于读者阅读论文；</li>
<li>本文考虑了点推荐和轨迹推荐的任务分配模式以及参与感知和机会感知的参与者行为模式，更贴近真实场景。</li>
</ol>
<p>weakness:</p>
<ol>
<li>图10中存在下列问题：<ol>
<li>对这个图的文字描述里写的是参与者$tf_6$和$tf_7$，而图里出现的是$tf_6$和$tf_5$，这两处表达需要统一；</li>
<li>文字描述里是先把$tf_6$的<code>current time</code>调到<code>10:08</code>，然后再因为$tf_1$没有任务而删除它，图里这俩过程反过来了；</li>
<li>图中第4行和第6行出现了$U_6$和$U_7$两个符号是什么含义，与其他参与者有什么区别？这需要在文字说明部分加以解释。</li>
</ol>
</li>
<li>实验部分中提到的check-in分布是否可以增加具体的介绍？</li>
<li>本文实验部分假设参与者最高移动速度不超过<code>1KM/min</code>，最低速度不低于<code>0.5KM/min</code>，这个速度设置主要是汽车的速度范围，没有考虑其他交通方式如步行、骑行等，如果可以放宽速度限制范围，会更合理一些；</li>
<li>本文实验部分如果可以增加与现有算法的性能简要对比，会更有说服力。</li>
</ol>
<p>英文版本：</p>
<p>This paper argues that many current solutions to online multi-task  assignment problems can not solve different problems at the same time.  And the reason is that the data structures they used are too simple to solve these problems. This paper proposes a task organization model based  on hierarchical tree and a participant organization model based on time series queue, and designs a task allocation algorithm. According to  different computing patterns, tree creation methods and task allocation strategy, this paper uses randomly generated data set to carry out  simulation experiment analysis. The performance of the algorithm is evaluated according to four indexes: algorithm running time, task participant matching rate, participant travel distance and redundant tasks removed.  It is concluded that  parallel computing can reduce the running time of the algorithm;  time-first hierarchical tree can improve the matching rate of tasks and  participants, and short-distance-first principle can reduce the travel  distance of participants.</p>
<p>strength:</p>
<ol>
<li>The main idea of this paper is described clearly and the research work is complete, containing detailed performance analysis.</li>
<li>This paper analyzes the problem of online multi-task assignment from the perspective of data structure, and proposes a task assignment algorithm based on hierarchical tree and time series queue, which is innovative to some extent.</li>
<li>In this paper, the algorithm idea is described in detail, and the figures clearly explain the algorithm process and experimental data, which are very helpful for readers to understand this paper.</li>
<li>This paper considers different participant distributions, different sensing methods(i.e. participatory sensing and opportunistic sensing), and different recommendation methods(i.e. point recommendation and trajectory recommendation), which is closer to the real scene.</li>
</ol>
<p>weakness:</p>
<ol>
<li>In Fig. 10,  participants tf_6 and ​tf_7 are written in the corresponding text description(Page 8, line 54, right column), while ​tf_6 and tf_5 appear in the figure. These two  expressions need to be unified.</li>
<li>In the text  description, change the current time of tf_6 to 10:08 first, then delete tf_1  from time-series queue. But the two processes are reversed in Fig.10. Picture content and text description should be unified.</li>
<li>What do the u_6 and u_7  in Fig. 10 mean and how are they different from the other participants? This needs to be explained in the paper.</li>
<li>What is the specific form of the check-in distribution mentioned in Section 4?</li>
<li>The experimental part of this paper assumes that “The maximum moving speed of participants does not exceed 1KM/min, and the minimum moving speed is not lower than 0.5KM/min.” This speed limit is  mainly the speed range of cars, did not consider other modes of  transport such as walking, cycling. If the speed limit can be relaxed,  it will be more reasonable.</li>
<li>The evaluation part will be more convincing if it can be compared with the performance of existing algorithms.</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>审稿意见</tag>
      </tags>
  </entry>
  <entry>
    <title>Github项目数据统计</title>
    <url>/2021/04/30/Github%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="Github项目数据统计"><a href="#Github项目数据统计" class="headerlink" title="Github项目数据统计"></a>Github项目数据统计</h1><p>​      由于需要统计Dapp项目的发展历程数据，在查资料时看到了<a href="https://zhuanlan.zhihu.com/p/32759663" target="_blank" rel="noopener">以太坊 Dapp 调研</a>，这份统计只包含了2017年12月20日及之前的数据，而现在已经是2021年了，因此我模仿这个进行了新的统计。</p>
<a id="more"></a>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>经过一系列学习，我终于掌握了GitHub api的基础使用。简单来说，我们可以通过访问api接口进行查询并获取数据。通过关键字dapp进行查询的api是<code>https://api.github.com/search/repositories?q=dapp</code>，用浏览器直接打开这个链接可以看到如下图的内容：</p>
<p><img src="https://i.loli.net/2021/04/30/nXQsavbDH98PJxc.png" alt="image-20210430103142883"></p>
<p>第一行的<code>total_count</code>是所有结果的总数，接下来有30个<code>items</code>，每一个都是对应的项目，点开第一个可以看到其数据格式为：</p>
<p><img src="https://i.loli.net/2021/04/30/qNL3xuYcrlByVbW.png" alt="image-20210430103308097"></p>
<p>图中显示的内容并不完整，还有很多信息比如stars数量等都可以直接获取。</p>
<p>但是总共有19930个项目，却只获取到30个，这显然是不够的，想获取更多项目就需要修改api的内容，改成<code>https://api.github.com/search/repositories?q=dapp&amp;page=1&amp;per_page=100</code>，修改后就可以获取到100条项目信息了，这是每页项目数的上限，将api中的<code>page=1</code>改成<code>page=2</code>即可得到新的100条信息，然而由于api限制，通过这样的方法最多可以获取1000条（即<code>page=10</code>），超过1000条后会有报错信息。为了能获取到更多项目，我们需要对访问查询作出限制，使得每次查询结果都不超过1000条，然后将多次查询结果合并起来得到完整结果，例如仅查找创建于2021年1月至2月的项目数，这样就可以得到1000条以内的结果，再逐页访问即可。限制时间的api为：<code>https://api.github.com/search/repositories?q=dapp+created:2021-04-01T00:00:00..2021-05-01&amp;page=1&amp;per_page=100</code>，这个api可以获取创建时间在2021年4月1日至5月1日的所有项目数据，如果要获取其他时间范围，对api中的时间进行修改即可，可以精确到秒；如果时间限制是早于或晚于某个时间点，则写成<code>created:&gt;=2021-04-01T00:00:00</code>，大于等于符号可以改成小于等于或者大于或者小于。如果想限制其他字段，比如更新时间，则把created修改为updated即可。</p>
<p>具体到写python代码时，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> github3 <span class="keyword">import</span> login, GitHub</span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    result = requests.get(<span class="string">"https://api.github.com/search/repositories?q=dapp+created:2021-04-01T00:00:00..2021-05-01&amp;page=6&amp;per_page=100"</span>)</span><br><span class="line">    response_dict = result.json()</span><br><span class="line">    repo_dicts = response_dict[<span class="string">'items'</span>]</span><br><span class="line">    print(<span class="string">"Toal repositories:"</span>, response_dict[<span class="string">'total_count'</span>])</span><br><span class="line">    print(<span class="string">"Repositories returned:"</span>, len(repo_dicts))</span><br><span class="line">    keys = &#123;<span class="string">'id'</span>,<span class="string">'full_name'</span>,<span class="string">'html_url'</span>,<span class="string">'commits_url'</span>,<span class="string">'language'</span>,<span class="string">'description'</span>,<span class="string">'forks_count'</span>,<span class="string">'stargazers_count'</span>,<span class="string">'watchers_count'</span>,<span class="string">'created_at'</span>,<span class="string">'pushed_at'</span>,<span class="string">'updated_at'</span>&#125;</span><br><span class="line">    save_dicts = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> repo_dicts:</span><br><span class="line">        j = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> i.items() <span class="keyword">if</span> key <span class="keyword">in</span> keys&#125;</span><br><span class="line">        save_dicts.append(j)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'test.csv'</span>, <span class="string">'a+'</span>, newline=<span class="string">''</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f: </span><br><span class="line">        fieldnames = [<span class="string">'id'</span>,<span class="string">'full_name'</span>,<span class="string">'html_url'</span>,<span class="string">'commits_url'</span>,<span class="string">'language'</span>,<span class="string">'description'</span>,<span class="string">'forks_count'</span>,<span class="string">'stargazers_count'</span>,<span class="string">'watchers_count'</span>,<span class="string">'created_at'</span>,<span class="string">'pushed_at'</span>,<span class="string">'updated_at'</span>]</span><br><span class="line">        writer = csv.DictWriter(f,fieldnames=fieldnames)</span><br><span class="line">        <span class="comment">#writer.writeheader()</span></span><br><span class="line">        writer.writerows(save_dicts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<!--这段代码`import`的一些包其实没有用到，是最初学着写的时候都引入了，之后没删。-->
<p>代码第9行使用<code>requests.get()</code>获取api的数据，接着使用<code>.json()</code>将它转为字典。这个字典的<code>total_count</code>项就是前面图中显示的项目总数，这里我们没有用到；字典的<code>items</code>项则是我们需要的项目列表，将它单独存到<code>repo_dicts</code>，显然获取的项目列表数并不等于项目总数。</p>
<p>接下来把这次数据处理所需要的字段写到<code>keys</code>中，从<code>repo_dicts</code>中提取这些列的内容存到新列表<code>save_dicts</code>中，再将这些数据保存到csv文件里。这个提取数据并保存的过程应该有更简练的代码写法，我懒得改了就这样吧。</p>
<p>最终得到的csv文件如下图所示：</p>
<p><img src="https://i.loli.net/2021/04/30/YIcsFzMrN1Cb93l.png" alt="image-20210430105338111"></p>
<p>这个数据总量比api那里的总量要多一些，显然是有重复的，因此要进行去重，我们选择把相同id的条目删了，只保留一个。excel本身就有去重的功能，在python里用pandas也可以，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    frame=pd.read_csv(<span class="string">'test.csv'</span>,engine=<span class="string">'python'</span>)</span><br><span class="line">    data = frame.drop_duplicates(subset=[<span class="string">'id'</span>], keep=<span class="string">'first'</span>, inplace=<span class="literal">False</span>)</span><br><span class="line">    data.to_csv(<span class="string">'newtest.csv'</span>, encoding=<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这样就得到了一份到目前为止所有和dapp相关的项目表。</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>接下来要对所有数据进行分析统计。我们要做的图表如下：</p>
<ol>
<li>每月新Dapp项目数量分布</li>
<li>项目创建及更新时间分布</li>
<li>项目语言分布</li>
</ol>
<p>第3个最简单，我们先看它。</p>
<h3 id="项目语言分布"><a href="#项目语言分布" class="headerlink" title="项目语言分布"></a>项目语言分布</h3><p>从csv文件读入数据后，按<code>language</code>列进行数量统计即可，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import csv</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">pd.set_option(&#39;display.max_rows&#39;,None)</span><br><span class="line">pd.set_option(&#39;display.max_columns&#39;, None)</span><br><span class="line">pd.set_option(&#39;display.width&#39;, 1000)</span><br><span class="line">pd.set_option(&#39;display.max_colwidth&#39;, 1000)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    frame&#x3D;pd.read_csv(&#39;newtest.csv&#39;,engine&#x3D;&#39;python&#39;)</span><br><span class="line">    df1 &#x3D; frame.language.value_counts()</span><br><span class="line">    print(df1)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">JavaScript           <span class="number">10018</span></span><br><span class="line">C<span class="comment">#                    2087</span></span><br><span class="line">HTML                  <span class="number">1019</span></span><br><span class="line">TypeScript             <span class="number">806</span></span><br><span class="line">CSS                    <span class="number">376</span></span><br><span class="line">Solidity               <span class="number">336</span></span><br><span class="line">Vue                    <span class="number">335</span></span><br><span class="line">Java                   <span class="number">295</span></span><br><span class="line">Python                 <span class="number">256</span></span><br><span class="line">Shell                  <span class="number">139</span></span><br><span class="line">Go                     <span class="number">133</span></span><br><span class="line">C++                    <span class="number">120</span></span><br><span class="line">Dockerfile              <span class="number">72</span></span><br><span class="line">PHP                     <span class="number">65</span></span><br><span class="line">Kotlin                  <span class="number">54</span></span><br><span class="line">Ruby                    <span class="number">52</span></span><br><span class="line">Swift                   <span class="number">49</span></span><br><span class="line">Dart                    <span class="number">37</span></span><br><span class="line">Rust                    <span class="number">34</span></span><br><span class="line">Objective-C             <span class="number">30</span></span><br><span class="line">Jupyter Notebook        <span class="number">30</span></span><br><span class="line">C                       <span class="number">25</span></span><br><span class="line">Makefile                <span class="number">24</span></span><br><span class="line">WebAssembly             <span class="number">22</span></span><br><span class="line">TSQL                    <span class="number">19</span></span><br><span class="line">SCSS                    <span class="number">17</span></span><br><span class="line">PowerShell              <span class="number">10</span></span><br><span class="line">F<span class="comment">#                      10</span></span><br><span class="line">TeX                      <span class="number">9</span></span><br><span class="line">Perl                     <span class="number">8</span></span><br><span class="line">Clojure                  <span class="number">8</span></span><br><span class="line">Haskell                  <span class="number">7</span></span><br><span class="line">R                        <span class="number">7</span></span><br><span class="line">Svelte                   <span class="number">6</span></span><br><span class="line">CoffeeScript             <span class="number">6</span></span><br><span class="line">Scala                    <span class="number">6</span></span><br><span class="line">Nix                      <span class="number">5</span></span><br><span class="line">Visual Basic             <span class="number">5</span></span><br><span class="line">Visual Basic .NET        <span class="number">5</span></span><br><span class="line">D                        <span class="number">4</span></span><br><span class="line">Elm                      <span class="number">4</span></span><br><span class="line">Smarty                   <span class="number">3</span></span><br><span class="line">Elixir                   <span class="number">3</span></span><br><span class="line">GLSL                     <span class="number">3</span></span><br><span class="line">ASP                      <span class="number">3</span></span><br><span class="line">HCL                      <span class="number">3</span></span><br><span class="line">PLpgSQL                  <span class="number">2</span></span><br><span class="line">ShaderLab                <span class="number">2</span></span><br><span class="line">OCaml                    <span class="number">2</span></span><br><span class="line">Logos                    <span class="number">2</span></span><br><span class="line">Blade                    <span class="number">2</span></span><br><span class="line">Roff                     <span class="number">2</span></span><br><span class="line">LiveScript               <span class="number">2</span></span><br><span class="line">Hack                     <span class="number">2</span></span><br><span class="line">PLSQL                    <span class="number">2</span></span><br><span class="line">Sass                     <span class="number">1</span></span><br><span class="line">ECL                      <span class="number">1</span></span><br><span class="line">GDScript                 <span class="number">1</span></span><br><span class="line">NSIS                     <span class="number">1</span></span><br><span class="line">Stata                    <span class="number">1</span></span><br><span class="line">CMake                    <span class="number">1</span></span><br><span class="line">MATLAB                   <span class="number">1</span></span><br><span class="line">EJS                      <span class="number">1</span></span><br><span class="line">Twig                     <span class="number">1</span></span><br><span class="line">QML                      <span class="number">1</span></span><br><span class="line">XML                      <span class="number">1</span></span><br><span class="line">Batchfile                <span class="number">1</span></span><br><span class="line">Crystal                  <span class="number">1</span></span><br><span class="line">Apex                     <span class="number">1</span></span><br><span class="line">Emacs Lisp               <span class="number">1</span></span><br><span class="line">Lua                      <span class="number">1</span></span><br><span class="line">Racket                   <span class="number">1</span></span><br><span class="line">VimL                     <span class="number">1</span></span><br><span class="line">Handlebars               <span class="number">1</span></span><br><span class="line"><span class="number">4</span>D                       <span class="number">1</span></span><br><span class="line">PureScript               <span class="number">1</span></span><br><span class="line">Pascal                   <span class="number">1</span></span><br><span class="line">Io                       <span class="number">1</span></span><br><span class="line">Assembly                 <span class="number">1</span></span><br><span class="line">Name: language, dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="每月新增Dapp项目数量分布"><a href="#每月新增Dapp项目数量分布" class="headerlink" title="每月新增Dapp项目数量分布"></a>每月新增Dapp项目数量分布</h3><p>从csv文件读入数据后，访问<code>created_at</code>这一列并截取其前7位，即可得到每个项目的创建年月，统计每个月创建的项目数量即可得到数据结果，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">'display.max_rows'</span>,<span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.width'</span>, <span class="number">1000</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_colwidth'</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    frame=pd.read_csv(<span class="string">'newtest.csv'</span>,engine=<span class="string">'python'</span>)</span><br><span class="line">    frame[<span class="string">'created'</span>] = frame[<span class="string">'created_at'</span>].str[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">    df1 = frame.created.value_counts()</span><br><span class="line">    print(df1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这份数据内容很多，因此就不列出了。</p>
<h3 id="项目创建及更新时间分布"><a href="#项目创建及更新时间分布" class="headerlink" title="项目创建及更新时间分布"></a>项目创建及更新时间分布</h3><p>由于数据很多，因此这里并不逐月统计，对于创建时间，统计每半年的项目数；对于更新时间，统计每一年的项目数，例如创建于2009年10月至2010年4月且最后一次更新于2014年4月至2015年4月的项目有1个，则这一对时间所对应的值就是1。以此类推，可以得到一份完整表格。</p>
<p>我们首先读入csv文件，截取创建和更新的年月数据，并依次分组并统计每组的项目数，这样就可以得到每组年月对所对应的项目数，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">'display.max_rows'</span>,<span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.width'</span>, <span class="number">1000</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_colwidth'</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    frame=pd.read_csv(<span class="string">'newtest.csv'</span>,engine=<span class="string">'python'</span>)</span><br><span class="line">    frame[<span class="string">'created'</span>] = frame[<span class="string">'created_at'</span>].str[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">    frame[<span class="string">'updated'</span>] = frame[<span class="string">'updated_at'</span>].str[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">    group = frame.groupby([<span class="string">'created'</span>,<span class="string">'updated'</span>])</span><br><span class="line">    dict_tmp = dict(group.size())</span><br><span class="line">    print(dict_tmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>得到的结果是<code>... (&#39;2021-03&#39;, &#39;2021-03&#39;): 473, (&#39;2021-03&#39;, &#39;2021-04&#39;): 151,...</code>这样的格式，将这些放到excel里并进行分列、去除无效数据等处理，最终可以得到如下图所示的表格：</p>
<p><img src="https://i.loli.net/2021/04/30/tS9wECnmoiONprB.png" alt="image-20210430122233349"></p>
<p>接下来筛选出created列中2014-11~2015-04之间的数据，将筛选后的updated和num这两列复制到新区域（比如sheet4），按升序排列，如下图，选中2015-04之前的数据，就可以在右下角看到这个时间段内的项目数总和。</p>
<p><img src="https://i.loli.net/2021/04/30/Eq83h4BrRxLd5z6.png" alt="image-20210430122713555"></p>
<p>用类似的方法进行多次筛选、排序、求和，最终可以得到如下数据表：</p>
<p><img src="https://i.loli.net/2021/04/30/1Qok6Z9U2r5RtvO.png" alt="image-20210430124738534"></p>
<p>行表示创建时间，列表示更新时间。</p>
<h2 id="图像生成"><a href="#图像生成" class="headerlink" title="图像生成"></a>图像生成</h2><p>使用<code>Echarts</code>生成图表，因为没学过前端，所以就直接用了<a href="https://zhuanlan.zhihu.com/p/32759663" target="_blank" rel="noopener">以太坊 Dapp 调研</a>给出的js代码，链接为 <a href="https://github.com/heeeeeng/my_docs/tree/master/ethereum_dapp/data_viewer" target="_blank" rel="noopener">Github</a> 。</p>
<p>所有数据是直接在<code>web.js</code>中写好的，并不是从其他文件读取，且文件开头的<code>var scatter_origin_data</code>其实可以删了。此外，这份文件中的个人和组织项目散点图我并不需要，因此也直接删了。</p>
<p>接下来将<code>web.js</code>中的数据修改成前面统计好的数据，打开<code>web.html</code>就可以看到图表了。</p>
<p>由于hexo博客也可以显示echarts，因此我就把图表放这里了。</p>
<div id="echarts3693" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts3693'));
        // 指定图表的配置项和数据
        var option = {
title: {
            text: '每月新Dapp项目数量分布',
            x:'center'
        },
        tooltip: {
            trigger: 'axis'
        },
        toolbox: {
            show: true,
            feature: {
                dataZoom: {
                    yAxisIndex: 'none'
                },
                dataView: {readOnly: false},
                magicType: {type: ['line', 'bar']},
                restore: {},
                saveAsImage: {}
            }
        },
        xAxis:  {
            name: "创建时间",
            type: 'category',
            boundaryGap: false,
            data: ["2009-01","2009-02","2009-03","2009-04","2009-05","2009-06","2009-07","2009-08","2009-09","2009-10","2009-11","2009-12","2010-01","2010-02","2010-03","2010-04","2010-05","2010-06","2010-07","2010-08","2010-09","2010-10","2010-11","2010-12","2011-01","2011-02","2011-03","2011-04","2011-05","2011-06","2011-07","2011-08","2011-09","2011-10","2011-11","2011-12","2012-01","2012-02","2012-03","2012-04","2012-05","2012-06","2012-07","2012-08","2012-09","2012-10","2012-11","2012-12","2013-01","2013-02","2013-03","2013-04","2013-05","2013-06","2013-07","2013-08","2013-09","2013-10","2013-11","2013-12","2014-01","2014-02","2014-03","2014-04","2014-05","2014-06","2014-07","2014-08","2014-09","2014-10","2014-11","2014-12","2015-01","2015-02","2015-03","2015-04","2015-05","2015-06","2015-07","2015-08","2015-09","2015-10","2015-11","2015-12","2016-01","2016-02","2016-03","2016-04","2016-05","2016-06","2016-07","2016-08","2016-09","2016-10","2016-11","2016-12","2017-01","2017-02","2017-03","2017-04","2017-05","2017-06","2017-07","2017-08","2017-09","2017-10","2017-11","2017-12","2018-01","2018-02","2018-03","2018-04","2018-05","2018-06","2018-07","2018-08","2018-09","2018-10","2018-11","2018-12","2019-01","2019-02","2019-03","2019-04","2019-05","2019-06","2019-07","2019-08","2019-09","2019-10","2019-11","2019-12","2020-01","2020-02","2020-03","2020-04","2020-05","2020-06","2020-07","2020-08","2020-09","2020-10","2020-11","2020-12","2021-01","2021-02","2021-03","2021-04"]
        },
        yAxis: {
            name: '新项目数量',
            type: 'value',
            axisLabel: {
                formatter: '{value}'
            }
        },
        series: [
            {
                name:'新项目数量',
                type:'line',
                data: [1,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,2,0,1,2,1,3,2,1,2,2,2,0,1,5,2,3,5,2,1,1,5,4,4,3,3,8,8,8,5,7,5,8,11,16,9,9,5,6,6,12,19,5,12,16,10,14,21,29,29,26,18,29,34,34,32,34,52,42,49,63,56,50,58,66,64,66,60,41,37,69,60,75,109,128,118,148,203,193,217,223,229,339,353,455,425,625,506,526,596,488,490,432,456,441,341,433,391,385,387,383,379,278,303,313,288,320,288,291,407,479,348,381,316,339,411,448,392,492,456,633,581],
                markPoint: {
                    data: [
                        {type: 'max', name: '最大值'}
                    ]
                },
                markLine: {
                    data: [
                        {type: 'average', name: '平均值'}
                    ]
                }
            }
        ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<div id="echarts4541" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts4541'));
        // 指定图表的配置项和数据
        var option = {
        title : {
            text: '项目语言分布',
            x:'center'
        },
        tooltip : {
            trigger: 'item',
            formatter: "{b} <br/> 项目数量: {c} ({d}%) "
        },
        legend: {
            orient: 'vertical',
            left: 'left',
            data: ['JavaScript','HTML', 'TypeScript', 'CSS', 'Others']
        },
        series : [
            {
                name: '项目语言分布',
                type: 'pie',
                radius : '55%',
                center: ['50%', '60%'],
                data:[
                    {value:10018, name:'JavaScript'},
                    {value:2087, name:'C#'},
                    {value:1019,name:"HTML"},
                    {value:806,name:"TypeScript"},
                    {value:376,name:"CSS"},
                    {value:336,name:"Solidity"},
                    {value:335,name:"Vue"},
                    {value:295,name:"Java"},
                    {value:256,name:"Python"},
                    {value:139,name:"Shell"},
                    {value:133,name:"Go"},
                    {value:120,name:"C++"},
                    {value:687, name:'Others'}
                ],
                itemStyle: {
                    emphasis: {
                        shadowBlur: 10,
                        shadowOffsetX: 0,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }
        ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<div id="echarts4010" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts4010'));
        // 指定图表的配置项和数据
        var option = {
        title : {
            text: '剩余语言分布',
            x:'center'
        },
        tooltip : {
            trigger: 'item',
            formatter: "{b} <br/> 项目数量: {c} ({d}%) "
        },
        series : [
            {
                name: '编程语言数量分布',
                type: 'pie',
                radius : '55%',
                center: ['50%', '60%'],
                data:[                    
                    {value:72,name:"Dockerfile"},
                    {value:65,name:"PHP"},
                    {value:54,name:"Kotlin"},
                    {value:52,name:"Ruby"},
                    {value:49,name:"Swift"},
                    {value:37,name:"Dart"},
                    {value:34,name:"Rust"},
                    {value:30,name:"Jupyter Notebook"},
                    {value:30,name:"Objective-C"},
                    {value:25,name:"C"},
                    {value:24,name:"Makefile"},
                    {value:22,name:"WebAssembly"},
                    {value:19,name:"TSQL"},
                    {value:17,name:"SCSS"},
                    {value:10,name:"PowerShell"},
                    {value:10,name:"F#"},
                    {value:137,name:"Others"},
                ],
                itemStyle: {
                    emphasis: {
                        shadowBlur: 10,
                        shadowOffsetX: 0,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }
        ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<p><img src="https://i.loli.net/2021/04/30/UC8DSlosXBIu5Mv.png" alt="fe0b04c74a9bae3058a8c53ba973f4e"></p>
<p>热力图不知道为什么始终没法在这里显示，所以就放个截图了……</p>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>Echarts</tag>
        <tag>Github</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification</title>
    <url>/2021/04/15/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Eliciting%20Information%20from%20Heterogeneous%20Mobile%20Crowdsourced%20Workers%20Without%20Verification/</url>
    <content><![CDATA[<h1 id="Eliciting-Information-from-Heterogeneous-Mobile-Crowdsourced-Workers-Without-Verification"><a href="#Eliciting-Information-from-Heterogeneous-Mobile-Crowdsourced-Workers-Without-Verification" class="headerlink" title="Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification"></a>Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification</h1><p>这篇和Strategic Information Revelation in Crowdsourcing Systems Without Verification是同一批作者的，针对的问题一样，内容方法看着也差不多，希望别一模一样……</p>
<a id="more"></a>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>问题：无验证的信息提取（IEWV）</p>
<p>思路：激励workers高质量和如实报告</p>
<p>常规方法：多数投票——符合多数解决方案的workers获得报酬</p>
<p>存在问题：未考虑workers的异构性</p>
<p>本文方法：两阶段Stackelberg博弈</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本文场景：</p>
<ol>
<li>workers求解准确率异构（即，不同workers以不同概率生成高质量数据）</li>
<li>考虑数据质量与平台成本之间的平衡</li>
</ol>
<p>本文方法：多数投票机制</p>
<p>需要解决的问题：</p>
<ol>
<li>给定奖励，多数投票机制下，异构workers会如何行动；</li>
<li>workers的异构性如何影响平台的最优奖励设计和均衡；</li>
<li>在提升平台均衡方面，知道workers异构方案准确性有什么价值。</li>
</ol>
<p>本文的两阶段博弈：</p>
<ol>
<li>平台决定多数投票机制的奖励等级，目标是最大化收益，该收益考虑了workers解决方案质量和平台总支出之间的均衡；</li>
<li>每个worker选择自己的努力等级和报告策略，目标是最大化自己收益。</li>
</ol>
<p>本文考虑两种情况：</p>
<ol>
<li>不完全信息博弈（平台不知道workers的准确率）</li>
<li>完全信息博弈（平台知道workers的准确率）</li>
</ol>
<h3 id="Key-Contributions"><a href="#Key-Contributions" class="headerlink" title="Key Contributions"></a>Key Contributions</h3><ol>
<li>分析了IEWV问题中异构workers场景下的平台均衡</li>
<li>分析了多均衡共存的场景</li>
<li>刻画了workers的最优策略</li>
<li>刻画了workers异构性对平台均衡的影响</li>
<li>刻画了得知workers异构性的价值</li>
</ol>
<h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><h3 id="Information-Elicitation"><a href="#Information-Elicitation" class="headerlink" title="Information Elicitation"></a>Information Elicitation</h3><p>略</p>
<h3 id="Information-Aggregation"><a href="#Information-Aggregation" class="headerlink" title="Information Aggregation"></a>Information Aggregation</h3><p>略</p>
<h2 id="3-Model"><a href="#3-Model" class="headerlink" title="3. Model"></a>3. Model</h2><h3 id="Workers’-Decision-Problem"><a href="#Workers’-Decision-Problem" class="headerlink" title="Workers’ Decision Problem"></a>Workers’ Decision Problem</h3><h4 id="Workers-and-Task"><a href="#Workers-and-Task" class="headerlink" title="Workers and Task"></a>Workers and Task</h4><p>集合：$N=\{1,2,…,N\}$表示到达平台的workers</p>
<p>待求解问题的答案是二选一，记作$X=\{-1,1\}$</p>
<p>$x\in X$表示该任务的正确答案</p>
<p>$x_i^{estimate}\in X$表示第$i$个worker对任务答案的估计值</p>
<p>$x_i^{estimate}\in X$表示第$i$个worker向平台上报的任务答案</p>
<h4 id="Worker-Effort-Exertion-and-Reporting-Strategy"><a href="#Worker-Effort-Exertion-and-Reporting-Strategy" class="headerlink" title="Worker Effort Exertion and Reporting Strategy"></a>Worker Effort Exertion and Reporting Strategy</h4><p>workers的任务质量依赖于努力程度，记作$e_i\in \{0,1\}$</p>
<p>workers可通过付出一定代价来努力从而提高任务质量（即准确率）</p>
<p>第$i$个worker的求解方案准确率记作$p_i\in (0.5,1])$</p>
<script type="math/tex; mode=display">
P(x_i^{estimate}=x)=\left\{
\begin{matrix}
p_i,\ \ &if\ \ e_i=1\ \ with\ \ a\ \ cost\ \ c_i\geq 0, \\
0.5,\ \ &if\ \ e_i=0.
\end{matrix}
\right.</script><p>workers异构性的体现：$N$个workers中有$k$个高质量的求解准确率为$p_h$，和$N-k$个低质量的求解准确率为$p_l$，$0.5&lt;p_l&lt;p_h\leq 1$</p>
<p>workers的上报策略：$v_i=\{1,-1,rd\}$，其中，努力的workers可以选择$\{1,-1\}$分别表示如实报告和谎报；而不努力的workers可以选择$rd$表示以0.5的概率随机上报</p>
<script type="math/tex; mode=display">
x_i^{report}=
\left\{
\begin{matrix}
x_i^{estimate},\ \ &if\ \  v_i=1\\
-x_i^{estimate},\ \ &if\ \  v_i=-1\\
1\ \  or\ \  -1\ \  with\ \  an\ \  equal\ \  probability,\ \ &if\ \  v_i=rd.
\end{matrix}
\right.</script><p>本文不考虑多个workers共谋等情况。</p>
<p>workers的策略记作$s_i=(e_i,v_i)$，属于集合$S_i=\{(0,rd),(1,1),(1,-1)\}$</p>
<h4 id="Internal-Reward-for-Truthful-Reports"><a href="#Internal-Reward-for-Truthful-Reports" class="headerlink" title="Internal Reward for Truthful Reports"></a>Internal Reward for Truthful Reports</h4><p>第$i$个worker如果努力且如实上报，则会得到内在奖励$l_i\geq 0$</p>
<p>反之，谎报会得到内在惩罚$-l_i$</p>
<p>不努力的worker会随机上报，他的内在奖励为0</p>
<h4 id="Consistency-Reward-for-Output-Agreement"><a href="#Consistency-Reward-for-Output-Agreement" class="headerlink" title="Consistency Reward for Output Agreement"></a>Consistency Reward for Output Agreement</h4><p>一致性奖励记作$R\geq 0$</p>
<p>除了第$i$个worker以外，其余workers的多数投票方案记作$x_{-i}^{majority}$</p>
<p>从第$i$个worker的角度来看，多数投票方案是：</p>
<script type="math/tex; mode=display">
x_{-i}^{majority}=
\left \{
\begin{matrix}
1,\ \ if\ \ \sum_{j\in N,j\neq i}x_j^{report}>0,\\
-1,\ \ if\ \ \sum_{j\in N,j\neq i}x_j^{report}<0,\\
tie,\ \ if\ \ \sum_{j\in N,j\neq i}x_j^{report}=0.
\end{matrix}
\right.</script><p>第$i$个worker的上报值与多数投票方案一致或者多数投票方案是tie的情况下，该worker会得到奖励；反之则不会。</p>
<p>第$i$个worker得到奖励R的概率记作$P_i(R,p,s)$，$p=(p_j,\forall j\in N)$，$s=(e,v)$，$e=(e_j,\forall j \in N)$，$v=(v_j,\forall j \in N)$</p>
<h4 id="Worker-Payoff-Maximization-Problem"><a href="#Worker-Payoff-Maximization-Problem" class="headerlink" title="Worker Payoff Maximization Problem"></a>Worker Payoff Maximization Problem</h4><p>worker的收益函数：$u_i(R,s)=R*P_i(R,p,s)+v_il_i-e_ic_i$</p>
<p><strong>博弈1：</strong>$\Omega_1=(N,S,u)$，其中：</p>
<ol>
<li><p>$N$：N个workers的集合</p>
</li>
<li><p>$S$：第$i$个worker的策略空间为$s_i\in S_i=\{(0,rd),(1,1),(1,-1)\}$。所有workers的策略记作$s=(s_i,\forall i\in N)$，所有workers的可行策略集合记作$S=\prod_{i\in N}S_i$。</p>
<p><em>这里应该是集合的笛卡尔积，不过这个表达不太确定是否正确。</em></p>
</li>
<li><p>$u$：向量$u=(u_i,\forall i \in N)$包含了所有workers的收益</p>
</li>
</ol>
<p>该博弈中，给定报酬$R$和其他workers的决策$s_{-i}=(e_{-i},v_{-i})=((e_j,v_j),\forall j \neq i)$，第$i$个worker需要求解下述优化问题。</p>
<p><strong>问题1：</strong> 第$i$个worker的收益最大化</p>
<p>$max\ \ u_i(R,s,s_{-i})$</p>
<p>$var.\ \ s_i\in\{(0,rd),(1,1),(1,-1)\}.$</p>
<p><strong>定义1：</strong> 纳什均衡：在给定$R$的情况下，如果对于所有$s_i’\in S_i$，和所有$i\in N$，都有$u_i(R,s_i^<em>,s_{-i}^</em>)\geq u_i(R,s_i’,s_{-i}^<em>)$，则认为策略$s^</em>=\prod_{i\in N}s_i^*$构成了博弈$\Omega_1$的一个纳什均衡。</p>
<p>注意：第$i$个worker的策略选择是前面<strong>问题1</strong>的优化解决方案，是与平台支付报酬$R$和其他worker策略$s_{-i}$相关的函数。</p>
<h3 id="Platform’s-Reward-Design-Problem"><a href="#Platform’s-Reward-Design-Problem" class="headerlink" title="Platform’s Reward Design Problem"></a>Platform’s Reward Design Problem</h3><h4 id="Accuracy-of-Aggregated-Estimate"><a href="#Accuracy-of-Aggregated-Estimate" class="headerlink" title="Accuracy of Aggregated Estimate"></a>Accuracy of Aggregated Estimate</h4><p>平台根据所有workers的上报值进行多数投票猜测最终的值</p>
<script type="math/tex; mode=display">
x_p^{estimate}=
\left \{
\begin{matrix}
1,\ &if\ \sum_{i=1}^Nx_i^{report}>0,\\
-1,\ &if\ \sum_{i=1}^Nx_i^{report}<0,\\
1\ or\ -1\ with\ an\ equal\ probability,\ &if\ \sum_{i=1}^Nx_i^{report}=0.
\end{matrix}
\right.</script><p>$P_a(R,p,N)$表示上述公式得到的聚合解决方案是正确的概率</p>
<p>假设：N是基数且$N\geq 4$</p>
<h4 id="Expected-Consistency-Rewards"><a href="#Expected-Consistency-Rewards" class="headerlink" title="Expected Consistency Rewards."></a>Expected Consistency Rewards.</h4><p>workers总一致性奖励期望记作$E[R^T]$</p>
<h4 id="Platform’s-Payoff-Maximization-Problem"><a href="#Platform’s-Payoff-Maximization-Problem" class="headerlink" title="Platform’s Payoff Maximization Problem"></a>Platform’s Payoff Maximization Problem</h4><p>平台收益函数：</p>
<script type="math/tex; mode=display">
\prod(R)=\beta P_a(R,p,N)-E[R^T]</script><p>$\beta&gt;0$表示平台对准确率分配的权重</p>
<p><strong>问题2：</strong> 平台的收益最大化：</p>
<p>$max \prod(R)$</p>
<p>$var. R\geq0$</p>
<h3 id="Two-Stage-Game"><a href="#Two-Stage-Game" class="headerlink" title="Two-Stage Game"></a>Two-Stage Game</h3><p>阶段1：平台决定R</p>
<p>阶段2：workers选择努力和上报策略</p>
<p>博弈求解方法：逆向归纳</p>
<p>符号表达：</p>
<p>$X$：任务类型空间</p>
<p>$x$：任务真实类型</p>
<p>$x_i^{estimate}$：第$i$个worker的估计值</p>
<p>$x_i^{report}$：第$i$个worker的上报值</p>
<p>$x_{-i}^{majority}$：除了第$i$个worker以外，剩下workers的多数投票方案</p>
<p>$x_p^{estimate}$：平台的聚合估计值</p>
<p>$s_i\triangleq(e_i,v_i)$：第$i$个worker的策略（努力策略和上报策略）</p>
<p>$c_i$：第$i$个worker的努力成本</p>
<p>$l_i$：第$i$个worker的内部奖励</p>
<p>$p_i$：第$i$个worker努力时的准确率</p>
<p>$R$：平台的一致性奖励</p>
<p>$\beta$：平台对聚合准确率的权重</p>
<p>$E[R^T]$：所有workers一致性奖励的期望</p>
<h2 id="4-Incomplete-Information"><a href="#4-Incomplete-Information" class="headerlink" title="4. Incomplete Information"></a>4. Incomplete Information</h2><p>每个worker的准确率只有自己知道，其他workers和平台都不知道。</p>
<h3 id="Workers’-Decisions-at-Stage-II"><a href="#Workers’-Decisions-at-Stage-II" class="headerlink" title="Workers’ Decisions at Stage II"></a>Workers’ Decisions at Stage II</h3><h4 id="Workers’-Heterogeneity"><a href="#Workers’-Heterogeneity" class="headerlink" title="Workers’ Heterogeneity"></a>Workers’ Heterogeneity</h4><p>workers异构性的体现：</p>
<ol>
<li>准确率异构——&gt;$k$个高准确率$p_h$workers，用集合$N_h$表示，$N-k$个低准确率$p_l$，用集合$N_l$表示，$1\leq k\leq N-1,0.5&lt;p_l&lt;p_h\leq 1$，这些参数的数值是公开信息。</li>
<li>努力时的成本和内在奖励/惩罚相同——&gt;$c_i=c,l_i=l,l&lt;c$</li>
</ol>
<h4 id="Workers’-Equilibrium-Behaviors"><a href="#Workers’-Equilibrium-Behaviors" class="headerlink" title="Workers’ Equilibrium Behaviors"></a>Workers’ Equilibrium Behaviors</h4><p>假设：同类型worker（准确率相同）会选择相同的策略</p>
<p><strong>定义2：</strong> 对称纳什均衡（SNE）</p>
<ol>
<li>n-SNE：所有workers都不努力和如实报告</li>
<li>f-SNE：所有workers都努力和如实报告</li>
<li>p-SNE：高质量workers努力和如实报告，低质量workers则相反</li>
</ol>
<p><strong>命题1：</strong> workers之间的SNE</p>
<ol>
<li>当$R\geq 0$时一定存在一个n-SNE</li>
<li>存在一个阈值$R_f\geq 0$，当$R\geq R_f$时，一定存在一个f-SNE</li>
<li>当$k\geq k_1$时，存在两个阈值$0&lt;R_p^l\leq R_p^h$，使得在$R_p^l\leq R \leq R_p^h$时，一定存在一个p-SNE</li>
</ol>
<p>阈值之间的关系取决于$k$的大小：当$k$较小时，$R_f\leq R_p^l$；当$k$较大时，$R_f&gt;R_p^l$。</p>
<p>由命题1可得：</p>
<ol>
<li>对于任意非负一致性奖励$R$，一定存在一个n-SNE，所有workers都没有动机努力和如实报告；努力worker的收益是$\frac{R}{2}+l-c$，不努力worker的收益是$\frac{R}{2}$，由于$l&lt;c$，显然不努力更好。</li>
<li>当一致性奖励足够大时，存在f-SNE，所有workers都会努力和如实报告。</li>
<li>workers准确率的异构性允许我们通过机制来使不同准确率的workers采取不同策略，当一致性准确率在合适范围内时，存在p-SNE使得高准确率workers努力且如实报告，而低准确率workers不努力并随机报告。</li>
</ol>
<p>各均衡解存在性与参数的关系：</p>
<ol>
<li>$k&lt;k_1:$ 高准确率workers很少时，不存在p-SNE。</li>
<li>$k_1\leq k\leq k_2:$ 高准确率workers人数适量时，存在p-SNE，但平台报酬$R$的下限很高（$R_p^l&gt;R_f$）。</li>
<li>$k\geq k_2:$ 高准确率workers足够多时，存在p-SNE，且$R_p^l&lt;R_f$。当k很大时，高质量workers在p-SNE得到报酬的概率与在f-SNE得到报酬的概率相近，低质量workers也会被激励选择(1,1)策略。</li>
</ol>
<p>帕累托最优均衡解：</p>
<p><strong>命题2：</strong> 给定一致性奖励$R$，一定存在一个帕累托最优均衡解。</p>
<p>这意味着可以通过调整一致性奖励来引导worker的努力策略和上报策略。</p>
<p><strong>命题3：</strong> 策略空间（$s_i^*=(0,rd),\forall i\in N_h,s_j=(1,1),\forall i\in N_l$）不存在均衡解。</p>
<p>这意味着不会出现低质量workers努力而高质量workers随机的场面。对于给定的R，高质量workers有更高的概率拿到奖励。在努力成本不变的前提下，高准确率workers更愿意选择(1,1)的策略。换言之，多数投票方案更能吸引高准确率workers。然而，在完全信息的场景下这一条并不成立。</p>
<h3 id="Platform’s-Reward-Design-at-Stage-I"><a href="#Platform’s-Reward-Design-at-Stage-I" class="headerlink" title="Platform’s Reward Design at Stage I"></a>Platform’s Reward Design at Stage I</h3><p>$P_f,P_p,P_n:$ workers在三种均衡下的聚合准确率</p>
<p>$E[R_f^T],E[R_p^T],E[R_n^T]:$ 三种均衡下的总期望一致性奖励</p>
<p>$\eta_f,\eta_p,\eta_n:$ 三种均衡下的效率（是指一致性奖励的效率）</p>
<p>效率计算方式：</p>
<p>$\eta_f=\frac{P_f-P_n}{E[R_f^T]}$</p>
<p>$\eta_p=\frac{P_p-P_n}{E[R_p^T]}$</p>
<p>$\eta_n=\frac{P_n-P_n}{E[R_n^T]}=0$</p>
<p>上面这个计算式反过来（也就是$\frac{1}{\eta_f}$）的含义是：对于单位准确率而言，从均衡n-SNE提高到f-SNE所需要支出的平均一致性奖励。$\eta_p$也是类似的含义。</p>
<p>平台的最优决策R：</p>
<p><strong>定理1：</strong> 给定任意参数$(\beta,N,c,l,p_l,p_h,k)$，平台可以引导workers达到f-SNE和对应的效率$\eta_f$</p>
<ol>
<li><p>如果p-SNE存在，且$\eta_p\geq \eta_f$，平台的最优一致性奖励为：</p>
<script type="math/tex; mode=display">
R^* = 
\left\{
\begin{matrix}
0,\ &if\ \beta<\frac{1}{\eta_p}, \\
R_p^l,\  &if\ \frac{1}{\eta_p}\leq\beta<\frac{E[R_f^T]-E[R_p^T]}{P_f-P_p}\\
R_f,\  &if\ \beta \geq \frac{E[R_f^T]-E[R_p^T]}{P_f-P_p};\\
\end{matrix}
\right.</script></li>
<li><p>其他情况下的平台最优一致性奖励为：</p>
<script type="math/tex; mode=display">
R^*=
\left \{
\begin{matrix}
0,&\ if\ \beta<1/\eta_f,\\
R_f,&\ if\ \beta\geq1/\eta_f.
\end{matrix}
\right.</script></li>
</ol>
<p><img src="https://i.loli.net/2021/05/07/E2af8LhbsgiKpUC.png" alt="image-20210507094050695"></p>
<p><img src="https://i.loli.net/2021/05/07/2PdRjKWyF7prVfT.png" alt="image-20210507094124550"></p>
<p>分析<strong>定理1</strong>可得：</p>
<ol>
<li>当p-SNE存在，且效率高于f-SNE，对应图4中的$k&gt;k^{THR}$区域，平台会根据$\beta$来引导均衡从而最大化收益。当$\beta$较小时，由于较低的准确率评价，平台不会提供任何激励，R=0，从而n-SNE是帕累托最优，对应图3中$k&gt;k^{THR}$区域中下面的白色部分。当$\beta$合适时，即图3中的蓝色区域，平台会选择$R=R_p^l$从而得到p-SNE。当$\beta$很大时，即图3中的灰色区域，平台会选择$R=R_f$，得到f-SNE，同时在一致性奖励方面支出很大。</li>
<li>当p-SNE不存在，或其效率低于f-SNE，对应图4中的$k&lt;k^{THR}$区域，类似前面的分析，$\beta$较小时，是n-SNE；反之则是p-SNE。</li>
</ol>
<h2 id="5-Complete-Information-Weighted-Aggregation"><a href="#5-Complete-Information-Weighted-Aggregation" class="headerlink" title="5. Complete Information: Weighted Aggregation"></a>5. Complete Information: Weighted Aggregation</h2><p>每个worker的准确率$p_i$是公开信息</p>
<h3 id="Workers’-Decisions"><a href="#Workers’-Decisions" class="headerlink" title="Workers’ Decisions"></a>Workers’ Decisions</h3><p>这一步和前面的<strong>博弈1</strong>、<strong>命题1</strong>一样。</p>
<h3 id="Platform’s-Reward-Design"><a href="#Platform’s-Reward-Design" class="headerlink" title="Platform’s Reward Design"></a>Platform’s Reward Design</h3><p>平台使用加权多数规则（weighted majority rule）来决定最终的聚合准确率：</p>
<script type="math/tex; mode=display">
x_p^{estimate}=
\left\{
\begin{matrix}
1,\ &if\ \sum_{i=1}^Nw_i(p_i,s_i)x_i^{report}>0\\
-1,\ &if\ \sum_{i=1}^Nw_i(p_i,s_i)x_i^{report}<0\\
1\ or\ -1\ with\ equal\ prob.,\ &if\ \sum_{i=1}^Nw_i(p_i,s_i)x_i^{report}=0
\end{matrix}
\right.</script><p>其中，</p>
<script type="math/tex; mode=display">
w_i(p_i,s_i)=log\frac{\rho(p_i,s_i)}{1-\rho(p_i,s_i)}, \\
\rho(p_i,s_i)=
\left\{
\begin{matrix}
0.5,\ &if\ s_i=(0,rd), \\
p_i,\ &if\ s_i=(1,1), \\
1-p_i,\ &if\ s_i=(1,-1).
\end{matrix}
\right.</script><p>权重公式既能提高聚合准确率，又会显著影响平台决定的报酬。</p>
<p>第$i$个worker的权重$w_i(p_i,s_i)$由其准确率和策略共同决定，因此：</p>
<ol>
<li>在f-SNE时（所有workers都选择<code>(1,1)</code>策略），高质量workers有更高权重，高低质量的权重都是正数；</li>
<li>在p-SNE时（高质量workers采取<code>(1,1)</code>而低质量workers采取<code>(0,rd)</code>），高质量workers权重为正数，低质量workers权重为0；</li>
<li>在n-SNE时（所有workers都选择<code>(0,rd)</code>策略），大家权重都是0，平台随机得到最终答案。</li>
</ol>
<p>数字符号定义如下：</p>
<ol>
<li>$P_f^{wm},P_p^{wm},P_n^{wm}$分别表示在加权多数规则情况下，f-SNE、p-SNE和f-SNE对应的聚合准确率；</li>
<li>$\eta_f^{wm},\eta_p^{wm},\eta_n^{wm}$分别表示在加权多数规则情况下，f-SNE、p-SNE和f-SNE对应的效率。</li>
</ol>
<p>计算方式：</p>
<p>$\eta_f^{wm}=(P_f^{wm}-P_n^{wm})/E[R_f^T]$</p>
<p>$\eta_p^{wm}=(P_p^{wm}-P_n^{wm})/E[R_p^T]$</p>
<p>$\eta_n^{wm}=(P_n^{wm}-P_n^{wm})/E[R_n^T]=0$</p>
<p>workers的均衡解行为和不完全信息一致，每种均衡对应的总一致性奖励（$E[R_f^T],E[R_p^T],E[R_n^T]$）也一致。</p>
<p><strong>命题4：</strong> 给定参数$(\beta,N,c,l,p_l,p_h,k)$，如果f-SNE和p-SNE共存，则$P_f^{wm}\geq P_p^{wm}$</p>
<p><strong>证明：</strong> 在p-SNE，低准确率workers采取<code>(0,rd)</code>，高准确率workers采取<code>(1,1)</code>，根据计算权重的公式，低质量workers权重为0，高质量workers权重为正数，基于此可计算得到$P_p^{wm}$。在f-SNE，所有workers采取<code>(1,1)</code>，按照p-SNE分配权重是可行的，此时$P_f^{wm}= P_p^{wm}$。由于权重计算公式是最优的，因此可得$P_f^{wm}\geq P_p^{wm}$。</p>
<p><em>补充：这个证明没看懂，个人对命题4的理解是说，两个均衡解共存时，f-SNE是所有workers都努力并如实报告，p-SNE是只有高质量workers努力并如实报告，显然f-SNE多了低质量workers努力贡献的准确率，因此总的准确率会更高。</em></p>
<p>由此，可以刻画平台的最优决策，和<strong>定理1</strong>一样，只有符号表达替换了。</p>
<p><img src="https://i.loli.net/2021/05/18/1Rf8TAgeHwkzsEn.png" alt="image-20210518162745417"></p>
<p>图5是新的均衡图解。蓝色区域更大了，也就是说在完全信息的场景下，平台更可能只让高质量workers努力和正确上报。</p>
<p><strong>定理2</strong>： 令$\prod^{inc<em>}$和$\prod^{com</em>}$表示平台在不完全信息和完全信息情况下对应的最优收益。给定参数$(\beta,N,c,l,p_l,p_h,k)$，可得：$\prod^{com<em>}\geq \prod^{inc</em>}$。</p>
<h2 id="6-Complete-Information-Discriminatory-Reward-Policy"><a href="#6-Complete-Information-Discriminatory-Reward-Policy" class="headerlink" title="6. Complete Information: Discriminatory Reward Policy"></a>6. Complete Information: Discriminatory Reward Policy</h2><p>第5章中，平台给不同准确率的workers相同的奖励；本章中则采取有差别的奖励策略，即便是和多数一致方案相同，也会因为准确率不同而得到不同的奖励：低准确率得到的奖励是$R_{low}$，高准确率得到的奖励是$R_{high}$。</p>
<h3 id="Workers’-Decisions-1"><a href="#Workers’-Decisions-1" class="headerlink" title="Workers’ Decisions"></a>Workers’ Decisions</h3><p><strong>命题5</strong>：workers的SNE是</p>
<ol>
<li>$R_{low}$和$R_{high}$都大于等于0时，$s_i^*=(0,rd),\forall i$是一个SNE；</li>
<li>存在两个阈值$R_f^l$和$R_f^h$均大于0，使得当$R_{low}\geq R_f^l$且$R_{high}\geq R_f^h$时，$s_i^*=(1,1),\forall i$是一个SNE；</li>
<li>存在两个阈值$R_p^l$和$R_p^h$均大于0，使得当$R_{low}\leq R_p^l$且$R_{high}\geq R_p^h$时，高质量workers采取$(1,1)$而低质量workers采取$(0,rd)$是SNE；</li>
<li>存在两个阈值$R_{pl}^l$和$R_{pl}^h$均大于0，使得当$R_{low}\geq R_{pl}^l$且$R_{high}\leq R_{ph}^h$时，低质量workers采取$(1,1)$而高质量workers采取$(0,rd)$是SNE。</li>
</ol>
<h3 id="Platform’s-Optimal-Reward-Design"><a href="#Platform’s-Optimal-Reward-Design" class="headerlink" title="Platform’s Optimal Reward Design"></a>Platform’s Optimal Reward Design</h3><p><strong>定理3：</strong></p>
<ol>
<li>使用$\prod_{UP}^{com<em>}$和$\prod_{DP}^{com</em>}$表示平台在均等奖励和差分奖励的情况下的最优支出，则有：$\prod_{DP}^{com<em>}\geq\prod_{UP}^{com</em>}$</li>
<li>存在阈值$\bar{\beta}$，使得当$\beta\geq \bar{\beta}$时，如果UP的最优SNE是n-SNE，且DP的最优SNE不是f-SNE、p-SNE或者pl-SNE，则DP的社会财富比UP高。</li>
</ol>
<p>定理3说明从平台来看，采取差分奖励策略会带来不比均等奖励策略糟糕的支出和社会财富。DP并不一定会损害社会财富，反而会带来双赢的场面。</p>
<h2 id="7-Numerical-Results"><a href="#7-Numerical-Results" class="headerlink" title="7. Numerical Results"></a>7. Numerical Results</h2><p>分析高质量workers的数量$k$和高质量workers准确率$p_h$对平台与workers收益的影响。</p>
<h3 id="Incomplete-Information"><a href="#Incomplete-Information" class="headerlink" title="Incomplete Information"></a>Incomplete Information</h3><h3 id="Complete-Information"><a href="#Complete-Information" class="headerlink" title="Complete Information"></a>Complete Information</h3><h2 id="8-Conclusion"><a href="#8-Conclusion" class="headerlink" title="8. Conclusion"></a>8. Conclusion</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>crowdsourcing</tag>
        <tag>stackelberg game</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链行业总结</title>
    <url>/2021/04/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A1%8C%E4%B8%9A%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="区块链行业总结"><a href="#区块链行业总结" class="headerlink" title="区块链行业总结"></a>区块链行业总结</h1>]]></content>
      <categories>
        <category>slides</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-A Novel Paradigm for Disaster-Response Networks: Framework, Strategy and Solution</title>
    <url>/2021/03/06/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-A%20Novel%20Paradigm%20for%20Disaster-Response%20Networks%20Framework,%20Strategy%20and%20Solution/</url>
    <content><![CDATA[<h1 id="灾害应对网络的新范式：框架、策略与解决方案"><a href="#灾害应对网络的新范式：框架、策略与解决方案" class="headerlink" title="灾害应对网络的新范式：框架、策略与解决方案"></a>灾害应对网络的新范式：框架、策略与解决方案</h1><p>这篇是投稿到IEEE Wireless Communications Magazine的论文，现在要写审稿意见。</p>
<p>作者：</p>
<p>中国电力科学研究院</p>
<p>西安电子科技大学</p>
<p>华中科技大学</p>
<p>西北工业大学</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ol>
<li>起因：自然灾害频发、恐怖势力猖獗</li>
<li>特性：DRN（disaster-response network灾害应对网络）更看重网络的灵活性和应急救援能力，对网络框架和资源配置策略提出了新的要求</li>
<li>技术基础：卫星通信和无人机（UAV）动态中继</li>
<li>本文：提出了DRN建设和资源配置的新范式，通过卫星和无人机构建动态可扩展的DRN；提出了新的网络资源配置视角；在DRN框架下设计了资源调度计划。</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="DRN的结构"><a href="#DRN的结构" class="headerlink" title="DRN的结构"></a>DRN的结构</h3><ol>
<li>需求：快速恢复通信，为救灾提供前提，提高救援效率</li>
<li>关键问题：个人安全</li>
<li>传统DRN：在快速部署和网络灵活性方面不好</li>
<li>新技术DRN：根据是否使用其他基础设施分为两类，基础设施包括可移动和可部署的ICT资源单元（MDRU）、卫星、无人机；总的来说使用其他基础设施的这一类更好</li>
<li>大多数现有网络的问题：只重视容量或覆盖性能，忽视救灾需求，尤其是用户的人身安全</li>
</ol>
<h3 id="DRN中的资源分配"><a href="#DRN中的资源分配" class="headerlink" title="DRN中的资源分配"></a>DRN中的资源分配</h3><ol>
<li>受灾用户的实时需求通常远远大于 DRN 的能力。因此，资源配置策略成为决定系统效率的关键因素。传统网络中的资源配置策略通常涉及容量、延迟或吞吐量，并相应地进行优化。</li>
<li>救灾的特殊性，即及时性和任务导向性，加上DRN之间的建筑差异，使得现有的资源配置策略不适应。由于时间和任务导向，主要考虑如何提高受灾用户的救援能力。因此，DRN 中的资源分配策略需要更多地考虑应用层的要求，而不是物理层的性能。</li>
</ol>
<h3 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h3><ol>
<li>针对时效性和任务导向，提出了一种新范式</li>
<li>采用卫星、无人机</li>
<li>快速部署、动态覆盖、灵活中继</li>
<li>第二部分：DRN的框架；第三部分：跨层资源优化和资源分配方案的开发；第四部分：性能评估；第五部分：总结</li>
</ol>
<h2 id="Disaster-response-network"><a href="#Disaster-response-network" class="headerlink" title="Disaster response network"></a>Disaster response network</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ol>
<li>由空间层、空气层和地面层组成：用户在地面层，需要发射信号；无人机在空气层收集信号传递给空间层的卫星；卫星和卫星基站通信。</li>
<li>空间层：使用低轨道卫星、中心化网络控制器</li>
<li>空气层：无人机作为中继来弥补卫星欠缺的灵活性等；假设无人机数量大于卫星容量，配备移动充电设施，可动态规划工作路径；简化卫星信道受大气变化的影响问题，重点关注资源分配策略</li>
<li>地面层：遇险用户发射求救信号成功则被视为成功救援；用户分为三类：成功发出信号的被救援用户（R-user）、有足够电量试图发求救信号的活跃用户（A-user）、用完电池无能为力的沉默用户（S-user）</li>
<li>本文框架中的A-user通过无人机中继器向卫星发信号，无人机分配完成后网络拓扑保持不变，每个用户只涉及一个无人机中继，使用译码转发和波束形成技术，用户与无人机中继之间的链路采用Nakagami衰落信道模型</li>
</ol>
<h3 id="资源分配策略"><a href="#资源分配策略" class="headerlink" title="资源分配策略"></a>资源分配策略</h3><ol>
<li>控制层和数据层通过卫星上的中心化网络解耦</li>
<li>控制层：网络控制器制定通信请求接收率（CRAR），接收用户、无人机报告的信道状态信息，收集用户设备的剩余工作时间</li>
<li>资源分配问题：用户的剩余电量不同，卫星要在电量耗尽前接收用户的遇险通信请求；通信请求的数量可能超过网络容量，要综合考虑用户设备的剩余工作时间和卫星、无人机可以处理的通信请求。</li>
</ol>
<h2 id="Resource-allocation"><a href="#Resource-allocation" class="headerlink" title="Resource allocation"></a>Resource allocation</h2><ol>
<li>用CRAR作为系统效率指标，即优化目标是提高CRAR</li>
<li>t时刻的CRAR指当前CRAR和未来CRAR的总和<ol>
<li>当前CRAR：s(t)</li>
<li>未来CRAR：$\sum_{\tau=t+1}^{\infty}P_{\tau}(B, C_{v-u}, C_{u-s})$</li>
<li>$B, C_{u-s},C_{v-u}$分别表示用户电量、空间层频道和空气层频道</li>
<li>电量越多用户等待救援的时间越久</li>
</ol>
</li>
<li>无人机算力有限，因此需要降低资源分配算法的复杂度——本文资源分配分为两阶段：空间层和空气层各一阶段</li>
<li>第一阶段中，对于每个无人机中继，网络控制器都会收集 CSI（频道状态信息） 并保持空气层链路的信道增益，这是成功传输的最关键因素之一。卫星根据卫星接入能力以更大的信道增益访问无人机中继</li>
<li>第二阶段中，t时刻的空气层链路资源分配方案：用矩阵表示卫星到无人机的分配方案、无人机到用户的分配方案和根据信道容错率判断的信道可用性（1或者0），用户电量不同会有不同的权重（低电量高延迟的优先级高），计算上述矩阵卷积相乘的F范数来作为目标函数</li>
<li>优化算法：贪婪的迭代匹配过程</li>
</ol>
<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><ol>
<li>仿真模拟实验：用户由泊松点过程建模，使用二进制相移键控发送信号，位错误概率阈值$\epsilon=10^3$，进行20轮实验</li>
</ol>
<h3 id="CRAR"><a href="#CRAR" class="headerlink" title="CRAR"></a>CRAR</h3><ol>
<li>不同信噪比下，无人机数量和CRAR之间的关系</li>
</ol>
<h3 id="传输功率"><a href="#传输功率" class="headerlink" title="传输功率"></a>传输功率</h3><ol>
<li>不同无人机数量下，CRAR和传输功率之间的关系</li>
</ol>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>提出了灾害应对系统中的资源分配方案，可改善CRAR</p>
<h2 id="审稿意见"><a href="#审稿意见" class="headerlink" title="审稿意见"></a>审稿意见</h2><h3 id="Strength"><a href="#Strength" class="headerlink" title="Strength"></a>Strength</h3><ul>
<li></li>
<li></li>
</ul>
<h3 id="Weakness"><a href="#Weakness" class="headerlink" title="Weakness"></a>Weakness</h3><ul>
<li>创新性较差，实质就提出了一个基于电量和延迟的资源分配方案</li>
<li>灾害应对系统的通信恢复过程除了考虑用户电量和延迟，也应当考虑用户本身的生命体征等；第一部分中提到的其他DRN存在的问题，本文中的DRN同样也有</li>
<li>公式1中的P函数具体形式没有介绍，且后文中的资源分配方案是否能得到最优的R(t)也需要进行分析</li>
<li>没有具体介绍空间层（卫星和无人机）的分配方案，“卫星以较大的信道增益访问无人机”是否会和卫星本身的容量和传输能力发生冲突，如果发生冲突（即资源不够分配）时，应当如何向不同的无人机分配资源？</li>
<li><del>网络控制器是卫星和无人机上都有吗？是否可以把无人机的资源分配计算工作放到卫星上，无人机仅进行通信中继？</del></li>
<li>在用户设备与无人机建立通信连接后，如果因为意外导致连接断开如何判断和处理？</li>
<li>在灾害应对系统中，直接将信息发送成功视作救援成功合适吗？是否还需要考虑周期性确认用户状态等后续操作带来的能量消耗？</li>
<li>实验中用作对比的传统方案具体是指哪种方案？</li>
<li>实验是数值仿真还是小规模的无人机仿真？如果是前者，无人机和卫星在实际使用场景的差异很大，数值仿真无法有效说明方案的效率；如果进行了无人机实验，则型号等相关参数应该在实验部分进行说明。</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>灾害应对网络</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-中世纪历史与文化</title>
    <url>/2021/03/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%AD%E4%B8%96%E7%BA%AA%E5%8E%86%E5%8F%B2%E4%B8%8E%E6%96%87%E5%8C%96/</url>
    <content><![CDATA[<h1 id="中世纪历史与文化"><a href="#中世纪历史与文化" class="headerlink" title="中世纪历史与文化"></a>中世纪历史与文化</h1><h2 id="第一章-波埃修斯与欧洲的崛起"><a href="#第一章-波埃修斯与欧洲的崛起" class="headerlink" title="第一章 波埃修斯与欧洲的崛起"></a>第一章 波埃修斯与欧洲的崛起</h2><h3 id="波埃修斯：新柏拉图主义者"><a href="#波埃修斯：新柏拉图主义者" class="headerlink" title="波埃修斯：新柏拉图主义者"></a>波埃修斯：新柏拉图主义者</h3><ol>
<li>波埃修斯的成就：<ol>
<li>翻译《工具论》by亚里士多德的前三篇，介绍了一种思维方式；</li>
<li>著作《分类之书》、论算术的论文、对音乐的说明、《哲学的慰藉》等；</li>
<li>将“原理”“主体”“本质”等基础概念引入欧洲学术话语；</li>
<li>“知识并不来自所认知的事物，而是进行思考与认识的主题的认知能力所固有的”；</li>
<li>“四艺”的概念</li>
</ol>
</li>
<li>对后世的影响：<ol>
<li>《哲学的慰藉》：见证了古典文化在最终熄灭前发出最后的火光；</li>
<li>但丁、豪斯费霍尔等作者深受影响；</li>
<li>”哲学“与”命运“的讨论支撑着基督教，对自由意志的探讨意义深远；</li>
<li>推进神学与哲学之辩——&gt;中世纪理性与信仰日趋严重分化与对立</li>
</ol>
</li>
<li>在这之后：学术与知识逐渐随古代的结束而沉默，许多学派被取缔，艺术停滞在圣像的形式主义上，留下的只有基督教、教会和异端。中世纪的教育体系不再关注传统教育内容——科学研究与实验，而更多地体现为护教、阐释、劝勉、布道和虔敬。</li>
</ol>
<h3 id="传承到中世纪的知识"><a href="#传承到中世纪的知识" class="headerlink" title="传承到中世纪的知识"></a>传承到中世纪的知识</h3><ol>
<li>《论基督教教义》by圣奥古斯丁：符号学——事物通过符号被认识</li>
<li>《指南》by卡西奥多鲁斯：基督教的教育规划</li>
<li>《语文学与墨丘利的婚约》by马蒂安努斯$\cdot$卡佩拉：寓言式的有关技艺的基础教程</li>
</ol>
<h3 id="罗马与外族的融合"><a href="#罗马与外族的融合" class="headerlink" title="罗马与外族的融合"></a>罗马与外族的融合</h3><ol>
<li>来到罗马帝国的土地上的外族人一方面想要战胜先进文明，同时另一方面又效仿着先进文明，典型的例子：哥特人</li>
</ol>
<h4 id="哥特人"><a href="#哥特人" class="headerlink" title="哥特人"></a>哥特人</h4><ol>
<li>”没有法律任何国家都不能长存“</li>
<li>”复兴罗马“成为接下来数百年乃至整个中世纪的标语，在历史的不同阶段以不同面貌出现，也以不同方式被付诸实践</li>
<li>最初（4世纪初以来）罗马人向哥特人派遣基督教传教士，而这也受到了异教徒的抵抗，由此发生了哥特人的罗马化。在这一阶段，乌尔菲拉主教将《圣经》翻译为哥特方言，尽管翻译存在很多问题，但这仍然推进了哥特人向地中海高等文化的转变。</li>
<li>到5世纪左右，哥特人分为西哥特和东哥特两部分</li>
<li>5世纪后期，西哥特国王们编撰了一系列法令集，这些成文法一直沿用至中世纪盛期，它们将”罗马人“从”哥特人“中分离出来，并形成”成文法区域“</li>
<li>在与法兰克人打仗并战败后，哥特人被迫来到赛蒂马尼亚和西班牙，并建立新的哥特王国。在此之后原本信奉阿里乌教派的哥特人皈依了天主教，修订了教会法。</li>
<li>尽管哥特人认可天主教会的合法性，但事实上哥特人与罗马教会、教宗之间并未建立法律上的联系，哥特-西班牙的天主教徒更多地保持了自身的独立性</li>
<li>11世纪教会改革，西班牙被纳入罗马教宗的普世主教区（指世俗君主放弃神职叙任权）</li>
</ol>
<h4 id="法兰克人"><a href="#法兰克人" class="headerlink" title="法兰克人"></a>法兰克人</h4><ol>
<li>在哥特人发展的同时，法兰克人也在发展；法兰克人的起源混沌不清，没有详细记载，更多的是各种神话</li>
<li>法兰克的整个发展过程中都得到了罗马帝国的帮助，尤其是经济扶持；相应地，墨洛温王朝将罗马遗留的军事、民政管理系统作为自身的统治基础。</li>
<li>古典文化在墨洛温王朝经历了转型、退化，并没有像在哥特王国那样突然消亡。</li>
<li>法兰克王国的创立者克洛维死后，按其意愿，法兰克王国分给了他的四个儿子，这一分裂的继承法由此传承下去，直到9、10世纪随加洛林王朝的结束而结束。</li>
<li>法兰克王国的由于分裂的继承法没能形成稳定的证券，但同时诞生了一系列下属王国</li>
</ol>
<h4 id="东罗马帝国（拜占庭）"><a href="#东罗马帝国（拜占庭）" class="headerlink" title="东罗马帝国（拜占庭）"></a>东罗马帝国（拜占庭）</h4><ol>
<li>在波埃修斯的时代，东罗马统治者是查士丁尼大帝，他实行了一系列复兴政策：<ol>
<li>收复落入蛮族统治的西部省份——战争同时带来巨大的负担，以君士坦丁堡为中心建立的政治经济集权体制绑架了被收复省份的发展机会，削弱了其生产和抵抗的力量，反而加快了罗马帝国的衰落</li>
<li>编撰罗马法法典《民法大全》（又被称为《查士丁尼法典》）——11世纪末，引发了西方以大学为基础的学术勃兴</li>
<li>关闭雅典学园——科学发展逐渐停滞，不再有根本上的创新</li>
</ol>
</li>
<li>陆陆续续的外敌入侵：<ol>
<li>来自中亚的匈人入侵</li>
<li>南面皈依伊斯兰教的阿拉伯人</li>
<li>各类蛮族：斯拉夫人、阿瓦尔人、佩切涅格人、保加利亚人</li>
<li>伦巴第人入侵意大利</li>
</ol>
</li>
<li>11世纪诺曼人的到来终结了拜占庭势力对伦巴第和意大利南部的影响</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>罗马象征着先进的物质、社会和文化发展水平，”朝向罗马“（Romorientierung）这一确凿的、潜意识上的进程从未消解。与之对应的，在罗马彼岸居住着古代意义上的”野蛮人“，他们相对于罗马而言处于低等文化，只拥有少数铁器；没有城市和铺设的道路；只有纯粹的口头文化而没有文字，很长一段时间内用凿刻的符文作为咒语或简单的名字；没有科学也没有持久的历史传统；宗教崇拜鲜为人知。</p>
<p>西方世界的不同地域对接受和继承高等书写文化有着完全不同的启动环境，离地中海高等文明越远的地方，高等文明遭到的拒绝和限制就越明显，其童话效应也更为迟缓和微弱。</p>
<p>不过爱尔兰与众不同，西方学术的复兴从那里受益，尽管波埃修斯的作品并未在爱尔兰产生任何影响。</p>
<h2 id="第二章-大格里高利和法兰克人的新兴权力"><a href="#第二章-大格里高利和法兰克人的新兴权力" class="headerlink" title="第二章 大格里高利和法兰克人的新兴权力"></a>第二章 大格里高利和法兰克人的新兴权力</h2><h2 id="第三章-查理曼与第一次“罗马帝国的复兴”"><a href="#第三章-查理曼与第一次“罗马帝国的复兴”" class="headerlink" title="第三章 查理曼与第一次“罗马帝国的复兴”"></a>第三章 查理曼与第一次“罗马帝国的复兴”</h2><h2 id="第四章-王国的巩固与罗马帝国的第二次复兴"><a href="#第四章-王国的巩固与罗马帝国的第二次复兴" class="headerlink" title="第四章 王国的巩固与罗马帝国的第二次复兴"></a>第四章 王国的巩固与罗马帝国的第二次复兴</h2><h2 id="第五章-末世危险地临近了"><a href="#第五章-末世危险地临近了" class="headerlink" title="第五章 末世危险地临近了"></a>第五章 末世危险地临近了</h2><h2 id="第六章-“真正的皇帝是教宗”"><a href="#第六章-“真正的皇帝是教宗”" class="headerlink" title="第六章 “真正的皇帝是教宗”"></a>第六章 “真正的皇帝是教宗”</h2><h2 id="第七章-教宗分立的漫长世纪"><a href="#第七章-教宗分立的漫长世纪" class="headerlink" title="第七章 教宗分立的漫长世纪"></a>第七章 教宗分立的漫长世纪</h2><h2 id="第八章-天主的代理人"><a href="#第八章-天主的代理人" class="headerlink" title="第八章 天主的代理人"></a>第八章 天主的代理人</h2><h2 id="第九章-法理高奏凯歌"><a href="#第九章-法理高奏凯歌" class="headerlink" title="第九章 法理高奏凯歌"></a>第九章 法理高奏凯歌</h2><h2 id="第十章-理性之光"><a href="#第十章-理性之光" class="headerlink" title="第十章 理性之光"></a>第十章 理性之光</h2><h2 id="第十一章-君主制"><a href="#第十一章-君主制" class="headerlink" title="第十一章 君主制"></a>第十一章 君主制</h2><h2 id="第十二章-对最后的审判与重生的期待"><a href="#第十二章-对最后的审判与重生的期待" class="headerlink" title="第十二章 对最后的审判与重生的期待"></a>第十二章 对最后的审判与重生的期待</h2>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>中世纪历史与文化</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+reveal实现slide</title>
    <url>/2021/03/02/hexo+reveal%E5%AE%9E%E7%8E%B0slide/</url>
    <content><![CDATA[<h1 id="hexo-reveal"><a href="#hexo-reveal" class="headerlink" title="hexo+reveal"></a>hexo+reveal</h1><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>今天终于搞成了用<code>reveal.js</code>在博客里显示ppt的效果。感谢做模块的大佬，以至于安装过程还挺简单的。步骤如下：</p>
<ol>
<li><p>安装：命令行进入博客目录，输入<code>npm i hexo-generator-slidehtml</code></p>
</li>
<li><p>安装好以后，一个按格式（格式见后文）写好的markdown文件就会被渲染成slide格式的html网页了，需要访问的时候，在博客的链接后面加<code>slide.html</code>即可，比如某个博客的链接是<code>http://www.clo5de.info/hexo-generator-slidehtml/2019/04/03/nonTitleMerge/</code>，那么它对应的slide链接就是<code>http://www.clo5de.info/hexo-generator-slidehtml/2019/04/03/nonTitleMerge/slide.html</code>。</p>
</li>
<li><p>但是这样安装好的没法渲染公式，因此要进入<code>\blog\node_modules\hexo-generator-slidehtml\layout</code>目录，打开<code>post-slide.ejs</code>文件，添加<code>&lt;script src=&quot;https://cdn.bootcss.com/reveal.js/3.4.1/plugin/math/math.js&quot;&gt;&lt;/script&gt;</code>（和其他script放一起就行），并在<code>Reveal.initialize</code> 代码块中添加一行<code>plugins: [ RevealMath ],</code>注意这一行最后有个逗号不要忘了。</p>
</li>
<li><p>关于math的设置也还有其他可选项，可以参考<a href="https://revealjs.com/math/" target="_blank" rel="noopener">官网</a></p>
</li>
<li><p>此外我在官网还下载了<code>reveal.js</code>的完整内容，并把其中的<code>plugin</code>文件夹整个复制到了<code>\blog\node_modules\hexo-generator-slidehtml\layout</code>目录下；而刚才那个<code>post-slide.ejs</code>的<code>Reveal.initialize</code> 代码块中的<code>dependencies</code>也增加了以下两行：</p>
<p><code>{ src: &#39;https://cdn.bootcss.com/reveal.js/3.4.1/plugin/math/math.esm.js&#39; },</code></p>
<p><code>{ src: &#39;https://cdn.bootcss.com/reveal.js/3.4.1/plugin/math/math.js&#39; },</code></p>
<p>不过这一步的操作按理说是不需要的，只是我一开始怎么也没法刷新出公式，猜测可能和网页缓存等有关。</p>
</li>
<li><p>按官网的说法，如果要写markdown行内公式，就需要把内容放到如下代码所示的符号中间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;$$公式内容$$&#96;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If you want to include math inside of a presentation written in Markdown you need to wrap the formula in backticks. This prevents syntax conflicts between LaTeX and Markdown</p>
</blockquote>
</li>
<li><p>不过根据我自己的使用，markdown语法的公式就可以正常显示了，不需要按上面的格式来写。</p>
</li>
<li><p>如果写latex公式，就放到<code>&lt;section&gt;&lt;/section&gt;</code>中间，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">  &lt;h2&gt;The Lorenz Equations&lt;&#x2F;h2&gt;</span><br><span class="line">  \[\begin&#123;aligned&#125;</span><br><span class="line">  \dot&#123;x&#125; &amp; &#x3D; \sigma(y-x) \\</span><br><span class="line">  \dot&#123;y&#125; &amp; &#x3D; \rho x - y - xz \\</span><br><span class="line">  \dot&#123;z&#125; &amp; &#x3D; -\beta z + xy</span><br><span class="line">  \end&#123;aligned&#125; \]</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
<p>这个公式的展示效果在官网上可以看到。</p>
</li>
<li><p>在搞了各种配置之后公式如果还没渲染，就等一等，可能和缓存有关。</p>
</li>
<li><p>对于需要制作成slide的markdown文件，只需要在原先写标题日期分类和tags等内容的那个地方增加一个字段：<code>slidehtml: true</code>，这个也可以写进<code>hexo new</code>的模板，这样方便一些。markdown文件中要有一行<code>&lt;!-- #Slide Start# --&gt;</code>（去掉#，这里加#是为了避免接下来直接渲染slide），整个文件内容会以此分为两部分，在这一行前面的，就会展示在博客内容中，而这一行后面的，则会出现在对应的slide中。例如本篇博客的内容就到此结束了，而如果在网址后面添加<code>slide.html</code>，则会看到我复制别人的slide内容。</p>
</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://github.com/jackey8616/hexo-generator-slidehtml" target="_blank" rel="noopener">https://github.com/jackey8616/hexo-generator-slidehtml</a></li>
<li><a href="https://revealjs.com/math/" target="_blank" rel="noopener">https://revealjs.com/math/</a></li>
<li><a href="https://www.lfhacks.com/assets/revealjs.html" target="_blank" rel="noopener">https://www.lfhacks.com/assets/revealjs.html</a></li>
<li><a href="http://vishalgupta.me/md-slides/" target="_blank" rel="noopener">http://vishalgupta.me/md-slides/</a></li>
</ol>
]]></content>
      <categories>
        <category>slides</category>
      </categories>
      <tags>
        <tag>博客配置</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Closed-Form Expression for the Poisson-Binomial Probability Density Function</title>
    <url>/2021/02/12/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Closed-Form%20Expression%20for%20the%20Poisson-Binomial%20Probability%20Density%20Function/</url>
    <content><![CDATA[<h1 id="Closed-Form-Expression-for-the-Poisson-Binomial-Probability-Density-Function"><a href="#Closed-Form-Expression-for-the-Poisson-Binomial-Probability-Density-Function" class="headerlink" title="Closed-Form Expression for the Poisson-Binomial Probability Density Function"></a>Closed-Form Expression for the Poisson-Binomial Probability Density Function</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>二项分布概率密度函数描述了当单个成功概率在试验中保持不变时 N 次独立试验中的成功数。而当这个成功概率会改变时，概率密度函数就转变为泊松-二项分布。</p>
<p>例子：</p>
<ol>
<li>可靠性理论/容错：当N个子进程中有至少M个失败时，我们认为该进程失败。第n个子进程的失败概率为$p_n$，计算整个进程的失败概率。</li>
<li>目标追踪：当传感器在N次连续独立查找中至少检测到M次时，目标追踪会被启动。给定可能会改变的每次查找检测概率$p_n$，确定追踪启动的概率。</li>
<li>模式识别/决策理论：如果第n个专家在诊断某特殊情况是否发生时，有$p_n$的概率得到正确的判断，那么为了实现超过某一百分数的正确率，需要多少位独立专家的重合判定。</li>
<li>教育考试设计：标准化考试中有N个等权重问题，给定至少正确解答其中n个问题的学生百分数，据此推算每个问题正确回答学生的百分数，从而确定问题是否表现出所需的难度扩散。（这是一个逆向泊松二项分布的问题）</li>
<li>多传感器融合：给定一个由N个传感器组成的网络，其检测/无检测输出将通过投票结果进行组合，为了实现指定的M-out-N”融合”误报概率，每个传感器的误报率应该是多少。</li>
<li>项目管理/资源分配：有K个工作站，每个工作站分配到$r_k$个资源，每个工作站达到其各自生产配额的概率为$p_k=f(r_k)$。给定L个附加工作站的可用性，并假设函数$f()$可逆，应向新工作站分配多少资源，以便K+L个工作站中至少 M 个工作站能达到其生产配额的概率为P。</li>
</ol>
<p>本文组织结构：</p>
<ol>
<li>单独每次事件成功率与泊松-二项分布概率密度函数之间的关系</li>
<li>数值技术（多项式插值和离散傅里叶变换）</li>
<li>通过获取二项系数、二项式 cdf 和泊松-二项性时刻（Poisson-binomial moments，这个翻译不知道是否正确）的新表示来演示这些表达式的使用</li>
<li>解决前面的第6个例子作为应用展示</li>
<li>使用多项式技术和矩阵理论技术解决逆向泊松-二项分布的问题</li>
<li>总结</li>
</ol>
<h2 id="GROUNDWORK"><a href="#GROUNDWORK" class="headerlink" title="GROUNDWORK"></a>GROUNDWORK</h2><p>在N次独立实验中，第k次的成功率为$p_k$，失败率为$1-p_k$。成功的次数Y可以被写作$Y=X_1+X_2+…+X_N$，这N个相互独立的随机变量$X_k$，分布向量为$[Pr\{X_k=0\}\ \ Pr\{X_k=1\}]=[1-p_k\ \ p_k]$，其中$Pr\{u\}$表示$u$的概率。而这些随机变量的和式Y的分布就是泊松二项概率密度函数，其表达式通过线性卷积可以得到：</p>
<script type="math/tex; mode=display">
[Pr\{Y=0\}\ \ Pr\{Y=1\}...Pr\{Y=N\}]\\
= [1-p_1\ \ p_1]*[1-p_2\ \ p_2]*...*[1-p_N\ \ p_N] \tag{1}</script><p>对公式1两边使用Z变换，可得泊松二项概率密度函数的两种生成函数：</p>
<script type="math/tex; mode=display">
P_0+P_1z+P_2z^2+...+P_Nz^N\\
=(1-p_1+p_1z)(1-p_2+p2_z)...(1-p_N+p_Nz) \tag{2}</script><p>其中$P_n$表示$Pr\{Y=n\}$</p>
<p>公式(2)的右边稍微改动一下可得：</p>
<script type="math/tex; mode=display">
P_0+P_1z+P_2z^2+...+P_Nz^N\\
=\alpha(z-s_1)(z-s_2)...(z-s_N) \tag{3a}</script><p>其中</p>
<script type="math/tex; mode=display">
\alpha = \prod_{k=1}^N P_k \tag{3b}</script><script type="math/tex; mode=display">
s_k = -(1-p_k)/p_k \tag{3c}</script><p>上述过程用matlab可以写成：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[P,Q]</span>=<span class="title">ProbMofN</span><span class="params">(p)</span></span></span><br><span class="line"><span class="comment">% 给定N个元素的向量p，它表示N个独立重复实验的成功概率，该函数的返回值包括：</span></span><br><span class="line"><span class="comment">% P：N+1个元素，表示0次成功、1次成功、2次成功...N次成功（泊松-二项式的pdf）</span></span><br><span class="line"><span class="comment">% Q：N+1个元素，表示至少0次成功、至少1次成功、...、至少N次成功的概率（泊松-二项式的cdf）</span></span><br><span class="line">p(p==<span class="number">0</span>)=[];    <span class="comment">% 消除等于0的元素</span></span><br><span class="line">n=<span class="built_in">length</span>(p);</span><br><span class="line">alpha=prob(p);</span><br><span class="line">s=-(<span class="number">1</span>-p)./p;</span><br><span class="line">S=poly(s); <span class="comment">% S就是根为向量s的多项式的N+1个系数的向量，也就是说，S(1)*x^N+...+S(N)*x+S(N+1)</span></span><br><span class="line"></span><br><span class="line">temp_P=alpha*S;</span><br><span class="line">temp_Q=cumsum(temp_P);</span><br><span class="line"></span><br><span class="line">P=temp_P[N+<span class="number">1</span>:<span class="number">-1</span>:<span class="number">1</span>];</span><br><span class="line">Q=temp_Q[N+<span class="number">1</span>:<span class="number">-1</span>:<span class="number">1</span>];</span><br><span class="line"><span class="comment">%================================</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span>=<span class="title">invProbMofN</span><span class="params">(P)</span></span></span><br><span class="line"><span class="comment">% 给定N个元素的向量P，它表示N次实验后，0次成功、1次成功、...、N次成功的概率，该函数的返回值为：</span></span><br><span class="line"><span class="comment">% p：N个元素的向量，表示每次实验的成功率</span></span><br><span class="line">N1=<span class="built_in">length</span>(P); <span class="comment">% N1=N+1</span></span><br><span class="line">S=P[N1:<span class="number">-1</span>:<span class="number">1</span>]; </span><br><span class="line">s=roots(S); <span class="comment">% s是N个元素的向量，表示生成函数的根</span></span><br><span class="line">p=<span class="number">1.</span>/(<span class="number">1</span>-s); <span class="comment">% p是N个元素的向量，表示每次事件的成功率</span></span><br></pre></td></tr></table></figure>
<p>这样的计算过程虽然很好用，但是在对泊松-二项式pdf进行进一步分析或推导新结论时不太方便。于是本文提出了近似表达式。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>泊松分布</tag>
      </tags>
  </entry>
  <entry>
    <title>Ren&#39;py引擎的使用</title>
    <url>/2021/02/11/Ren-py%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Ren’py引擎的使用"><a href="#Ren’py引擎的使用" class="headerlink" title="Ren’py引擎的使用"></a>Ren’py引擎的使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>Renpy可以在<a href="https://www.renpy.org/" target="_blank" rel="noopener">官方网站</a>下载；</li>
<li>除了安装引擎本身以外，还需要准备python2和python3；</li>
<li>解包游戏文件需要使用python3安装unrpa，命令行中的安装命令为<code>py -3 -m pip install unrpa</code>；</li>
</ol>
<h2 id="制作游戏"><a href="#制作游戏" class="headerlink" title="制作游戏"></a>制作游戏</h2><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><ol>
<li><code>unrpa -mp 目标路径 rpa文件路径</code>即可将rpa文件解包成rpy文件和rpyc文件</li>
</ol>
]]></content>
      <categories>
        <category>Renpy</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>Renpy</tag>
      </tags>
  </entry>
  <entry>
    <title>仙境之夜攻略记录</title>
    <url>/2021/02/11/%E4%BB%99%E5%A2%83%E4%B9%8B%E5%A4%9C%E6%94%BB%E7%95%A5%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="仙境之夜攻略记录"><a href="#仙境之夜攻略记录" class="headerlink" title="仙境之夜攻略记录"></a>仙境之夜攻略记录</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><div class="table-container">
<table>
<thead>
<tr>
<th>中文</th>
<th>英文</th>
<th>编号</th>
</tr>
</thead>
<tbody>
<tr>
<td>白兔</td>
<td>White Rabbit</td>
<td>WR</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>King Claudius of Clubs</td>
<td>KC</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>Queen Catherine of Clubs</td>
<td>QC</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>Countess Jamala of Clubs</td>
<td>JC</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>King David of Diamonds</td>
<td>KD</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>Queen Diana of Diamonds</td>
<td>QD</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>Princess Julie of Diamonds</td>
<td>JD</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>King Harry of Hearts</td>
<td>KH</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>Queen Hera of Hearts</td>
<td>QH</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>Duke Jorge of Hearts</td>
<td>JH</td>
</tr>
<tr>
<td>黑桃国王所罗门</td>
<td>King Solomon of Spades</td>
<td>KS</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>Queen Sarah of Spades</td>
<td>QS</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>Prince John of Spades</td>
<td>JS</td>
</tr>
<tr>
<td>小丑 柴郡猫</td>
<td>Cheshire Cat, The Joker</td>
<td>JK</td>
</tr>
<tr>
<td>外来者 爱丽丝</td>
<td>Alice, The Outsider</td>
<td>A</td>
</tr>
</tbody>
</table>
</div>
<h3 id="活动喜好"><a href="#活动喜好" class="headerlink" title="活动喜好"></a>活动喜好</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>槌球</th>
<th>驯鹰</th>
<th>音乐</th>
<th>马术</th>
<th>下午茶</th>
<th>网球</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>无感</td>
<td>厌恶</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>厌恶</td>
<td>无感</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>喜欢</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>厌恶</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>喜欢</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>厌恶</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
<td>无感</td>
<td>厌恶</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>无感</td>
<td>厌恶</td>
<td>喜欢</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>无感</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>无感</td>
<td>厌恶</td>
<td>喜欢</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>喜欢</td>
<td>无感</td>
<td>厌恶</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>喜欢</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>厌恶</td>
<td>无感</td>
</tr>
</tbody>
</table>
</div>
<h3 id="初始立场"><a href="#初始立场" class="headerlink" title="初始立场"></a>初始立场</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>战争</th>
<th>魔法</th>
<th>贸易</th>
<th>边境</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>有些反对</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>支持</td>
<td>支持</td>
<td>征税</td>
<td>闭关</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>支持</td>
<td>反对</td>
<td>没有主见</td>
<td>开放</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>支持</td>
<td>反对</td>
<td>自由</td>
<td>闭关</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>开放</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>皆可</td>
<td>皆可</td>
<td>自由（强烈）</td>
<td>皆可</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>反对</td>
<td>反对</td>
<td>自由</td>
<td>开放</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>反对</td>
<td>支持</td>
<td>自由</td>
<td>开放</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>反对</td>
<td>支持</td>
<td>自由</td>
<td>开放</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>开放</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>开放</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>支持</td>
<td>反对</td>
<td>自由</td>
<td>闭关</td>
</tr>
</tbody>
</table>
</div>
<h3 id="秘密和对他人的看法"><a href="#秘密和对他人的看法" class="headerlink" title="秘密和对他人的看法"></a>秘密和对他人的看法</h3><p><strong>列人物</strong>对<strong>行人物</strong>的看法，例如第二行第三列“被其支配”表示所罗门对莎拉的看法。行列相同的格子表示这个角色的秘密。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>被妻子的魔法控制了</td>
<td>被其支配</td>
<td>可爱的儿子</td>
<td>不待见对方</td>
<td>友好</td>
<td>互相怀疑</td>
<td>敌对</td>
<td>友好</td>
<td>对我来说也像自己的女儿一样</td>
<td>友好</td>
<td>友好</td>
<td>可疑</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>受控的丈夫</td>
<td>对黑桃蘑菇上瘾</td>
<td>受控的儿子</td>
<td>若意见相同，可以友好相处</td>
<td>无感</td>
<td>互相怀疑</td>
<td>敌对</td>
<td>无感</td>
<td>无感</td>
<td>无感</td>
<td>敌对（姐妹关系）</td>
<td>无感</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>亲爱的父亲</td>
<td>独裁的母亲</td>
<td>和方片公主相爱</td>
<td>很容易操纵我</td>
<td>友好</td>
<td>友好</td>
<td>仰慕</td>
<td>友好</td>
<td>坠入爱河！</td>
<td>有意思的姨丈</td>
<td>有点怕她，但是是个有意思的人</td>
<td>很容易操纵我</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>令人厌恶的蠢蛋</td>
<td>若意见相同，可以友好相处</td>
<td>易操纵</td>
<td>是炸脖龙！</td>
<td>糟糕的婚姻</td>
<td>值得信任</td>
<td>勒索对象</td>
<td>若意见相同，可以友好相处</td>
<td>我想得到她</td>
<td>敌对</td>
<td>敌对</td>
<td>不为人知的弟弟！</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>友好</td>
<td>糟糕的悍妇</td>
<td>可爱的小伙子</td>
<td>可怕的怪物！</td>
<td>不是仙境世界的本地人</td>
<td>值得信任</td>
<td>被领养后遇到的刻薄哥哥</td>
<td>友好</td>
<td>可爱的小姑娘</td>
<td>被领养后遇到的冷漠哥哥</td>
<td>棘手之人</td>
<td>旧爱</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>高度怀疑</td>
<td>高度怀疑</td>
<td>蠢蛋，没有威胁</td>
<td>独裁者，需要遏制他</td>
<td>我会保护她</td>
<td>前任黑桃女王</td>
<td>高度怀疑</td>
<td>高度怀疑</td>
<td>多愁善感的小姑娘，没有威胁</td>
<td>老蠢蛋，没有威胁</td>
<td>太情绪化，没有威胁</td>
<td>高度怀疑</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>敌对</td>
<td>敌对</td>
<td>敌人之子</td>
<td>勒索我的人</td>
<td>与我无关</td>
<td>…谁啊？</td>
<td>他的身体正长出像怪物一样的肿瘤</td>
<td>轻浮的女人，我要控制她！</td>
<td>和她妈太像了</td>
<td>愚蠢的弟弟</td>
<td>我的弟弟很听她的</td>
<td>这家伙是什么立场？</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>应该是我的敌人</td>
<td>令人厌恶的女人</td>
<td>敌人的可爱儿子</td>
<td>可怕的暴君</td>
<td>可爱而不幸的女人</td>
<td>她让我很不自在…</td>
<td>控制狂！</td>
<td>是一名不为人知的女巫</td>
<td>完美！</td>
<td>亲爱的小叔子</td>
<td>让她高兴就对了！</td>
<td>他让我很不自在…</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>应该是我的敌人</td>
<td>令人厌恶的女人</td>
<td>我爱他！</td>
<td>让我害怕的人</td>
<td>可爱的女人，可惜婚姻不幸福</td>
<td>看起来很友好</td>
<td>父王（有点无趣）</td>
<td>完美的母后</td>
<td>和黑桃王子陷入爱河</td>
<td>亲爱的叔叔</td>
<td>亲爱的婶婶（只要不生气）</td>
<td>很有说服力！</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>友好的妹夫</td>
<td>可恨的小姨子</td>
<td>可爱的小侄子</td>
<td>敌人！</td>
<td>可怜的妹妹…</td>
<td>看起来很有涵养</td>
<td>无聊的哥哥</td>
<td>友好的嫂子</td>
<td>可爱的小侄女</td>
<td>偷了妻子的水果塔！</td>
<td>喜怒无常的妻子</td>
<td>值得信任的顾问</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>友好的妹夫</td>
<td>可恨的妹妹</td>
<td>可爱的小侄子</td>
<td>敌人！</td>
<td>可怜又悲惨的女人</td>
<td>有点无聊</td>
<td>大舅子</td>
<td>友好的嫂子</td>
<td>可爱的小侄女</td>
<td>有点无聊的丈夫</td>
<td>和乔治公爵有外遇</td>
<td>情人</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>蠢蛋</td>
<td>糟糕的女人</td>
<td>缺心眼，容易受骗</td>
<td>我的哥哥</td>
<td>我对她还有感情…</td>
<td>她是从哪来的？</td>
<td>试试操纵他</td>
<td>试试操纵她</td>
<td>缺心眼，容易受骗</td>
<td>我的情敌</td>
<td>我爱她！</td>
<td>梅花王国培养他来暗中破坏红心王国</td>
</tr>
</tbody>
</table>
</div>
<h2 id="给自己的提醒"><a href="#给自己的提醒" class="headerlink" title="给自己的提醒"></a>给自己的提醒</h2><h3 id="仙境世界的灾难"><a href="#仙境世界的灾难" class="headerlink" title="仙境世界的灾难"></a>仙境世界的灾难</h3><p>如果克劳狄斯王和所罗门王、莎拉王后、戴安娜王后及赫拉女王碰面，会发生什么事？大卫王似乎想深入了解约翰王子</p>
<p>如果克劳狄斯王和所罗门王、莎拉王后、戴安娜王后及赫拉女王碰面，会发生什么事？（大卫王和约翰王子没有谈话过）</p>
<p>克劳狄斯王想见大卫王和朱莉公主。</p>
<h3 id="黑桃王国的命运"><a href="#黑桃王国的命运" class="headerlink" title="黑桃王国的命运"></a>黑桃王国的命运</h3><p>贾马拉女伯爵想见戴安娜王后、大卫王和莎拉王后。其中的一位在压力之下是个脆弱的突破点。</p>
<p>如果贾马拉女伯爵在试探过戴安娜王后、大卫王和莎拉王后之后和所罗门王谈话，会发生什么？</p>
<p>所罗门王和约翰王子需要和对方谈话，并与戴安娜王后和凯瑟琳王后谈话。</p>
<p>如果所罗门王与赫拉女王见面两次后，和莎拉王后进行了谈话，会发生什么…</p>
<h3 id="红心王国的故事"><a href="#红心王国的故事" class="headerlink" title="红心王国的故事"></a>红心王国的故事</h3><p>如果乔治公爵和赫拉女王整个峰会都待在一起会发生什么事？</p>
<p>如果莎拉王后和亨利王谈话，然后然后和赫拉女王见面，并且她们两位都与乔治公爵对话，会发生什么？</p>
<p>赫拉女王托贾马拉女伯爵调查亨利王、约翰王子和乔治公爵。</p>
<p>也许克劳狄斯王、朱莉公主和大卫王会鼓励亨利王做出新的尝试。</p>
<h3 id="梅花王国的阴谋"><a href="#梅花王国的阴谋" class="headerlink" title="梅花王国的阴谋"></a>梅花王国的阴谋</h3><p>如果整个峰会期间，克劳狄斯王和乔治公爵都被安排在一起，会发生什么事？</p>
<p>如果克劳狄斯王和凯瑟琳见面，然后向大卫王或贾马拉女伯爵抱怨对方，会发生什么？对了，必须有另一个步骤…</p>
<p>如果凯瑟琳王后和乔治公爵整个峰会期间都待在一块会发生什么事？</p>
<h3 id="方片王国的审判"><a href="#方片王国的审判" class="headerlink" title="方片王国的审判"></a>方片王国的审判</h3><p>大卫王想同所罗门王和莎拉王后和平谈判，但是他也许需要向乔治公爵寻求帮助。</p>
<p>如果戴安娜王后无法付清乔治公爵索要的钱款，会发生什么？</p>
<h3 id="年轻的人儿"><a href="#年轻的人儿" class="headerlink" title="年轻的人儿"></a>年轻的人儿</h3><p>如果克劳狄斯王和大卫王全程都被安排在一块会发生什么？</p>
<p>为约翰王子和朱莉公主向富有的贵族寻求帮助。</p>
<p>如果乔治公爵和约翰王子及朱莉公主相处时间相同，会发生什么？</p>
<p>约翰王子似乎有个工作机会。他应该与他的母亲和克劳狄斯王对话。所罗门王应该和乔治公爵谈谈。</p>
<p>黑桃王国的国王和王后以及梅花王国的王后和女伯爵似乎对朱莉公主有兴趣。</p>
<h3 id="外来者"><a href="#外来者" class="headerlink" title="外来者"></a>外来者</h3><p>如果整个峰会期间，莎拉王后和凯瑟琳王后都被安排在一块，会发生什么？</p>
<p>凯瑟琳王后与贾马拉女伯爵一道，需要从大卫王那里拿到花园钥匙，并从乔治公爵那里拿到魔法玫瑰。</p>
<p>赫拉女王想见大卫王、亨利王、约翰王子和凯瑟琳王后。</p>
<h2 id="每天开始时的反应"><a href="#每天开始时的反应" class="headerlink" title="每天开始时的反应"></a>每天开始时的反应</h2><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><ol>
<li>战争没通过，红心女王会表示满意；否则，红心女王会表示不高兴。</li>
<li>满意值大于等于6，红心女王会满意；没过半但大于等于0，红心女王会表现得中性；否则，会生气。</li>
<li>红心女王会对水果塔丢失而感到生气。</li>
</ol>
<h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><ol>
<li>魔法通过，红心女王满意。</li>
<li>满意值大于等于12，红心女王会满意；大于等于0，中性；反之，生气。</li>
<li>继续生气水果塔。</li>
</ol>
<h3 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h3><ol>
<li>贸易没通过，会满意。</li>
<li>满意值大于等于18，会高兴；大于等于0，中性；反之，生气。</li>
<li>继续生气水果塔。</li>
</ol>
<h2 id="每天活动安排的影响"><a href="#每天活动安排的影响" class="headerlink" title="每天活动安排的影响"></a>每天活动安排的影响</h2><p>满意值（satisfaction）初始为0</p>
<p>投票值初始：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>战争</th>
<th>魔法</th>
<th>贸易</th>
<th>边境</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>接下来每天的表格种：</p>
<ol>
<li><p>表格中空白表示这个组合只有对话，没有满意值和投票值的变化</p>
</li>
<li><p>表格中-表示该值不存在或者有对称组合，比如<code>（所罗门，莎拉）</code>和<code>（莎拉，所罗门）</code>是同一个组合，前者写了影响，后者就是-了</p>
</li>
</ol>
<p>除了这些表格以外，每个人对应的活动项目，如果是喜欢，则满意值+1，厌恶，则满意值-1，无感则无变化</p>
<p>任意两个角色组合的初始值为1，每安排到一起一次，该组合的值+1，第四次不会增加（例如，KCQC表示克劳狄斯和凯瑟琳的组合，在结局判定时，KCQC=1表示没有安排在一起过，KCQC=2表示安排了一次，KCQC=3表示两次，KCQC=4表示三次，KCQC=5表示四次；此外有一些组合，代码里没有在第四次的时候+1，也就是说=4表示3次或4次，不过对于最后判定没有影响。）</p>
<h3 id="人物组合的影响"><a href="#人物组合的影响" class="headerlink" title="人物组合的影响"></a>人物组合的影响</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>组合第1次时，所罗门的秘密曝光</td>
<td>组合第1次时，所罗门和戴安娜的秘密曝光</td>
<td></td>
<td></td>
<td>组合第1次时，如果贾马拉和莎拉、大卫、戴安娜都组合过1次，贾马拉的秘密曝光</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>组合第1次时，莎拉的秘密曝光，</td>
<td></td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td>组合第2次时，凯瑟琳的秘密曝光</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>组合第1次时，约翰和朱莉的秘密曝光</td>
<td>组合第4次时，亨利的秘密曝光</td>
<td></td>
<td>组合第1次时，约翰和朱莉的秘密曝光</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>组合第4次时，满意值减10</td>
<td>组合第4次时，<code>talkaboutclubs == 1 and kingconvinced == 0</code>不成立时，乔治的秘密曝光</td>
<td>组合第1次时，克劳狄斯的秘密曝光；组合第4次时，大卫的秘密曝光</td>
<td></td>
<td>组合第3次时，乔治的秘密曝光</td>
<td>组合第4次时，亨利的秘密曝光</td>
<td>组合第4次时，满意值减10</td>
<td>组合第1次且魔法没通过时，乔治的秘密曝光</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>组合第1次，凯瑟琳的秘密曝光</td>
<td></td>
<td></td>
<td></td>
<td>组合第4次时，凯瑟琳的秘密曝光</td>
<td></td>
<td></td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td>组合第2次时，贾马拉和戴安娜的秘密都曝光</td>
<td></td>
<td></td>
<td></td>
<td>组合第2次时，乔治的秘密曝光</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td>组合第4次时，如果<code>dianahaspayment!=0</code>，亨利的秘密曝光</td>
<td></td>
<td>组合第1次时，戴安娜的秘密曝光</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>组合第4次时，约翰和朱莉的秘密曝光</td>
<td></td>
<td>组合第1次时，约翰和朱莉的秘密曝光</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第一天（战争）"><a href="#第一天（战争）" class="headerlink" title="第一天（战争）"></a>第一天（战争）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>KS投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 0</td>
<td>KS投票值 1 KD投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>QC投票值 1 满意值-1</td>
<td>JC投票值 0 满意值-1</td>
<td>满意值-1</td>
<td>空</td>
<td>JD投票值 1 满意值+1</td>
<td>KH投票值 1 满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JS投票值 1 满意值+1</td>
<td>QC投票值 1 满意值+1</td>
<td>JC投票值 1</td>
<td>满意值+1</td>
<td>QD投票值 1 满意值+1</td>
<td>JD投票值 1 满意值+1</td>
<td>KH投票值 1 满意值+1</td>
<td>QH投票值 1 满意值+1</td>
<td>JS投票值 1</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 1; 满意值-1</td>
<td>JC投票值 1 满意值+1</td>
<td>KD投票值 1</td>
<td>QD投票值 1</td>
<td>JD投票值 1</td>
<td>KH投票值 1 满意值-1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 0 满意值+1</td>
<td>空</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>QC投票值 1 满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值-1</td>
<td>JC投票值 0</td>
<td>JC投票值 0</td>
<td>JC投票值 0</td>
<td>JC投票值 0</td>
<td>JC投票值 1 满意值-1</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>空</td>
<td>空</td>
<td>满意值+1</td>
<td>JH投票值 0</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>QD投票值 1</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>JD投票值 1</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JH投票值 0 满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第二天（魔法）"><a href="#第二天（魔法）" class="headerlink" title="第二天（魔法）"></a>第二天（魔法）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>满意值-1</td>
<td>JS投票值 0 满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 1</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值-1</td>
<td>空</td>
<td>满意值-1</td>
<td>JC投票值 0 满意值-1</td>
<td>满意值-1</td>
<td>空</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>JH投票值 1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>QC投票值 0 满意值+1</td>
<td>JC投票值 0</td>
<td>私奔flag+1 满意值+1</td>
<td>QD投票值 0 满意值+1</td>
<td>JD投票值 0 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>QH投票值 0 满意值+1</td>
<td></td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 0 满意值-1</td>
<td>JC投票值 0 满意值+1</td>
<td>空</td>
<td>QD投票值 0</td>
<td>JD投票值 0</td>
<td>满意值-1</td>
<td>QH投票值 0 满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值+1</td>
<td>QC投票值 0</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>JH投票值 1 满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值-1</td>
<td>JC投票值 0 JD投票值 0（这里看对话应该是JC投票值 1 QD投票值 0，怀疑是写错了）</td>
<td>JC投票值 0 JD投票值 0</td>
<td>JC投票值 1</td>
<td>JC投票值 1</td>
<td>JC投票值 0</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QD投票值 0</td>
<td>JD投票值 0</td>
<td>KH投票值 0</td>
<td>QH投票值 0</td>
<td>空</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>QD投票值 0</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>QH投票值 0 JD投票值 0 满意值+1</td>
<td>JD投票值 0</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JH投票值 0 QH投票值 0 满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第三天（贸易）"><a href="#第三天（贸易）" class="headerlink" title="第三天（贸易）"></a>第三天（贸易）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>满意值-1</td>
<td>JS投票值 0 满意值+1</td>
<td>KC投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 0</td>
<td>KD投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>JD投票值 0 满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值-1</td>
<td>KC投票值 0</td>
<td>满意值-1</td>
<td>JC投票值 1 满意值-1</td>
<td>KD投票值 0 满意值-1</td>
<td>空</td>
<td>JD投票值 0 满意值+1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JS投票值 1 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>JS投票值 1</td>
<td>私奔flag+1 满意值+1 JS投票值 1</td>
<td>JS投票值 1 满意值+1</td>
<td>JS投票值 1 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>JS投票值 1</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>空</td>
<td>KC投票值 0 满意值-1</td>
<td>KC投票值 0 满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 1 满意值+1</td>
<td>空</td>
<td>QC投票值 1 满意值+1</td>
<td>JD投票值 0 满意值+1</td>
<td>空</td>
<td>空</td>
<td>JH投票值 0 满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值-1</td>
<td>JC投票值 1</td>
<td>JC投票值 1</td>
<td>KH投票值 1</td>
<td>JC投票值 1</td>
<td>JC投票值 1 满意值-1</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>空</td>
<td>KH投票值 1</td>
<td>KD投票值 0</td>
<td></td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>QD投票值 0 满意值+1</td>
<td>空</td>
<td>JH投票值 1</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JD投票值 0 满意值+1</td>
<td>JD投票值 0  满意值+1</td>
<td>JD投票值 1</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>KH投票值 1 满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第四天（边境）"><a href="#第四天（边境）" class="headerlink" title="第四天（边境）"></a>第四天（边境）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>KS投票值 0 满意值-1</td>
<td>KS投票值 0 JS投票值 0 满意值+1</td>
<td>KS投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 0 KS投票值 0 满意值-1</td>
<td>KS投票值 0 KD投票值 0 满意值-1</td>
<td>KS投票值 0 QD投票值 0  满意值+1</td>
<td>满意值+1</td>
<td>KH投票值 0 KS投票值 0 满意值+1</td>
<td>满意值+1</td>
<td>KS投票值 0</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>JC投票值 1 满意值-1</td>
<td>KD投票值 0 满意值-1</td>
<td>QD投票值 0</td>
<td>满意值+1</td>
<td>KH投票值 0 满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值+1</td>
<td>私奔flag+1 满意值+1</td>
<td>JS投票值 0</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>JS投票值 0</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>KD投票值 0</td>
<td>QD投票值 0</td>
<td>空</td>
<td>KH投票值 0 满意值-1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值+1</td>
<td>空</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 0 满意值-1</td>
<td>QD投票值 0</td>
<td>JC投票值 1</td>
<td>JC投票值 0 KH投票值 0</td>
<td>JC投票值 1</td>
<td>满意值-1</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>空</td>
<td>空</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>QD投票值 0</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>KH投票值 0 满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="每晚投票"><a href="#每晚投票" class="headerlink" title="每晚投票"></a>每晚投票</h2><p>如果大于等于7票，就通过；小于等于5票，就不通过；恰好是6票，柴郡猫投票。</p>
<p>柴郡猫投票的结果：战争不通过；魔法通过；贸易自由；开放边境通过。</p>
<h2 id="最终结局"><a href="#最终结局" class="headerlink" title="最终结局"></a>最终结局</h2><p>”皇室成员聚集在一起，这是他们最后一个可以互相交流的晚上了。“</p>
<p>以下结局在条件不冲突的情况下可同时达成。</p>
<h3 id="炸脖龙结局"><a href="#炸脖龙结局" class="headerlink" title="炸脖龙结局"></a>炸脖龙结局</h3><p>结局1：克劳狄斯与所罗门、莎拉、戴安娜、赫拉各组合过一次</p>
<p>分支1：约翰和大卫组合过两次及以上</p>
<p>约翰王子杀了龙，然后大卫王提议约翰继位当梅花的国王。</p>
<p>分支2：不满足分支1的条件</p>
<p>大卫王杀了龙，但是龙死前划破他的衣服，他自己被龙诅咒的事实也被发现了，于是只能放弃王位，朱莉继位。</p>
<p>结局2：克劳狄斯与大卫组合过两次、与朱莉组合过两次</p>
<p>克劳狄斯变成龙，抢走朱莉，约翰王子和他父亲一起去营救。</p>
<h3 id="贾马拉结局"><a href="#贾马拉结局" class="headerlink" title="贾马拉结局"></a>贾马拉结局</h3><p>结局1：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成）炸脖龙结局1的分支2没有达成（朱莉没继位）</p>
<p>要求：贾马拉与戴安娜、大卫各组合过1次，与莎拉组合过2次</p>
<p>戴安娜坦白她当初参与刺杀贾马拉的事情，贾马拉在其的帮助下找到了另外两个当初刺杀她的人（大卫和莎拉），并把他们用魔法锁起来了。</p>
<p>结局2：贾马拉与所罗门第一次组合时，已经与戴安娜、大卫、莎拉各组合过1次</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 炸脖龙结局1的分支2没有达成（朱莉没继位）</p>
<p>贾马拉在所罗门的帮助下找到当初刺杀自己的三个人，并把他们用魔法锁起来了。同时为了感谢和补偿所罗门，他俩结婚了。</p>
<h3 id="黑桃结局"><a href="#黑桃结局" class="headerlink" title="黑桃结局"></a>黑桃结局</h3><p>结局1：所罗门逃离了莎拉的控制</p>
<p>炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王）</p>
<p>要求：这个条件实在太复杂了我不想思考了…</p>
<p>结局2：所罗门和莎拉相互洗脑（他发现了她对蘑菇上瘾）</p>
<p>要求：所罗门和莎拉第2次组合时，所罗门和赫拉已经组合2次了。</p>
<h3 id="约翰和朱莉的结局"><a href="#约翰和朱莉的结局" class="headerlink" title="约翰和朱莉的结局"></a>约翰和朱莉的结局</h3><p>结局1：朱莉与克劳迪斯订婚，凯瑟琳离婚了</p>
<p>要求：克劳狄斯与大卫组合4次，炸脖龙结局1的分支2没有达成（朱莉没继位） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）</p>
<p>结局2：俩人私奔</p>
<p>要求：这个条件很多种组合懒得写了（是要约翰和朱莉凑够至少4份钱，给钱的一共有9种情况） 或 炸脖龙结局1的分支2达成（朱莉继位） 或 炸脖龙结局1的分支1达成（约翰继位），且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 克劳狄斯与大卫组合少于4次</p>
<p>该结局三个分支：</p>
<ol>
<li>炸脖龙结局1的分支2达成（朱莉继位）</li>
<li>炸脖龙结局1的分支1达成（约翰继位）</li>
<li>不符合前两条</li>
</ol>
<p>结局3：俩人相爱</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成）, 炸脖龙结局1的分支1没有达成（约翰没继位）,炸脖龙结局1的分支2没有达成（朱莉没继位）, 约翰与乔治组合2次， 且 朱莉与乔治组合2次， 且 这个条件很多种组合懒得写了（是要约翰和朱莉没凑够4份钱，给钱的一共有9种情况）</p>
<h3 id="红心结局"><a href="#红心结局" class="headerlink" title="红心结局"></a>红心结局</h3><p>结局1：亨利被谋杀， 赫拉和乔治私奔</p>
<p>要求：赫拉与乔治组合4次</p>
<p>结局2：赫拉和乔治的私情曝光，触发女王死亡结局（见下文）</p>
<p>要求：<code>affairrevealed == 2</code> 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王）且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）</p>
<p>结局3：亨利偷水果塔的事情曝光</p>
<p>要求：<code>investigatedJCJS == 1 and investigatedJCKH == 1 and investigatedJCJH == 1</code></p>
<h3 id="其他结局"><a href="#其他结局" class="headerlink" title="其他结局"></a>其他结局</h3><p>结局1：乔治和克劳狄斯政变，触发女王死亡结局（见下文）</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 炸脖龙结局1的分支2没有达成（朱莉没继位） 且 炸脖龙结局1的分支1没有达成（约翰没继位）, 且 克劳狄斯与乔治组合4次， 且 魔法没通过</p>
<p>结局2：戴安娜被赶走</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 炸脖龙结局1的分支2没有达成（朱莉没继位） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）, 且<code>dianablackmail != 0</code></p>
<p>结局3：约翰去梅花王国居住</p>
<p>要求：克劳狄斯没有与所罗门、莎拉、戴安娜、赫拉各组合过一次 且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 克劳狄斯与大卫组合不到4次，且 这个条件很多种组合懒得写了（是要约翰和朱莉没凑够4份钱，给钱的一共有9种情况）,且 所罗门与乔治组合至少1次， 且莎拉与约翰组合至少1次， 且克劳狄斯与约翰组合至少1次</p>
<p>结局4：朱莉被训练为先知</p>
<p>要求：克劳狄斯没有与所罗门、莎拉、戴安娜、赫拉各组合过一次 且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且克劳狄斯与大卫组合不到4次 且 这个条件很多种组合懒得写了（是要约翰和朱莉没凑够4份钱，给钱的一共有9种情况） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）, 且 朱莉与凯瑟琳、贾马拉、所罗门、莎拉各组合1次</p>
<p>结局5：黑桃和方片休战</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成）且 炸脖龙结局1的分支2没有达成（朱莉没继位） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算，且 大卫与所罗门、莎拉、乔治 都至少组合1次</p>
<p>结局6：克劳狄斯和凯瑟琳婚姻咨询</p>
<p>要求：<code>johnarmed == 0</code> 且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） and 炸脖龙结局1的分支2没有达成（朱莉没继位）且克劳狄斯与大卫组合不到4次, <code>kingconvinced == 1 and queenconvinced == 1</code></p>
<p>结局7：红心王国开公共图书馆</p>
<p>要求：赫拉与乔治没有组合4次，且克劳狄斯与亨利组合至少1次，且大卫与亨利组合至少1次，且约翰与亨利组合至少1次，且 <code>investigatedJCKH == 0</code></p>
<h3 id="外来者结局"><a href="#外来者结局" class="headerlink" title="外来者结局"></a>外来者结局</h3><p>结局1：凯瑟琳和乔治一起跑了</p>
<p>要求：凯瑟琳与乔治组合4次</p>
<p>结局2：凯瑟琳和爱丽丝出现，赫拉心脏病发作，触发女王死亡结局（见下文）</p>
<p>要求：凯瑟琳和莎拉组合4次 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王）且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）</p>
<p>结局3：凯瑟琳和爱丽丝跑了</p>
<p>要求：<code>therapy == 0</code>，<code>solomonthief == 2 and magicrose == 1</code></p>
<p>结局4：赫拉发现了爱丽丝，爱丽丝被杀了</p>
<p>要求：<code>solomonthief != 2 and magicrose != 1</code>,大卫与赫拉组合1次 且 亨利与赫拉组合1次 且 约翰与赫拉组合1次 且 凯瑟琳与赫拉组合1次</p>
<h3 id="兔子结局"><a href="#兔子结局" class="headerlink" title="兔子结局"></a>兔子结局</h3><p>满意值&gt;=48:</p>
<p>分支1：战争和自由贸易没通过，魔法和开放边境通过了</p>
<p>分支2：战争和自由贸易通过了，魔法和开放边境没通过</p>
<p>分支3：不满足前面两个</p>
<p>满意值&gt;=-19，且&lt;=47：</p>
<p>分支1：战争和自由贸易没通过，魔法和开放边境通过了</p>
<p>分支2：战争和自由贸易通过了，魔法和开放边境没通过</p>
<p>分支3：不满足前面两个</p>
<p>满意值&lt;=-20</p>
<p>分支1：战争和自由贸易没通过，魔法和开放边境通过了</p>
<p>分支2：不满足上面那个</p>
<h3 id="女王死亡结局"><a href="#女王死亡结局" class="headerlink" title="女王死亡结局"></a>女王死亡结局</h3><p>根据满意值不同，兔子可能会失业。</p>
<h3 id="世界结局"><a href="#世界结局" class="headerlink" title="世界结局"></a>世界结局</h3><p><code>war == 0 and magic == 0 and trade == 0 and borders == 0</code></p>
<p>“四个议题都被否定了，因此，那年仙境世界什么都没发生。”</p>
<p>“没有战争，人民生活还算太平。但是禁止魔法，贸易不自由，边境封锁，导致许多物资匮乏。”</p>
<p>“这是生活艰苦的一年。”</p>
<p><code>war == 1 and magic == 0 and trade == 0 and borders == 0</code></p>
<p>“这一年，只有战争通过了。对于仙境世界较为弱小的国家来说，生活艰难。”</p>
<p>“你必须大量学习，才能找到在这个全新的世界里生存的办法。”</p>
<p>“未来的走向应该会很有意思…”</p>
<p><code>war == 0 and magic == 1 and trade == 0 and borders == 0</code></p>
<p>“这一年，只有魔法通过了，仙境世界到处都是神奇的动物和植物。”</p>
<p>“这会是奇妙的一年…”</p>
<p><code>war == 0 and magic == 0 and trade == 1 and borders == 0</code></p>
<p>“这一年，只有自由贸易通过了，仙境世界的市场情况像坐过山车紧张刺激。”</p>
<p>“幸运的是，这一年你似乎赚得盆钵体满。”</p>
<p><code>war == 0 and magic == 0 and trade == 0 and borders == 1</code></p>
<p>“这一年，只有边境允许开放，除了四处旅行，没有什么可以打发时间的事可以做。”</p>
<p>“趁着边境开放，你和许多仙境世界的游客一样，四处旅行，欣赏美景。”</p>
<p>“这会是马不停蹄的一年！”</p>
<p><code>war == 1 and magic == 1 and trade == 0 and borders == 0</code></p>
<p>“由于通过了战争和魔法，黑桃王国逐渐站上巅峰地位。”</p>
<p>“你和许多民众都移民到了这处于胜利地位的国家。”</p>
<p>“明年还会不会举行峰会呢？没人说得准。”</p>
<p><code>war == 1 and magic == 0 and trade == 1 and borders == 0</code></p>
<p>“由于通过了战争和自由贸易，梅花王国逐渐站上巅峰地位。”</p>
<p>“红心王国被占领后，你成了胜利国接纳的难民。”</p>
<p>“如果其他国家都被征服了，也许就不会再举办任何峰会了…”</p>
<p><code>war == 1 and magic == 0 and trade == 0 and borders == 1</code></p>
<p>“随着战争和边境的开放，生活发生了翻天覆地的变化。”</p>
<p>“你不得不适应暗无天日的生活，与一群衣衫褴褛的宫殿侍卫和仆人待在一起。”</p>
<p>“明年还有可能再次召开峰会吗？”</p>
<p><code>war == 0 and magic == 1 and trade == 1 and borders == 0</code></p>
<p>“随着魔法和自由贸易的开放，蘑菇交易欣欣向荣。”</p>
<p>“有些蘑菇能让你变大，有些蘑菇能让你变小，还有一些能够增强魔法，似乎每个人都在吃蘑菇。”</p>
<p>“明年还会有人理智犹存，担起组织峰会的大任吗？”</p>
<p><code>war == 0 and magic == 1 and trade == 0 and borders == 1</code></p>
<p>“随着魔法和边界的开放，红心王国的生活顺风顺水。”</p>
<p>“每个人都对你很满意，你也成了茶会必不可少的点心师。”</p>
<p>“希望明年你还能把事情安排得这么好。”</p>
<p><code>war == 0 and magic == 0 and trade == 1 and borders == 1</code></p>
<p>“随着自由贸易和边境的开放，方片王国正在崛起。”</p>
<p>“由于你出色的组织能力，方片王国把你挖走了。”</p>
<p>“也许明年的峰会可以在这里的寒冬宫殿举行。”</p>
<p><code>war == 1 and magic == 1 and trade == 1 and borders == 0</code></p>
<p>“除了边境，其他议题都通过了。四个国家都对国家边境地区格外警戒。”</p>
<p>“对于仙境世界的所有人来说，这是个孤立贫穷的时代。围墙四起，大陆被割据成四个部分。”</p>
<p>“明年，国家之间是否还会有足够的信任，来举行峰会？”</p>
<p><code>war == 1 and magic == 1 and trade == 0 and borders == 1</code></p>
<p>“除了自由贸易，其他议题都通过了。王国陷入一片混乱。”</p>
<p>“没有一处安全之处能够落脚！”</p>
<p>“今年你能不能生存下来都是个问题。”</p>
<p><code>war == 1 and magic == 0 and trade == 1 and borders == 1</code></p>
<p>“除了魔法，其他议题都通过了，日子似乎少了点什么…”</p>
<p>“这一整年，你都躲在地洞里。”</p>
<p>“明年还会有峰会吗？峰会是什么？沟通又是什么？蛤？…”</p>
<p><code>war == 0 and magic == 1 and trade == 1 and borders == 1</code></p>
<p>“除了战争，其他议题都通过了，仙境世界的人民大多誉你为英雄。”</p>
<p>“你成为最知名的人物，久负盛誉，礼物纷至沓来。”</p>
<p>“希望将来的峰会也能进行得像今年这么顺利。”</p>
<p><code>war == 1 and magic == 1 and trade == 1 and borders == 1</code></p>
<p>“所有议题都通过了，仙境世界顿时变得忙碌了起来。”</p>
<p>“由于你的组织能力，你被推上一个举足轻重的职位——红心王国国防部长。”</p>
<p>“虽然已经能看到今年会有多艰难，但是也会很有意思。”</p>
]]></content>
      <categories>
        <category>Renpy</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>仙境之夜</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-8</title>
    <url>/2021/01/06/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-8/</url>
    <content><![CDATA[<h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1><ol>
<li><p><code>flag</code>的作用是对人物或者事件进行标记，可以用在<code>if</code>或<code>trigger</code>或其他类似的地方，而其中人物对应的<code>flag</code>就是<code>character_flag</code>。</p>
</li>
<li><p>我们使用<code>add_character_flag</code>来添加一个人物标记，用<code>remove_character_flag</code>移除一个人物标记。</p>
</li>
<li><p>接下来看一个例子：有两个事件，其中事件1001有2个选项，选项a和b分别会给人物添加两个不同的<code>flag</code>，2个选项都会触发事件1002；而事件1002则有1个选项，根据事件1中的两个<code>flag</code>，该选项会显示不同的内容。那么代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; adventure</span><br><span class="line">adventure.1001 &#x3D; &#123;</span><br><span class="line">    type &#x3D; character_event</span><br><span class="line">	title &#x3D; adventure.1001.t1</span><br><span class="line">	desc &#x3D; adventure.1001.desc</span><br><span class="line">	theme &#x3D; adventure</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.a</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_1</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.b</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_2</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">adventure.1002 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; adventure.1002.t1</span><br><span class="line">	desc &#x3D; adventure.1002.desc1</span><br><span class="line">	theme &#x3D; adventure</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;has_character_flag &#x3D;flag_adventure_random_1&#125;</span><br><span class="line">			text &#x3D; adventure.1002.option.a</span><br><span class="line">		&#125;</span><br><span class="line">		name &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;has_character_flag &#x3D; flag_adventure_random_2&#125;</span><br><span class="line">			text &#x3D; adventure.1002.option.b</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flag</code>的基础用法大致就是这样，除了<code>character_flag</code>也还有其他类型的<code>flag</code>。</p>
</li>
</ol>
<h1 id="modifier"><a href="#modifier" class="headerlink" title="modifier"></a>modifier</h1><ol>
<li><p><code>modifier</code>可以理解为对数值的修正，和特质有点像，但结构和功能简单一些。</p>
</li>
<li><p><code>modifier</code>的基础结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modifer_key &#x3D; &#123;</span><br><span class="line">	icon &#x3D; icon_name	</span><br><span class="line">	# Effects, such as</span><br><span class="line">	# tax_mult &#x3D; 0.25</span><br><span class="line">	# county_opinion_add &#x3D; -30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>icon</code> 的文件名如果以<code>positive</code>或<code>negative</code>结尾，则该<code>modifier</code>的颜色会有相应的变化（指游戏里那行字的颜色），例如<code>diplomacy_positive</code>和<code>diplomacy_negative</code>。</p>
</li>
<li><p>在写好一个<code>modifier</code>之后，我们可以使用<code>add_character_modifier = XXX</code>来给角色添加<code>modifier</code>，使用<code>has_character_modifier = XXX</code>来判断角色是否有该<code>modifier</code>，使用<code>remove_character_character_modifier = XXX</code>来移除一个角色的某个<code>modifier</code>。在添加的时候，可以加时间字段来限制该<code>modifier</code>的持续时间，前面部分中的<code>flag</code>也是同样的用法。</p>
</li>
<li><p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># modifier file</span><br><span class="line">adventure_diplomacy_add_modifier &#x3D; &#123;</span><br><span class="line">	icon &#x3D; diplomacy_positive</span><br><span class="line">	diplomacy &#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># event file</span><br><span class="line">trigger &#x3D; &#123;</span><br><span class="line">	has_character_flag &#x3D; flag_adventure_diplomacy</span><br><span class="line">	NOT &#x3D; &#123; has_character_modifier &#x3D; adventure_diplomacy_add_modifier &#125;</span><br><span class="line">&#125;</span><br><span class="line">send_interface_message &#x3D; &#123;</span><br><span class="line">	type &#x3D; adventure_success_type</span><br><span class="line">	add_character_modifier &#x3D; &#123;</span><br><span class="line">		modifier &#x3D; adventure_diplomacy_add_modifier</span><br><span class="line">		years &#x3D; 20</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>modifier</code>的作用是让角色外交+2，在事件中，判断该角色有相应的<code>flag</code>且没有该<code>modifier</code>时，就给角色增加该<code>modifier</code>，且持续20年。</p>
</li>
<li><p>需要注意的是，我们无法在mod中直接修改角色的健康，只能通过<code>trait</code>或者<code>modifier</code>这样的方式来修改；类似地，角色的五个属性值也不能直接通过<code>diplomacy = 1</code>或者<code>add_diplomacy = 1</code>这样的方式来改，而是要通过<code>trait</code>或<code>modifier</code>修正（实际上，一定要改角色的属性值时，可以使用<code>add_diplomacy_skill = 1</code>这样的代码，但是一般不建议这么做，因为这样改完全看不出来数值是因为什么事件发生了变化，也不利于后续取消这个改变）。</p>
</li>
</ol>
<h1 id="customizable-localization"><a href="#customizable-localization" class="headerlink" title="customizable_localization"></a>customizable_localization</h1><ol>
<li><p>起因是想了解如何随机显示出现的文字，例如某事件的标题随机显示。试图使用<code>random_list</code>等方式都没用，在论坛提问以后大佬告诉我可以用<code>customizable_localization</code>来实现。学习了一下大致写法如下。</p>
</li>
<li><p>首先，文件夹路径是<code>Crusader Kings III\game\common\customizable_localization</code>，该文件夹中有很多已经写好的文件。</p>
</li>
<li><p>其次，相关的本地化文件夹路径是<code>Crusader Kings III\game\localization\simp_chinese\custom_localization</code>。</p>
</li>
<li><p>一个普通的<code>customizable_localization</code>文件格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YourCustomLoc &#x3D; &#123;</span><br><span class="line">    type &#x3D; character </span><br><span class="line">    random_valid &#x3D; yes</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        trigger &#x3D; &#123;  </span><br><span class="line">            your_triggers &#x3D; yes</span><br><span class="line">        &#125;</span><br><span class="line">        localization_key &#x3D; title_1</span><br><span class="line">    &#125;</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        trigger &#x3D; &#123;  </span><br><span class="line">            your_triggers &#x3D; no</span><br><span class="line">        &#125;</span><br><span class="line">        localization_key &#x3D; title_2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>type</code>可以有其他选项，具体选项在<code>CUSTOM_LOC_README.txt</code>文件中列出了。</p>
<p><code>random_valid</code>表示随机选，如果去掉这行就不随机了，而是按顺序第一个满足条件的文本。</p>
<p>接下来的<code>text</code>块就是待选的随机文本，其中<code>trigger</code>是该文本的触发条件，如果没有条件则可以不写<code>trigger</code>块。<code>localization_key</code>所对应的文字是在前面第3条提到的路径中。</p>
</li>
<li><p>在使用该随机文本的时候，例如我们要让某事件的标题随机出现，则把该标题所对应的本地化字符串写成<code>&quot;[ROOT.Char.Custom(&#39;YourCustomLoc&#39;)]&quot;</code></p>
</li>
<li><p>具体来看一个例子：</p>
<ol>
<li><p><code>common\customizable_localization\00_test_random_loc.txt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YourCustomLoc &#x3D; &#123;</span><br><span class="line">    type &#x3D; character</span><br><span class="line">    random_valid &#x3D; yes</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        localization_key &#x3D; title_1</span><br><span class="line">    &#125;</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        localization_key &#x3D; title_2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>localization\simp_chinese\custom_localization\test_random_loc_l_simp_chinese.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> title_1:0 &quot;大胆&quot;</span><br><span class="line"> title_2:0 &quot;善心&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>events\adventure_events\adventure_events.txt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adventure.1001 &#x3D; &#123;</span><br><span class="line">    type &#x3D; character_event</span><br><span class="line">	title &#x3D; adventure.1001.t1</span><br><span class="line">	desc &#x3D; adventure.1001.desc</span><br><span class="line">	theme &#x3D; adventure</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.a</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_1</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.b</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_2</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.c</span><br><span class="line">		trigger_event &#x3D; adventure.1003</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>localization\simp_chinese\event_localization\adventure\adventure_l_simp_chinese.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> adventure.1001.t1:0 &quot;[ROOT.Char.Custom(&#39;YourCustomLoc&#39;)]&quot;</span><br><span class="line"> adventure.1001.desc:0 &quot;氪金可以获得更好的体验&quot;</span><br><span class="line"> adventure.1001.option.a:0 &quot;我相信上天会为我选择最合适的道路！&quot;</span><br><span class="line"> adventure.1001.option.b:0 &quot;我相信我的能力，命运掌握在我自己手中！&quot;</span><br><span class="line"> adventure.1001.option.c:0 &quot;人的能力是有极限的，我要充钱变强！&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写好这些文件以后，游戏中通过<code>event adventure.1001</code>触发该事件，可以看到标题会随机显示为<code>大胆</code>或者<code>善心</code>。</p>
</li>
<li><p>类似地，<code>desc</code>部分也可以这样写。此外，除了<code>[ROOT.Char.Custom(&#39;YourCustomLoc&#39;)]</code>这样的写法，也还有其他类型的写法，具体可以参考游戏本体文件中的内容。</p>
</li>
</ol>
</li>
</ol>
<h1 id="message"><a href="#message" class="headerlink" title="message"></a>message</h1><ol>
<li><p><code>message</code>是指游戏右下角弹出的那个信息提示，或者屏幕上半部分的中间弹出的那个横幅。</p>
</li>
<li><p>代码基础结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_message &#x3D; &#123;</span><br><span class="line">	display &#x3D; (feed|toast)		# where to display the message; default: feed</span><br><span class="line">	text &#x3D; some_loc_key			# string to be used in the message; default: same as message key (e.g &quot;my_message&quot; in this example)</span><br><span class="line">	desc &#x3D; some_loc_key			# string that gives more info about what happened</span><br><span class="line">	tooltip &#x3D; some_loc_key		# string to be used for tooltip of type(optional); default: no tooltip</span><br><span class="line">	soundeffect &#x3D; sound_name	# sound effect played when showing the message (optional); default: no sound</span><br><span class="line">	icon &#x3D; &quot;texture.dds&quot;		# icon textures found in gfx\interface\message_icons</span><br><span class="line">	style &#x3D; good&#x2F;bad&#x2F;neutral	# neutral is default, affects the look of message items</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行的<code>display</code>如果是<code>feed</code>，则信息是右下角的形式；如果是<code>toast</code>，则信息是中间横幅的形式；默认值是<code>feed</code>；</p>
<p>第二行是该信息的标题文本，默认是信息本身的关键字段，例如这里的<code>my_message</code>；</p>
<p>第三行是改信息的描述文本；</p>
<p>接下来是该信息的工具栏提示文本；</p>
<p>最后三行分别是音效、图标和类型，图标的路径在<code>gfx\interface\message_icons</code>，类型的设置会影响信息框的颜色外观。</p>
</li>
<li><p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_message_type &#x3D; &#123;</span><br><span class="line">	display &#x3D; feed</span><br><span class="line">	title &#x3D; &quot;My Title&quot;</span><br><span class="line">	desc &#x3D; &quot;My $EFFECT$&quot;</span><br><span class="line">	tooltip &#x3D; &quot;My Tooltip&quot;</span><br><span class="line">	soundeffect &#x3D; &quot;blah.audio&quot;</span><br><span class="line">	icon &#x3D; &quot;nice.dds&quot;</span><br><span class="line">	style &#x3D; good</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">send_interface_message &#x3D; &#123;</span><br><span class="line">	type &#x3D; my_message_type</span><br><span class="line">	add_gold &#x3D; 50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<script type="math/tex">EFFECT</script>的写法表示该信息的文本描述是实际造成的效果，比如这里是钱增加50。这样写的一个好处就是，类似的事件可以共用同一个<code>message_type</code>，而不用针对每个事件都写一个新的。上述这个例子所弹出的信息提示如下：</p>
<pre><code>Title = My Title
Description = My Add 50 Gold
Tooltip = My Tooltip
</code></pre></li>
<li><p>第二个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">send_interface_message &#x3D; &#123;</span><br><span class="line">	type &#x3D; my_message_type</span><br><span class="line">	desc &#x3D; &#123;</span><br><span class="line">		desc &#x3D; &quot;My Start Line&quot;</span><br><span class="line">		desc &#x3D; linebreak</span><br><span class="line">		desc &#x3D; &quot;My $EFFECT$&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	title &#x3D; &quot;My Cooler Title&quot;</span><br><span class="line">	tooltip &#x3D; &quot;$DESCRIPTION$&quot;</span><br><span class="line">	add_gold &#x3D; 50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然使用刚才的<code>message_type</code>，但是在调用的时候指定了<code>desc</code>、<code>title</code>和<code>tooltip</code>这3个字段，则输出的信息中的3个字段会替换为指定的内容，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title &#x3D; My Cooler Title</span><br><span class="line">Description &#x3D; My Start Line \n My Add 50 Gold</span><br><span class="line">Tooltip &#x3D; My Start Line \n My Add 50 Gold</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Strategic Information Revelation in Crowdsourcing Systems Without Verification</title>
    <url>/2020/12/25/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Strategic%20Information%20Revelation%20in%20Crowdsourcing%20Systems%20Without%20Verification/</url>
    <content><![CDATA[<h1 id="Strategic-Information-Revelation-in-Crowdsourcing-Systems-Without-Verification"><a href="#Strategic-Information-Revelation-in-Crowdsourcing-Systems-Without-Verification" class="headerlink" title="Strategic Information Revelation in Crowdsourcing Systems Without Verification"></a>Strategic Information Revelation in Crowdsourcing Systems Without Verification</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ol>
<li>本文研究：无需验证解决方案、激励员工提供高质量解决方案的众包平台</li>
<li>本文假设：信息不对称、平台具有信息优势——平台知道有关workers解决方案的平均准确性的更多信息，可以向workers策略性披露信息。根据平台公开的信息，workers判断自己认真完成任务后所获得的奖励。</li>
<li>workers类型：<ol>
<li>naive workers：完全信任平台公开的信息</li>
<li>strategic workers：基于平台公开信息更新自己的先验信念</li>
</ol>
</li>
<li>本文发现：<ol>
<li>对于naive workers：始终宣布高平均精度</li>
<li>对于strategic workers：有动机宣布低于实际值的平均精度</li>
<li>平台的回报可能减少高精度workers </li>
</ol>
</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ol>
<li>互联网的发展使得多种在线任务的众包具有可行性。</li>
<li>高质量的众包任务解决方案需要worker付出足够的努力，因此平台需要提供激励；而平台无法获取真实结果验证解决方案时，设计激励方案会很难，进而引出IEWV问题。</li>
<li>IEWV(Information elicitation without verification)：未验证的信息挖掘，大多数研究对称信息场景；而实际上，平台往往有更多信息。</li>
<li>本文采用多数投票方案：如果一个worker与其他workers的大多数解决方案相匹配，他将获得一个一致性奖励。</li>
<li>本文假设平台有一个额外决策：信息披露。该场景中，workers由高精度和低精度的混合构成，平台知道每种类型的数量，而workers不知道。</li>
<li>本文研究：<ol>
<li>平台是否有披露信息的动机</li>
<li>平台是否操纵被披露的信息</li>
<li>平台的最优信息披露策略——&gt;平台如何利用信息不对称</li>
</ol>
</li>
<li>平台与workers之间的交互（三阶段）：<ol>
<li>平台决定信息披露策略</li>
<li>平台决定一致性奖励</li>
<li>workers决定是否努力完成任务以及是否如实报告解决方案</li>
<li>上述三阶段结束后，平台收集workers上报的解决方案并根据三阶段来决定一致性奖励</li>
</ol>
</li>
<li>本文考虑两种类型的workers：<ol>
<li>naive workers：完全相信平台、workers推理平台公开信息是否可靠的能力有限，可以作为基准</li>
<li>strategic workers：不相信平台，有很高推理能力</li>
</ol>
</li>
</ol>
<h3 id="Key-Contributions"><a href="#Key-Contributions" class="headerlink" title="Key Contributions"></a>Key Contributions</h3><ol>
<li>研究IEWV问题的策略性信息披露：非凸问题，但是可以利用特殊结构求最优解</li>
<li>workers的均衡策略：证明workers之间存在多重均衡，在适当的信息披露和报酬设计下，所有workers努力工作并如实报告自己解决方案是其帕累托最优</li>
<li>平台信息披露策略：<ol>
<li>naive workers：始终公布一个与实际值无关的较高的平均准确率</li>
<li>strategic workers：有动机公布一个低于实际值的平均准确率</li>
</ol>
</li>
<li>性能评估：数值实验<ol>
<li>平台报酬增加了workers对高准确率workers数量的先验信念</li>
<li>平台报酬可能会减小高准确率workers的数量</li>
</ol>
</li>
</ol>
<h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h3 id="Information-Elicitation-Without-Verification-IEWV"><a href="#Information-Elicitation-Without-Verification-IEWV" class="headerlink" title="Information Elicitation Without Verification(IEWV)"></a>Information Elicitation Without Verification(IEWV)</h3><ol>
<li>设计适当的激励</li>
<li>同伴预测</li>
<li>大都假设信息对称</li>
</ol>
<h3 id="Strategic-Information-Revelation"><a href="#Strategic-Information-Revelation" class="headerlink" title="Strategic Information Revelation"></a>Strategic Information Revelation</h3><ol>
<li>不完全信息中的cheap talk问题——假设平台不会说谎</li>
<li>考虑信息获取和揭示代价的劝说博弈——认为信息披露是唯一的决策</li>
</ol>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h3 id="Workers’-Decisions-and-Payoffs"><a href="#Workers’-Decisions-and-Payoffs" class="headerlink" title="Workers’ Decisions and Payoffs"></a>Workers’ Decisions and Payoffs</h3><ol>
<li>任务和workers：<ol>
<li>任务：二值问题，例如判断数学问题求解方案是否正确，解空间<code>{1， -1}</code>，分别表示正确和错误。</li>
<li>workers：$N$个，$x_i^{estimate}$表示第$i$个worker对该任务解的估计值，$x_i^{report}$表示第$i$个worker对该任务解的上报值，这二者可能一样也可能不同。</li>
</ol>
</li>
<li>workers的努力策略：<ol>
<li>worker可以决定是否努力工作，求解准确性和他选择的努力程度有关，努力程度为<code>{0,1}</code>两种。<ol>
<li>努力程度为0时，worker求解准确率为0.5，代价为0，且无法获取关于任务解方案的任何信息（即其估计值为真或假的概率相等）</li>
<li>努力程度为1时，其求解准确率会提高为$p_i$，代价为$c$。</li>
</ol>
</li>
<li>workers的异构：$N$个workers中有$k$个高准确率的worker（准确率为$p_h$）使用集合$N_h$表示；$N-k$个低准确率的worker（准确率为$p_l$），使用集合$N_l$表示。两个准确率值均大于0.5小于1。</li>
</ol>
</li>
<li>worker的上报策略：<ol>
<li>对于不努力的worker：策略唯一，随机上报，用<code>rd</code>表示</li>
<li>对于努力的worker：策略空间<code>{1,-1}</code>，分别表示如实报告和谎报</li>
<li>workers可以共谋，大家都报告1或者-1，但对于在线众包系统，这样的共谋并不现实；平台检测到共谋则会删除该worker，因此认为workers的报告策略是独立的，且只有<code>{rd,1,-1}</code>这三个选项。</li>
<li>$s_i=(e_i,r_i)$表示第$i$个worker的努力策略和报告策略，具体来说$s_i\in S_i=\{(0,rd),(1,1),(1,-1)\}$</li>
</ol>
</li>
<li>一致性奖励：<ol>
<li>报告值和大多数人一样的worker可以得到奖励$R$。</li>
<li>$G_i(s;\epsilon)$表示第$i$个worker收到$R$的概率，其中，$s=(e_i,r_i)$，$\epsilon$是平台策略，在后面进行分析。</li>
</ol>
</li>
<li>worker的收益：$u_i(s;\epsilon,R)=G_i(s;\epsilon)\cdot R-e_i\cdot c$</li>
</ol>
<h3 id="Platform’s-Decisions-and-Payoff"><a href="#Platform’s-Decisions-and-Payoff" class="headerlink" title="Platform’s Decisions and Payoff"></a>Platform’s Decisions and Payoff</h3><ol>
<li><p>平台的信息披露策略：</p>
<ol>
<li><p>平台拥有的信息优势：workers求解准确率的分布，也就是高准确率workers的数量$k$</p>
</li>
<li><p>平台和workers之间非对称信息披露的贝叶斯说服框架：</p>
<ol>
<li><p>平台和workers都不知道$k$，平台需要进行长期信息披露策略：</p>
<ol>
<li><p>平台虽然不知道$k$，但是知道$k$的分布，从而得到先验信念$\mu^{prior}=(\mu_{high}^{prior},\mu_{low}^{prior})$，其中$\mu_{high}^{prior}=Pr(k=k^{high})$，$\mu_{low}^{prior}=Pr(k=k^{low})$。$\mu_{high}^{prior}+\mu_{low}^{prior}=1$，且$k^{high}$和$k^{low}$是$k$的两个可能取值。</p>
</li>
<li><p>这个先验同时也是workers的，大家都一样。</p>
</li>
<li><p>注意，出于简化，上述公式中$k$的分布是两点分布，本方法同样适用于其他分布的情况。</p>
</li>
<li><p>在$k$被发现之前，平台会预定一个信息披露策略（？是否公开——从后文看是公开的，或者说是workers能发现其规律）。</p>
</li>
<li><p>平台可以有多个任务，每个任务有各自对应的$k$，在workers到来之前（也即是在$k$被发现之前），平台会先决定信息披露策略，并承诺会按这个策略执行，从而建立良好信誉。</p>
</li>
<li><p>$\epsilon = (\epsilon^h, \epsilon^l)\in [0,1]^2$：平台的信息披露策略。假设当$k=k^{low}$时，平台宣称$k_p^{anu}=k^{high}$的概率是$\epsilon^h$，而反之，当$k=k^{high}$时，平台宣称$k_p^{anu}=k^{low}$的概率是$\epsilon^l$。</p>
</li>
<li><p>总结一下就是平台会按下列概率决策：</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{low})=\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{low})=1-\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{high})=1-\epsilon^l$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{high})=\epsilon^l$</p>
<p>即：k有两个取值，一个high，一个low，当真实的k是high时，平台说谎的概率是$\epsilon^l$；当真实的k是low时，平台说谎的概率是$\epsilon^h$。</p>
</li>
</ol>
</li>
<li><p>workers执行任务，平台观察到$k$，workers尚且不知道；</p>
</li>
<li><p>平台依据之前决定的策略公开$k_p^{anu}$，可能和真实$k$不同，平台决定的$\epsilon$会影响workers对$k$的后验信念，从而影响平台的信誉和收益。</p>
</li>
<li><p>workers可以通过重复与平台交互从而了解平台的信息披露策略，也可以通过平台反馈以及信誉系统来了解信息披露策略。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>平台的奖励设计策略：$R$，决定worker均衡收益</p>
</li>
<li><p>平台的收益：准确率和代价之间的均衡</p>
<p>$U_p(\epsilon,R,k;s)=\beta P_a(\epsilon,R,k;s)-E\{R^{tot}(\epsilon,R,k;s)\}$</p>
<ol>
<li>$P_a(\epsilon,R,k;s)$表示workers的任务聚合准确率，使用少数服从多数的规则来计算该概率。</li>
<li>$\beta$表示平台对聚合准确率的估值（从公式上理解感觉更像是说当聚合结果是正确的时候所得到的收益）</li>
<li>$E\{R^{tot}(\epsilon,R,k;s)\}$表示对总的一致性奖励的预期支出（这里的$R^{tot}$是指什么？）</li>
</ol>
</li>
</ol>
<h2 id="SOLVING-THREE-STAGE-MODEL"><a href="#SOLVING-THREE-STAGE-MODEL" class="headerlink" title="SOLVING THREE-STAGE MODEL"></a>SOLVING THREE-STAGE MODEL</h2><p>本章节使用逆向归纳法，仅分析strategic worker。</p>
<h3 id="Worker-Equilibrium-Behaviors-in-Stage-III"><a href="#Worker-Equilibrium-Behaviors-in-Stage-III" class="headerlink" title="Worker Equilibrium Behaviors in Stage III"></a>Worker Equilibrium Behaviors in Stage III</h3><ol>
<li><p>前提：给定平台策略$\epsilon$和$R$，每个worker选择自己的努力程度和报告策略$s_i$来最大化自身收益</p>
</li>
<li><p>worker的信念更新：平台公布$k_p^{anu}$之前，workers有对$k$的先验信念$\mu^{prior}$（是每人一个还是所有worker共用？）</p>
<ol>
<li><p>平台公布$k_p^{anu}$后，workers基于先验信念和平台公布值更新后验信念$\mu_w^{post,str}|k_p^{anu}$，其中$w\in \{high,low\}$。计算如下：</p>
<script type="math/tex; mode=display">
\mu_{high}^{post,str}|k^{high}(\epsilon)=\frac{(1-\epsilon^l)\mu_{high}^{prior}}{(1-\epsilon^l)\mu_{high}^{prior}+\epsilon^h\mu_{low}^{prior}}</script><script type="math/tex; mode=display">
\mu_{low}^{post,str}|k^{high}(\epsilon)=\frac{\epsilon^h\mu_{low}^{prior}}{(1-\epsilon^l)\mu_{high}^{prior}+\epsilon^h\mu_{low}^{prior}}</script><script type="math/tex; mode=display">
\mu_{high}^{post,str}|k^{low}(\epsilon)=\frac{\epsilon^l\mu_{low}^{prior}}{\epsilon^l\mu_{high}^{prior}+(1-\epsilon^h)\mu_{low}^{prior}}</script><script type="math/tex; mode=display">
\mu_{low}^{post,str}|k^{low}(\epsilon)=\frac{(1-\epsilon^h)\mu_{low}^{prior}}{\epsilon^l\mu_{high}^{prior}+(1-\epsilon^h)\mu_{low}^{prior}}</script><p>推导过程用到了<a href="https://zhuanlan.zhihu.com/p/134036707" target="_blank" rel="noopener">贝叶斯公式</a>。</p>
<p>前两行表示平台宣布$k=k^{high}$时，worker对$k$实际值的后验信念；后两行表示平台宣布$k=k^{low}$时，worker对$k$实际值的后验信念。</p>
</li>
<li><p>显然，第一个公式里，随着$\epsilon^h$的增加，workers对k为high的后验信念逐渐减小，也就是说，如果平台在k实际为low时说谎的概率增加，则workers在听到平台说k为high时，会怀疑平台说谎；类似地，在第四个公式中，随着$\epsilon^l$的增加，workers对k为low的后验信念逐渐减小，也就是说，如果平台在k实际为high时说谎的概率增加，则workers在听到平台说k为low时，会怀疑平台，进而减小后验信念。</p>
</li>
</ol>
</li>
<li><p>worker的均衡策略：worker根据后验信念做出是否努力以及是否如实汇报的决策，本文关注对称纳什均衡——相同类型（任务求解准确率）的worker会有相同的决策。</p>
<ol>
<li><p>定义1：</p>
<ol>
<li>$n-SNE$：$(s_i^*=(0,rd), \forall i\in N)$，没有worker会努力和如实报告</li>
<li>$f-SNE$：$(s_i^*=(1,1), \forall i\in N)$， 所有worker都努力和如实报告</li>
<li>$p-SNE$：$(s_i^<em>=(1,1), \forall i\in N_h, s_j^</em>=(0,rd), \forall j\in N_l)$，高准确率的worker会努力和如实报告，低准确率的worker会不努力和随机报告</li>
</ol>
</li>
<li><p>定理1：</p>
<ol>
<li>给定任意$\epsilon\in [0,1]^2$，$R\geq 0$时一定存在一个$n-SNE$.</li>
<li>给定任意$\epsilon\in [0,1]^2$，始终存在阈值$R_f^{str}(\epsilon, k_p^{anu})&gt; 0$，使得当且仅当$R&gt;R_f^{str}(\epsilon,k_p^{anu})$时存在$f-SNE$.</li>
<li>当$\epsilon\in \Phi=\{\epsilon\in [0,1]^2|condition (11) \}$成立时，存在两个阈值$0&lt;R_{pl}^{str}(\epsilon,k_p^{anu})\leq R_{ph}^{str}(\epsilon, k_p^{anu})$，使得当且仅当$R_{pl}^{str}(\epsilon,k_p^{anu})\leq R \leq R_{ph}^{str}(\epsilon, k_p^{anu})$时，存在$p-SNE$. $condition (11)$如下：</li>
</ol>
<script type="math/tex; mode=display">
\frac{2p_h-1}{2p_l-1}(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})\geq \mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority} \tag{11}</script><p>​        在该公式中，$P_{k^{high}-1}^{majority}$是指：当$k^{high}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers都决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        $P_{k^{low}-1}^{majority}$是指：当$k^{low}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        $P_{k^{high}}^{majority}$是指：$k^{high}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        $P_{k^{low}}^{majority}$是指：$k^{low}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        这个公式算起来很复杂，它表达的场景是：当选择努力时，高准确率worker相信他们更有可能拿到奖励（而不是低准确率worker），也就是说高准确率worker认为自己是大多数的那部分。反之，当这个公式不满足时，高准确率worker会觉得自己拿到奖励的概率很低，从而使得高准确率worker的期望收益很低。此时，高准确率worker不会努力，而是选择降低成本，进而不存在$p-SNE$。</p>
</li>
</ol>
</li>
<li><p>推论1：</p>
<ol>
<li><p>对于一个固定的$\epsilon^l$，如果$k_p^{anu}=k^{high}$，则定理1中的$R_f^{str}(\epsilon,k_p^{anu})$和$R_{pl}^{str}(\epsilon,k_p^{anu})$随$\epsilon^h$增加而增加；反之，如果$k_p^{anu}=k^{low}$，则这两个都随$\epsilon^h$增加而减小。</p>
<p>说明：如果平台更喜欢把$k_p^{anu}$谎报成$k^{high}$（也就是说在$k^{low}$时说谎），那么为了达成$f-SNE$和$p-SNE$，平台需要提供更高报酬（也就是更大的$R$）。分析原因：这种情况会让workers觉得实际的$k$并不是$k^{high}$而是$k^{low}$，也就是说$\mu_{high}^{post,str}|k^{high}(\epsilon)$会减小，因此通过多数一致获得的奖励会减少，而为了激励workers，平台就需要提高奖励，从而提高workers的期望收益。</p>
</li>
<li><p>对于一个固定的$\epsilon^h$，如果$k_p^{anu}=k^{high}$，则定理1中的$R_f^{str}(\epsilon,k_p^{anu})$和$R_{pl}^{str}(\epsilon,k_p^{anu})$随$\epsilon^l$增加而增加；反之，如果$k_p^{anu}=k^{low}$，则这两个都随$\epsilon^l$增加而减小。</p>
<p>说明：如果平台更喜欢把$k_p^{anu}$谎报成$k^{low}$（也就是说在$k^{high}$时说谎），那么为了达成$f-SNE$和$p-SNE$，平台也一样需要提高报酬来激励。这里的推导可以看前面workers更新后验信念那里的公式来理解。</p>
</li>
<li><p>对于适当的$\epsilon$和$R$，定理1中的几个不同的$SNE$可以共存。</p>
</li>
</ol>
</li>
<li><p>定理2：帕累托最优：对于任意给定$\epsilon$和$R$，workers之间存在一个帕累托最优均衡解。</p>
<p>本文假设当多个均衡解共存时，workers会选择帕累托最优。</p>
</li>
</ol>
<h3 id="Platform-Reward-Design-in-Stage-II"><a href="#Platform-Reward-Design-in-Stage-II" class="headerlink" title="Platform Reward Design in Stage II"></a>Platform Reward Design in Stage II</h3><p>这一部分分析对于给定的$\epsilon$，平台观察$k$并决定$R$，从而在第三阶段达到帕累托最优。</p>
<ol>
<li><p>定义2：$z\in \{n,f,p\}$表示均衡解索引</p>
<ol>
<li><p>$P_z(k)$：均衡$z-SNE$的任务聚合准确率</p>
</li>
<li><p>$E\{R_z^{tot}(\epsilon,k,k_p^{anu})\}$：均衡$z-SNE$的总期望一致性奖励</p>
</li>
<li><p>$B_z(\epsilon,k,k_p^{anu})$：对于每单位$R$，均衡解从$n-SNE$提升到$z-SNE$所带来的平均准确率的提升，计算方式如下：</p>
<script type="math/tex; mode=display">
B_z(\epsilon,k,k_p^{anu})=\frac{P_z(k)-P_n(k)}{E\{R_z^{tot}(\epsilon,k,k_p^{anu})\}}</script></li>
</ol>
</li>
<li><p>定理3：</p>
<ol>
<li><p>如果$(11)$成立且$B_p(\epsilon,k,k_p^{anu})&gt;B_f(\epsilon,k,k_p^{anu})$，则平台的最优奖励为：</p>
<script type="math/tex; mode=display">
R^*=\left\{
\begin{aligned}
&0, &if \ \ \beta<\frac{1}{B_p(\epsilon,k,k_p^{anu})}\\
&R_{pl}^{str}(\epsilon,k_p^{anu}), &if\ \ \frac{1}{B_p(\epsilon,k,k_p^{anu})} \leq \beta<\widetilde\beta(\epsilon,k,k_p^{anu}) \\
&R_{f}^{str}(\epsilon,k_p^{anu}), &if\ \ \beta\geq \widetilde\beta(\epsilon,k,k_p^{anu})
\end{aligned}
\right.</script><p>其中，$\widetilde\beta(\epsilon,k,k_p^{anu})=\frac{E\{R_f^{tot}(\epsilon,k,k_p^{anu})-E\{R_p^{tot}(\epsilon,k,k_p^{anu})}{P_f(k)-P_p(k)}$</p>
</li>
<li><p>如果$(11)$不成立或者$B_p(\epsilon,k,k_p^{anu})&lt;B_f(\epsilon,k,k_p^{anu})$，则平台的最优奖励为：</p>
<script type="math/tex; mode=display">
R^*=\left\{
\begin{aligned}
&0, &if \ \ \beta<\frac{1}{B_f(\epsilon,k,k_p^{anu})}\\
&R_{f}^{str}(\epsilon,k_p^{anu}), &if\ \ \beta\geq \frac{1}{B_f(\epsilon,k,k_p^{anu})}
\end{aligned}
\right.</script><p>注意，$(11)$是达到$p-SNE$所必须的条件。</p>
</li>
</ol>
</li>
<li><p>定理3说明了：</p>
<ol>
<li>如果$p-SNE$存在，且它比$f-SNE$的单位收益准确率提升更高，且平台的估值$\beta$是温和的，平台会通过选择$R^*=R_{pl}^{str}(\epsilon,k_p^{anu})$引出$p-SNE$作为第三阶段的帕累托均衡来最大化自己的收益。</li>
<li>如果$p-SNE$不存在，或者它比$f-SNE$的单位收益准确率提升低，那么$p-SNE$对平台而言就不是最好的均衡解。当$\beta$很大时，平台会通过选择$R^*=R_f^{str}(\epsilon,k_p^{anu})$引出$f-SNE$作为第三阶段的帕累托最优。</li>
</ol>
</li>
</ol>
<h3 id="Platform-Information-Revelation-in-Stage-I"><a href="#Platform-Information-Revelation-in-Stage-I" class="headerlink" title="Platform Information Revelation in Stage I"></a>Platform Information Revelation in Stage I</h3><p>这一部分讨论平台的信息披露策略。在该阶段中，平台决定自己的信息披露策略$\epsilon = (\epsilon^h,\epsilon^l)\in[0,1]^2$，并预测自己在第二阶段中的$R$和workers在第三阶段中的帕累托均衡。</p>
<p>重复一下前文的符号表示：</p>
<blockquote>
<p>$\epsilon = (\epsilon^h, \epsilon^l)\in [0,1]^2$：平台的信息披露策略。假设当$k=k^{low}$时，平台宣称$k_p^{anu}=k^{high}$的概率是$\epsilon^h$，而反之，当$k=k^{high}$时，平台宣称$k_p^{anu}=k^{low}$的概率是$\epsilon^l$。</p>
<p>总结一下就是平台会按下列概率决策：</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{low})=\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{low})=1-\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{high})=1-\epsilon^l$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{high})=\epsilon^l$</p>
<p>即：k有两个取值，一个high，一个low，当真实的k是high时，平台说谎的概率是$\epsilon^l$；当真实的k是low时，平台说谎的概率是$\epsilon^h$。</p>
</blockquote>
<ol>
<li><p>定理4：对平台而言，设置为$\epsilon^h=1,\epsilon^l=0$并不总是最优解。</p>
<p>换言之，宣称$k_p^{anu}=k^{high}$并不总是最好的，具体分析如下：</p>
<p>首先，复习内容：$k$的真实值影响第2阶段中的奖励设计，而平台对$k$的宣称值$k_p^{anu}$影响第3阶段中workers的行为。考虑一下4种情况：</p>
<ol>
<li>Case $(h,h)$: $k=k^{high}$ 且 $k_p^{anu}=k^{high}$，出现概率$Q_{h,h}(\epsilon)=\mu_{high}^{prior}(1-\epsilon^l)$</li>
<li>Case $(h,l)$: $k=k^{high}$ 且 $k_p^{anu}=k^{low}$，出现概率$Q_{h,l}(\epsilon)=\mu_{high}^{prior}\epsilon^l$</li>
<li>Case $(l,h)$: $k=k^{low}$ 且 $k_p^{anu}=k^{high}$，出现概率$Q_{l,h}(\epsilon)=\mu_{low}^{prior}\epsilon^h$</li>
<li>Case $(l,l)$: $k=k^{low}$ 且 $k_p^{anu}=k^{low}$，出现概率$Q_{l,l}(\epsilon)=\mu_{low}^{prior}(1-\epsilon^h)$</li>
</ol>
<p>固定$\epsilon^l$，平台的期望收益为：</p>
<script type="math/tex; mode=display">
E\{U_p(\epsilon^h)\}=Q_{h,h}(\epsilon^h)U_{h,h}(\epsilon^h)+Q_{h,l}(\epsilon^h)U_{h,l}(\epsilon^h)+Q_{l,h}(\epsilon^h)U_{l,h}(\epsilon^h)+Q_{l,l}(\epsilon^h)U_{l,l}(\epsilon^h)</script><p>$U_{h,h}$表示在Case $(h,h)$的情况下，平台在第2阶段最优化奖励值后的最大收益。其他几个U也是类似的含义。</p>
<p>接下来分析期望收益随披露策略的变化趋势。</p>
</li>
<li><p>引理1：</p>
<ol>
<li>$U_{h,h}(\epsilon^h),U_{l,h}(\epsilon^h),Q_{l,l}(\epsilon^h)$随$\epsilon^h$增加而减小。</li>
<li>$U_{h,l}(\epsilon^h),U_{l,l}(\epsilon^h),Q_{l,h}(\epsilon^h)$随$\epsilon^h$增加而增加。</li>
</ol>
<p>分析：$Q_{l,l}(\epsilon^h)$和$Q_{l,h}(\epsilon^h)$随$\epsilon^h$的变化从定义即可看出。接下来用Case $(h,h)$ 中的 $U_{h,h}(\epsilon^h)$作为例子来分析。在推论1中可知，随$\epsilon^h$增加，平台需要支付更大的奖励$R$来激励workers，而这会减小平台的收益。其他几个U也是类似的分析思路。</p>
<p>而由于$E\{U_p(\epsilon^h)\}$的几部分单调性不同，因此无法直接分析出平台收益随$\epsilon^h$的变化趋势。同样的，$E\{U_p(\epsilon^l)\}$也无法分析变化趋势。从而得出定理4的结论。</p>
</li>
</ol>
<p>具体的平台披露策略因为太复杂了，所以没法分析，在实验部分进行了数值实验。</p>
<h2 id="NUMERICAL-RESULTS"><a href="#NUMERICAL-RESULTS" class="headerlink" title="NUMERICAL RESULTS"></a>NUMERICAL RESULTS</h2><p>这一部分进行数值实验，研究两类workers：策略型和天真型，天真型的符号表达沿用前文中策略型的，只是把str改成了nai，具体如下：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
\mu_{high}^{post,nai}|k^{high}=\mu_{low}^{post,nai}|k^{low}=1\\
\mu_{high}^{post,nai}|k^{low}=\mu_{low}^{post,nai}|k^{high}=0\\
\end{aligned}
\right.</script><p>接下来的实验结果说明：平台始终向天真的工人宣布高平均工人准确率是最佳的（也就是$k=k^{high}$），但对策略型工人来说并非如此。我们还显示了一个反直觉的结果，表明平台的收益随高准确率workers的准确率提高而提高，随高准确率workers的数量提高而减小。</p>
<h3 id="Impact-of-Worker-Characteristics"><a href="#Impact-of-Worker-Characteristics" class="headerlink" title="Impact of Worker Characteristics"></a>Impact of Worker Characteristics</h3><p>这一部分研究高准确率workers的准确率$p_h$对平台最优收益、workers总收益（所有workers的收益和）和社会福利（平台收益+workers收益）的影响。</p>
<p>参数：workers数量$N=100$，高准确率workers的准确率$p_h\in(0.7,0.8),step=0.02$，低准确率workers的准确率$p_l=0.6$，对$k$的先验信念$\mu_{high}^{prior}=0.7,\mu_{low}^{prior}=0.3$，$k$的取值$k^{low}=20,k^{high}\in\{50,70\}$，workers努力的成本$c=1$，平台对聚合准确的估值$\beta=1000$。</p>
<p>分析图像：</p>
<ol>
<li>平台收益随$p_h$增加而增加，对于某些$p_h$随$k^{high}$增加（指从50变成70）而减小。</li>
<li>天真的workers给平台带来的收益更高。</li>
<li>workers收益可能随$p_h$增加而减小。</li>
<li>社会财富随$p_h$增加而增加。</li>
</ol>
<h3 id="Impact-of-Worker-Prior-Belief"><a href="#Impact-of-Worker-Prior-Belief" class="headerlink" title="Impact of Worker Prior Belief"></a>Impact of Worker Prior Belief</h3><p>这一部分研究先验信念对平台最优收益、workers总收益和平台披露策略的影响。</p>
<p>参数：workers数量$N=100$，高准确率workers的准确率$p_h=0.75$，低准确率workers的准确率$p_l=0.6$，对$k$的先验信念$\mu_{high}^{prior}\in\{0.01,0.2,0.4,0.6,0.8,0.99\}$，$k$的取值$k^{low}=20,k^{high}\in\{50,70\}$，workers努力的成本$c=1$，平台对聚合准确的估值$\beta=1000$。</p>
<p>分析图像：</p>
<ol>
<li>平台收益随先验$\mu_{high}^{prior}$增加而增加。</li>
<li>策略型workers的聚合收益随先验$\mu_{high}^{prior}$增加而减小，天真型workers的聚合收益与先验$\mu_{high}^{prior}$无关。</li>
<li>面对天真型workers，平台始终宣称$k=k^{high}$是最优的；面对策略型workers则不是这样。</li>
<li>面对策略型workers时，平台的最优$\epsilon^{h}$随先验$\mu_{high}^{prior}$增加而减小，最优$\epsilon^{l}$随先验$\mu_{high}^{prior}$增加而增加。</li>
</ol>
<h2 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h2><ol>
<li>策略性信息披露问题——非凸规划</li>
<li>naive workers：总是公开一个较高的平均准确率</li>
<li>strategic workers：收益和平台信用的平衡，有动机宣布一个低于实际值的平均准确率</li>
<li>平台报酬可能减少高准确率workers的数量</li>
<li>未来工作：<ol>
<li>多维workers异质性</li>
<li>考虑信息披露的代价（获取信息所产生的成本）</li>
</ol>
</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/134036707" target="_blank" rel="noopener">贝叶斯公式</a></li>
</ol>
<h2 id="我的分析"><a href="#我的分析" class="headerlink" title="我的分析"></a>我的分析</h2><h3 id="第三阶段workers均衡解定理1"><a href="#第三阶段workers均衡解定理1" class="headerlink" title="第三阶段workers均衡解定理1"></a>第三阶段workers均衡解定理1</h3><p>要用到的字母表达：</p>
<p>$P_{k^{high}-1}^{majority}$是指：当$k^{high}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers都决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$P_{k^{low}-1}^{majority}$是指：当$k^{low}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$P_{k^{high}}^{majority}$是指：$k^{high}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$P_{k^{low}}^{majority}$是指：$k^{low}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)$和$\mu_{low}^{post,str}|k_p^{anu}(\epsilon)$是高质量workers的数量的后验概率</p>
<p>我增加的字母表达：$P^{00}$表示高低质量都采取$(0,rd)$时多数一致方案是正确的概率，$P^{01}$表示高质量采取$(0,rd)$低质量采取$(1,-1)$…类似的，可以把workers策略组合的所有概率表达都写出来，上标左边的数字表示高质量workers的策略，右边的数字表示低质量workers的策略，数字012分别表示策略$(0,rd),(1,-1),(1,1)$。</p>
<p>显然，$P^{00}=0.5$，$P^{20}=\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority}$</p>
<p>本文假设相同质量的workers会采取相同的策略，也就是说，高低质量的workers的策略组合一共有9种，我们列出收益矩阵：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>(0,rd)</th>
<th>(1,-1)</th>
<th>(1,1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>(0,rd)</td>
<td>$(0.5R, 0.5R)$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(1,-1)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(1,1)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="低质量workers选-0-rd"><a href="#低质量workers选-0-rd" class="headerlink" title="低质量workers选$(0,rd)$"></a>低质量workers选$(0,rd)$</h4><ol>
<li>高质量workers选$(0,rd)$，所有workers的答案是正确和错误的概率都是0.5，因此大家的收益都是$0.5R$，没有支出。</li>
<li>高质量workers选$(1,1)$，高质量workers正确的概率是$p_h$，低质量workers正确的概率是0.5，多数一致方案正确的概率是$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority}$，</li>
<li>高质量workers选$(1,-1)$，高质量workers正确的概率是$1-p_h$，低质量workers正确的概率是0.5，多数一致方案正确的概率是$P^{10}$。</li>
</ol>
<h4 id="低质量workers选-1-1"><a href="#低质量workers选-1-1" class="headerlink" title="低质量workers选$(1,-1)$"></a>低质量workers选$(1,-1)$</h4><ol>
<li>高质量workers选$(0,rd)$，高质量workers正确的概率是0.5，低质量workers正确的概率是$1-p_l$，多数一致方案正确的概率是$P^{01}$。</li>
<li>高质量workers选$(1,1)$，高质量workers正确的概率是$p_h$，低质量workers正确的概率是$1-p_l$，多数一致方案正确的概率是$P^{21}$。</li>
<li>高质量workers选$(1,-1)$，高质量workers正确的概率是$1-p_h$，低质量workers正确的概率是$1-p_l$，多数一致方案正确的概率是$P^{11}$。</li>
</ol>
<h4 id="低质量workders选-1-1"><a href="#低质量workders选-1-1" class="headerlink" title="低质量workders选$(1,1)$"></a>低质量workders选$(1,1)$</h4><ol>
<li>高质量workers选$(0,rd)$，高质量workers正确的概率是0.5，低质量workers正确的概率是$p_l$，多数一致方案正确的概率是$P^{02}$。</li>
<li>高质量workers选$(1,1)$，高质量workers正确的概率是$p_h$，低质量workers正确的概率是$p_l$，多数一致方案正确的概率是$P^{22}$。</li>
<li>高质量workers选$(1,-1)$，高质量workers正确的概率是$1-p_h$，低质量workers正确的概率是$p_l$，多数一致方案正确的概率是$P^{12}$。</li>
</ol>
<p>这里看起来是把每一个都列出来，然后比较大小找均衡解。</p>
<h4 id="Condition-11-的推导"><a href="#Condition-11-的推导" class="headerlink" title="$Condition(11)$的推导"></a>$Condition(11)$的推导</h4><p>在$p-SNE$的情况下，高准确率的worker采取策略$(1,1)$，低准确率的worker采取策略$(0,rd)$。</p>
<p>对于一个高质量worker，该workers努力时得到正确答案概率：$p_h$，得到错误答案概率：$1-p_h$。</p>
<p>其他workers中，高质量workers的数量$k$为$k^{high}-1$或者$k^{low}-1$，且对应的概率分别是两个后验概率$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)$和$\mu_{low}^{post,str}|k_p^{anu}(\epsilon)$，而这两种情况下其他workers的多数一致方案是正确和错误的概率分别是$P_{k^{high}-1}^{majority}$和$P_{k^{low}-1}^{majority}$，即可得：</p>
<p>其他workers的多数一致方案是正确的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority}$，</p>
<p>其他workers的多数一致方案是错误的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}-1}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}-1}^{majority})$</p>
<p>一个努力且如实报告的高质量worker得到收益的概率为：</p>
<script type="math/tex; mode=display">
p_h(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})+(1-p_h)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}-1}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}-1}^{majority})) \tag{1}</script><p>对于一个低质量worker而言，该workers努力时得到正确答案概率：$p_l$，得到错误答案概率：$1-p_l$，其他workers中，高质量workers的数量$k$为$k^{high}$或者$k^{low}$，且对应的概率分别是两个后验概率$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)$和$\mu_{low}^{post,str}|k_p^{anu}(\epsilon)$，而这两种情况下其他workers的多数一致方案是正确和错误的概率分别是$P_{k^{high}}^{majority}$和$P_{k^{low}}^{majority}$，即可得：</p>
<p>其他workers的多数一致方案是正确的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority}$，</p>
<p>其他workers的多数一致方案是错误的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}}^{majority})$</p>
<p>一个努力且如实报告的低质量worker得到收益的概率为：</p>
<script type="math/tex; mode=display">
p_l(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority})+(1-p_l)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}}^{majority})) \tag{2}</script><p>公式(1)大于公式(2)所推导出的公式和论文中的$condition(11)$不一样，暂时没想到其他的思路。</p>
<p>这里推导出的是：</p>
<script type="math/tex; mode=display">
(1-p_h)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)+\mu_{low}^{post,str}|k_p^{anu}(\epsilon))+(2p_h-1)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})\geq \\
(1-p_l)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)+\mu_{low}^{post,str}|k_p^{anu}(\epsilon))+(2p_l-1)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority})</script><p>论文里的11是：</p>
<script type="math/tex; mode=display">
\frac{2p_h-1}{2p_l-1}(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})\geq \mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority} \tag{11}</script><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ol>
<li>均衡解和阈值是怎么算出来的完全不懂</li>
<li>实验部分是怎么算最优平台披露策略$\epsilon^h,\epsilon^l$</li>
<li>图2(b)中增加的那段没有解释</li>
<li>$k^{high}=50$和$k^{high}=70$只有两个值是否能充分说明变化趋势（这个不重要）</li>
<li>社会财富的增加是否与平台数值过大有关（这个也不重要）</li>
<li>多数一致投票的时候，如果两边一样怎么处理（这个还不重要）</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>crowdsourcing</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-7</title>
    <url>/2020/12/24/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-7/</url>
    <content><![CDATA[<h1 id="On-Action"><a href="#On-Action" class="headerlink" title="On_Action"></a>On_Action</h1><p>在前面学习到的事件是由玩家在游戏中通过决议而触发的，但有时候我们会希望实现一些自动触发的事件，比如一年触发一次、五年触发一次等，这个时候就需要使用<code>on_action</code>了。</p>
<p>在<a href="https://likun1208.github.io/2020/11/08/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-4/">ck3mod制作笔记-4</a>中，我们提到过这个东西。它可以理解成一种编码，当游戏中有对应编码的事件发生时，就会执行<code>on_action</code>代码块中的内容，比如当角色结婚时，<code>on_marriage</code>部分的内容就会被触发。游戏本体的相关代码存放在<code>Crusader Kings III\game\common\on_action</code>文件夹中，可以看到有很多很多选项。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><code>_on_actions.info</code>文件中说明了一个<code>on_action</code>代码块的写法，这里简要翻译和介绍一下。</p>
<p>首先，一个<code>on_action</code>的基础结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on_action_name &#x3D; &#123;</span><br><span class="line">	trigger &#x3D; &#123;</span><br><span class="line">		trigger_conditions &#x3D; yes</span><br><span class="line">	&#125;</span><br><span class="line">	weight_multiplier &#x3D; &#123;</span><br><span class="line">		base &#x3D; 1</span><br><span class="line">		modifier &#x3D; &#123;</span><br><span class="line">			add &#x3D; 1</span><br><span class="line">			trigger_conditions &#x3D; yes</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	events &#x3D; &#123;</span><br><span class="line">		event_id_1</span><br><span class="line">		delay &#x3D; &#123; days &#x3D; 365 &#125;</span><br><span class="line">		event_id_2</span><br><span class="line">		delay &#x3D; &#123; months &#x3D; &#123; 6 12 &#125; &#125;</span><br><span class="line">		event_id_3</span><br><span class="line">	&#125;</span><br><span class="line">	random_events &#x3D; &#123;</span><br><span class="line">		chance_to_happen &#x3D; 25</span><br><span class="line">		chance_of_no_event &#x3D; &#123;</span><br><span class="line">			value &#x3D; 0</span><br><span class="line">			if &#x3D; &#123;</span><br><span class="line">				limit &#x3D; &#123; trigger_conditions &#x3D; yes &#125;</span><br><span class="line">				add &#x3D; 10</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		100 &#x3D; event_id_1</span><br><span class="line">		200 &#x3D; event_id_2</span><br><span class="line">		100 &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	first_valid &#x3D; &#123;</span><br><span class="line">		event_id_1</span><br><span class="line">		event_id_2</span><br><span class="line">		fallback_event_without_trigger</span><br><span class="line">	&#125;</span><br><span class="line">	on_actions &#x3D; &#123;</span><br><span class="line">		on_action_1</span><br><span class="line">		on_action_2</span><br><span class="line">		on_action_3</span><br><span class="line">	&#125;</span><br><span class="line">	random_on_actions &#x3D; &#123;</span><br><span class="line">		100 &#x3D; on_action_1</span><br><span class="line">		200 &#x3D; on_action_2</span><br><span class="line">		100 &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	first_valid_on_action &#x3D; &#123;</span><br><span class="line">		on_action_1</span><br><span class="line">		on_action_2</span><br><span class="line">	&#125;</span><br><span class="line">	effect &#x3D; &#123;</span><br><span class="line">		effects &#x3D; yes</span><br><span class="line">	&#125;</span><br><span class="line">	fallback &#x3D; another_on_action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>第一部分<code>trigger</code>是这个<code>on_action</code>的触发条件，如果一个<code>on_action</code>被游戏中的事件触发，而该<code>on_action</code>的<code>trigger</code>条件不满足，则无事发生。例如我们写一个<code>on_action</code>设定角色结婚后立刻获得1000金币，但是在<code>trigger</code>中限制该角色需要年龄低于30，则一个60岁角色的结婚事件触发该<code>on_action</code>后，不会获得金币。</li>
<li>第二部分是对该<code>on_action</code>权重的修正，这个权重是用于其他<code>on_action</code>的随机<code>on_action</code>列表（这个列表会在下面介绍），比如我们有3个<code>on_action</code>，分别是<code>on_action_1, on_action_2, on_action_3</code>，其中后两个在第一个的随机<code>on_action</code>列表中，这意味着当<code>on_action_1</code>触发时，<code>on_action_2</code>和<code>on_action_3</code>会以一定概率触发，概率由它们在列表中的权重决定，权重的计算方式在前面介绍过，而这里的<code>weight_multiplier</code>就是对该权重值的修正。</li>
<li>第三部分表示该<code>on_action</code>触发时会发生的事件列表，事件们在满足自身触发条件（<code>trigger</code>）的情况下，会从上到下按顺序逐一发生。这一部分中可以使用<code>delay</code>来控制事件之间的间隔，表示上一个事件发生多久后再继续进行下一个事件。<code>delay</code>可以是<code>days</code>，也可以是<code>months</code>和<code>years</code>，且这3者的值可以是形如<code>{6 12}</code>这样的随机列表，具体到游戏中会从大括号的值里挑一个，注意这两个数字之间没有逗号。上述代码中的这段例子就是当<code>on_action</code>触发时，先立刻发生<code>event_id_1</code>，等365天后会发生<code>event_id_2</code>，接着等6个月或12个月会发生<code>event_id_3</code>。</li>
<li>第四部分<code>random_events</code>是随机事件列表，<code>on_action</code>发生时，会从该列表中根据权值随机挑选事件发生，会且只会挑一个。其中的<code>chance_to_happen</code>是基础权值，比如这里是25。<code>chance_of_no_event</code>是可以格式化为脚本值的条目，出于性能原因独立于<code>chance_to_happen</code>，只有当<code>chance_to_happen</code>为真时，该值会被考虑。接下来的列表就是会被挑选的事件列表，其中形如<code>100 = 0</code>这样的条目，是指有一定概率没有任何事件发生，这个设置是为了避免玩家通过让随即列表中的其他事件都不满足触发条件，从而触发稀有事件。</li>
<li>第五部分<code>first_valid</code>选取触发器返回 true 的第一个事件。</li>
<li><code>on_action</code>除了规定发生什么事件以外，也可以规定触发哪些<code>on_action</code>，接下来的第六、第七和第八部分和前面的<code>events, random_events, first_valid</code>很像，它们分别是该<code>on_action</code>会触发的其他<code>on_action</code>列表、随机<code>on_action</code>列表和<code>first_valid on_action</code>列表，前面第二部分的权重就是在这里用的。</li>
<li>接着的<code>effect</code>这里先不说明，因为我还没学。</li>
<li>最后<code>fallback</code>有点类似于编程语言中的函数返回值，它表示该<code>on_action</code>定义的返回<code>on_action</code>。如果没有事件/on_actions由该<code>on_action</code>触发，则该返回<code>on_action</code>会被调用。注意，要避免创建无限的返回循环，否则游戏可能会被阻止推进时间。</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在这一部分中，我们写一个很基础朴素的<code>on_action</code>，来略微了解一下。</p>
<ol>
<li><p>首先我们要完成一个如下<code>on_action</code>：当角色结婚时，弹出第一个事件，1天后弹出第2个事件，10天或15天后弹出第3个事件，3个事件就很随意了。</p>
</li>
<li><p>那么首先，我们先写3个事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; test_action</span><br><span class="line">test_action.1001 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; test_action.1001.t</span><br><span class="line">	desc &#x3D; test_action.1001.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1001.option.a</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1001.option.b</span><br><span class="line">		trigger_event &#x3D; give_money.1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_action.1002 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; test_action.1002.t</span><br><span class="line">	desc &#x3D; test_action.1002.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1002.option.a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_action.1003 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; test_action.1003.t</span><br><span class="line">	desc &#x3D; test_action.1003.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1003.option.a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意，<code>namespace</code>一定要写对（也就是数字id前面的字符串），不能写成别的，不然就找不到这些事件了。</p>
<p>一个反例就是一开始我没注意，namespace写成了test，于是无论怎么搞都只会触发这个文件中的最后一个事件（test_action.1003）。</p>
<p>事件对应的文本文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> test_action.1001.t:0 &quot;测试&quot;</span><br><span class="line"> test_action.1001.desc:0 &quot;测试一下action。&quot;</span><br><span class="line"> test_action.1001.option.a:0 &quot;好耶！&quot;</span><br><span class="line"> test_action.1001.option.b:0 &quot;来点钱呗！&quot;</span><br><span class="line"></span><br><span class="line"> test_action.1002.t:0 &quot;测试2&quot;</span><br><span class="line"> test_action.1002.desc:0 &quot;测试一下多个事件。&quot;</span><br><span class="line"> test_action.1002.option.a:0 &quot;嗯嗯！&quot;</span><br><span class="line"></span><br><span class="line">  test_action.1003.t:0 &quot;测试3&quot;</span><br><span class="line">  test_action.1003.desc:0 &quot;测试一下delay。&quot;</span><br><span class="line">  test_action.1003.option.a:0 &quot;加油！&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备好事件以后，就可以开始写<code>on_action</code>文件了。根据需求，我们的<code>on_action</code>应该是<code>on_marriage</code>，其中只包含<code>events</code>块。内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on_marriage &#x3D; &#123;</span><br><span class="line">	events &#x3D; &#123;</span><br><span class="line">		test_action.1001</span><br><span class="line">		delay &#x3D; &#123; days &#x3D; 1 &#125;</span><br><span class="line">		test_action.1002</span><br><span class="line">		delay &#x3D; &#123; days &#x3D; &#123; 10 15 &#125; &#125;</span><br><span class="line">		test_action.1003</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来检查一下代码结构，看每个文件是否都在其对应的地方，我的代码结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- common</span><br><span class="line">	- on_action</span><br><span class="line">		test_on_action.txt</span><br><span class="line">- events</span><br><span class="line">	test_action_events.txt</span><br><span class="line">- localization</span><br><span class="line">	-simp_chinese</span><br><span class="line">		-event_localization</span><br><span class="line">			test_action_l_simp_chinses.yml</span><br></pre></td></tr></table></figure>
<p>实际上文件名并不严格要求按这个来，文件层级也不是特别严格，比如events里再套一层文件夹也没关系。</p>
<p>此外，<code>test_action_events</code>事件中某个选项会触发之前写过的<code>give_money_events</code>，这个事件和其相关文件在此就不列出了。</p>
</li>
<li><p>接下来进游戏加载mod，可以看到如下效果：</p>
<p>结婚当天（9月23日）触发第一个事件</p>
<p><img src="https://i.loli.net/2020/12/25/24QNcT3LekhHtpA.png" alt="image-20201225205736201"></p>
</li>
</ol>
<p>一天后（9月24日）触发第二个事件</p>
<p><img src="https://i.loli.net/2020/12/25/yA7d2Hzn9tMolkp.png" alt="image-20201225205913496"></p>
<p>15天后（10月8日）触发第3个事件</p>
<p><img src="https://i.loli.net/2020/12/25/PeXHlhZViFoK5zM.png" alt="image-20201225210107079"></p>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>除了一些游戏本身已经写好的<code>on_action</code>以外，我们也可以自己写<code>on_action</code>，并在决议、事件或其他会触发<code>on_action</code>的时候调用，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trigger_event &#x3D; &#123;</span><br><span class="line">	on_action &#x3D; on_action_name</span><br><span class="line">	days&#x2F;months&#x2F;years &#x3D; X  	# 可选项，可以没有</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="现有的on-action"><a href="#现有的on-action" class="headerlink" title="现有的on_action"></a>现有的<code>on_action</code></h2><p>在这一部分中我整理列出了游戏本体中的一系列<code>on_action</code>的名称和触发条件（其实是根据名称猜的，所以可能有错），具体效果就不说明了。（实在是太多了……）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别（文件名）</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">结盟（alliance_on_actions）</td>
<td style="text-align:center">on_alliance_added</td>
<td style="text-align:center">结成同盟</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_alliance_removed</td>
<td style="text-align:center">同盟到期移除</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_alliance_broken</td>
<td style="text-align:center">同盟破裂</td>
</tr>
<tr>
<td style="text-align:center">军队（army_on_actions）</td>
<td style="text-align:center">on_army_monthly</td>
<td style="text-align:center">玩家拥有的军队每30天自动触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_county_occupied</td>
<td style="text-align:center">当一个county完全被占领时触发，如果是被province owner重新占领则不触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_siege_completion</td>
<td style="text-align:center">当围攻完成时触发，如果是被province owner重新占领则不触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_siege_looting</td>
<td style="text-align:center">当围攻掠夺某一土地时触发（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_army_enter_province</td>
<td style="text-align:center">军队进入一个province时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_action_start</td>
<td style="text-align:center">突袭发生时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_action_completion</td>
<td style="text-align:center">突袭结束时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_action_weekly</td>
<td style="text-align:center">突袭过程中每7天触发一次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_loot_delivered</td>
<td style="text-align:center">当袭击者返回自己的领土并存入战利品时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_defeat_raid_army</td>
<td style="text-align:center">当突袭失败且战利品被盗时触发（？）</td>
</tr>
<tr>
<td style="text-align:center">战争（battle_on_actions）</td>
<td style="text-align:center">on_battle_owner_battle_end</td>
<td style="text-align:center">战争结束时，对战争双方触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_commander_battle_end</td>
<td style="text-align:center">战争结束时，对战争双方指挥官触发</td>
</tr>
<tr>
<td style="text-align:center">生日（birthday）</td>
<td style="text-align:center">on_birthday</td>
<td style="text-align:center">每个生日触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_specific_birthday</td>
<td style="text-align:center">几个特殊年龄的生日触发（3、6、10、15、16）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birthday_childhood</td>
<td style="text-align:center">未成年且可以受教育的年龄触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_graceful_aging_birthday</td>
<td style="text-align:center">这个没注释，我也没看懂</td>
</tr>
<tr>
<td style="text-align:center">人物等级（character_levels）</td>
<td style="text-align:center">on_piety_level_gain</td>
<td style="text-align:center">信仰等级提升时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_piety_level_loss</td>
<td style="text-align:center">信仰等级降低时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_prestige_level_gain</td>
<td style="text-align:center">声望等级提升时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_prestige_level_loss</td>
<td style="text-align:center">声望等级降低时触发</td>
</tr>
<tr>
<td style="text-align:center">孩子出生（child_birth_on_actions）</td>
<td style="text-align:center">on_birth_mother</td>
<td style="text-align:center">生娃时对孩他妈触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birth_father</td>
<td style="text-align:center">生娃时对孩他爸触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birth_real_father</td>
<td style="text-align:center">生娃时对亲生父亲触发（只在亲生父亲和法理父亲不一样时触发）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birth_child</td>
<td style="text-align:center">对新生儿触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_pregnancy_mother</td>
<td style="text-align:center">对怀孕状态的母亲触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_pregnancy_father</td>
<td style="text-align:center">对怀孕状态的父亲触发（<strong>这不是指男性怀孕</strong>）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_pregnancy_ended_mother</td>
<td style="text-align:center">怀孕结束时对母亲触发</td>
</tr>
<tr>
<td style="text-align:center">儿童时期（childhood_on_actions）</td>
<td style="text-align:center">child_personality_gain</td>
<td style="text-align:center">儿童性格特质等的获得</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_ongoing</td>
<td style="text-align:center">儿童时期触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_3rd_birthday</td>
<td style="text-align:center">3岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_6th_birthday</td>
<td style="text-align:center">6岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_10th_birthday</td>
<td style="text-align:center">10岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_15th_birthday</td>
<td style="text-align:center">15岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_16th_birthday</td>
<td style="text-align:center">16岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_action_add_sexuality</td>
<td style="text-align:center">获得性取向后触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birthday_education_events</td>
<td style="text-align:center">教育事件触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_education_boost</td>
<td style="text-align:center">检查儿童是否需要教育</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_education</td>
<td style="text-align:center">教育事件的触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_education_patronage</td>
<td style="text-align:center">patronage-forcused或者scholarly 配偶会给儿童教育加分，这个赞助我没理解是什么意思，scholarly应该是指学识属性高</td>
</tr>
<tr>
<td style="text-align:center">战斗（combat_on_actions）</td>
<td style="text-align:center">on_combat_end_winner</td>
<td style="text-align:center">对打赢了的一方触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_combat_end_loser</td>
<td style="text-align:center">对打输了的一方触发</td>
</tr>
<tr>
<td style="text-align:center">内阁（councillor_on_actions）</td>
<td style="text-align:center">on_leave_council</td>
<td style="text-align:center">内阁成员辞职时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_fired_from_council</td>
<td style="text-align:center">领主从内阁解雇该角色时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">organize_the_levies_marshal_task_side_effects</td>
<td style="text-align:center">军事统帅任务事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">train_commanders_success_effect</td>
<td style="text-align:center">训练指挥官成功事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">train_commanders_marshal_task_side_effects</td>
<td style="text-align:center">训练指挥官军事统帅事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_increase_control_side_effects</td>
<td style="text-align:center">增强控制力任务事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_foreign_affairs_side_effects</td>
<td style="text-align:center">外交事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_domestic_affairs_side_effects</td>
<td style="text-align:center">国内事务列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_integrate_title_side_effects</td>
<td style="text-align:center">合并头衔事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_fabricate_claim_success_effect</td>
<td style="text-align:center">伪造宣称成功事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_collect_taxes_side_effects</td>
<td style="text-align:center">收税事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_develop_county_side_effects</td>
<td style="text-align:center">发展事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_promote_culture_side_effects</td>
<td style="text-align:center">文化事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_religious_relations_side_effects</td>
<td style="text-align:center">宗教关系事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_convert_side_effects</td>
<td style="text-align:center">转变文化事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_fabricate_claim_side_effects</td>
<td style="text-align:center">伪造宣称事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_support_schemes_side_effects</td>
<td style="text-align:center">支持密谋事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_disrupt_schemes_side_effects</td>
<td style="text-align:center">打断密谋事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_find_secrets_outcome</td>
<td style="text-align:center">寻找秘密的结果</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_find_secrets_reveal_selection</td>
<td style="text-align:center">揭示秘密选择列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_find_secrets_side_effects</td>
<td style="text-align:center">寻找秘密事件列表</td>
</tr>
<tr>
<td style="text-align:center">伯爵领（county_on_actions）</td>
<td style="text-align:center">on_county_faith_change</td>
<td style="text-align:center">伯爵领改信时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_county_culture_change</td>
<td style="text-align:center">伯爵领改文化时触发</td>
</tr>
<tr>
<td style="text-align:center">宫廷（court_maintenance_on_actions）</td>
<td style="text-align:center">on_join_court</td>
<td style="text-align:center">角色加入宫廷时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_leave_court</td>
<td style="text-align:center">角色离开宫廷时触发</td>
</tr>
<tr>
<td style="text-align:center">廷臣宾客（courtier_guest_management_on_actions）</td>
<td style="text-align:center">on_courtier_decided_to_move_to_pool</td>
<td style="text-align:center">廷臣打算离开时针对该廷臣触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_courtier_ready_to_move_to_pool</td>
<td style="text-align:center">廷臣准备好离开时针对该廷臣触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_guest_arrived_from_pool</td>
<td style="text-align:center">宾客到达时针对该宾客触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_guest_ready_to_move_to_pool</td>
<td style="text-align:center">宾客准备好离开时针对宾客触发</td>
</tr>
<tr>
<td style="text-align:center">文化（culture_on_actions）</td>
<td style="text-align:center">on_culture_era_changed</td>
<td style="text-align:center">文化区域改变时对该文化触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_character_culture_change</td>
<td style="text-align:center">角色改文化时对该角色触发</td>
</tr>
<tr>
<td style="text-align:center">死亡（death）</td>
<td style="text-align:center">on_death</td>
<td style="text-align:center">死亡时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_natural_death_second_chance</td>
<td style="text-align:center">角色即将自然死亡，但通过脚本获得第二次生命时触发</td>
</tr>
<tr>
<td style="text-align:center">宗族（dynasty_on_actions）</td>
<td style="text-align:center">on_dynasty_created</td>
<td style="text-align:center">建立宗族时触发</td>
</tr>
<tr>
<td style="text-align:center">游戏开始（game_start）</td>
<td style="text-align:center">on_game_start</td>
<td style="text-align:center">游戏开局一系列历史信息生成后触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_game_start_after_lobby</td>
<td style="text-align:center">进入游戏后触发，主要是和游戏规则相关的内容</td>
</tr>
<tr>
<td style="text-align:center">健康（health_on_actions）</td>
<td style="text-align:center">yearly_health_pulse</td>
<td style="text-align:center">每年的健康事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">disease_outbreak_pulse</td>
<td style="text-align:center">随机生病触发事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wounded_recovery_pulse</td>
<td style="text-align:center">伤口恢复触发事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit_suicide</td>
<td style="text-align:center">决议自杀触发</td>
</tr>
<tr>
<td style="text-align:center">骑士团（holy_order_on_actions）</td>
<td style="text-align:center">on_holy_order_new_lease</td>
<td style="text-align:center">骑士团获得领地（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_holy_order_hired</td>
<td style="text-align:center">骑士团被雇佣</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_holy_order_destroyed</td>
<td style="text-align:center">骑士团被解散</td>
</tr>
<tr>
<td style="text-align:center">骑士（knight_on_actions）</td>
<td style="text-align:center">on_knight_combat_pulse</td>
<td style="text-align:center">战争中每天针对骑士触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_commander_combat_pulse</td>
<td style="text-align:center">战争中每天对指挥官触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_commander_combat_finished</td>
<td style="text-align:center">战争后对指挥官触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_army_combat_finished</td>
<td style="text-align:center">战争后对每个参战军队触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">varangian_ongoing</td>
<td style="text-align:center">针对Varangian guard触发</td>
</tr>
<tr>
<td style="text-align:center">婚姻（marriage_concubinage）</td>
<td style="text-align:center">on_marriage</td>
<td style="text-align:center">结婚时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_divorce</td>
<td style="text-align:center">离婚时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_concubinage</td>
<td style="text-align:center">角色成为他人侧室时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_concubinage_end</td>
<td style="text-align:center">角色不当侧室时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_betrothal_broken</td>
<td style="text-align:center">婚约破裂时触发</td>
</tr>
<tr>
<td style="text-align:center">监狱（prison_on_actions）</td>
<td style="text-align:center">on_imprison</td>
<td style="text-align:center">被抓时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_release_from_prison</td>
<td style="text-align:center">被放时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">quarterly_prison_maintenance_pulse</td>
<td style="text-align:center">住监狱过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">dungeon_ongoing</td>
<td style="text-align:center">关地牢过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">house_arrest_ongoing</td>
<td style="text-align:center">软禁时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">escape_from_prison</td>
<td style="text-align:center">试图逃出监狱时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">escape_from_prison_success</td>
<td style="text-align:center">成功逃出监狱时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">escape_from_prison_failure</td>
<td style="text-align:center">逃跑失败触发</td>
</tr>
<tr>
<td style="text-align:center">领地（realm_maintenance_on_actions）</td>
<td style="text-align:center">realm_maintenance_quarterly_pulse</td>
<td style="text-align:center">当领主的过程中随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">in_debt_county_corruption_pulse</td>
<td style="text-align:center">负债时增加腐败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">low_control_pulse</td>
<td style="text-align:center">控制力较低时触发（会增加腐败）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">high_countrol_pulse</td>
<td style="text-align:center">高控制力时触发（移除腐败）（这里的countrol真的没问题吗…）</td>
</tr>
<tr>
<td style="text-align:center">宗教（religion_on_actions）</td>
<td style="text-align:center">on_faith_created</td>
<td style="text-align:center">创建信仰时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_faith_conversion</td>
<td style="text-align:center">转变信仰时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_character_faith_change</td>
<td style="text-align:center">人物改信时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_faith_monthly</td>
<td style="text-align:center">每种信仰每个月触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">faith_holy_order_land_acquisition_pulse</td>
<td style="text-align:center">骑士团信仰</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">faith_heresy_events_pulse</td>
<td style="text-align:center">异端事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">faith_fervor_events_pulse</td>
<td style="text-align:center">宗教热情事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pagan_conversion_pulse</td>
<td style="text-align:center">异教徒转变事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_potential_great_holy_war_invalidation</td>
<td style="text-align:center">圣战目标无效时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_great_holy_war_invalidation</td>
<td style="text-align:center">上一个没找到新目标时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_great_holy_war_countdown_end</td>
<td style="text-align:center">圣战开始的倒计时为0时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_great_holy_war_participant_replaced</td>
<td style="text-align:center">圣战中角色被替换时触发</td>
</tr>
<tr>
<td style="text-align:center">规则（ruler_designer）</td>
<td style="text-align:center">on_ruler_designer_finished</td>
<td style="text-align:center">新人物设计好后触发（应该是指那个自定义统治者属性的玩法）</td>
</tr>
<tr>
<td style="text-align:center">秘密（secret_on_actions）</td>
<td style="text-align:center">secrets_ongoing</td>
<td style="text-align:center">处理秘密事件时触发</td>
</tr>
<tr>
<td style="text-align:center">压力应对决策（主要是不同特质会有特殊事件）（stress_coping_decisions_on_actions）</td>
<td style="text-align:center">stress_loss_drunkard</td>
<td style="text-align:center">酒鬼减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_hashishiyah</td>
<td style="text-align:center">瘾君子减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_rakish</td>
<td style="text-align:center">放荡者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_reclusive</td>
<td style="text-align:center">隐居减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_irritable</td>
<td style="text-align:center">烦躁减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_flagellant</td>
<td style="text-align:center">自鞭笞者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_profligate</td>
<td style="text-align:center">挥霍减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_improvident</td>
<td style="text-align:center">缺乏远见者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_contrite</td>
<td style="text-align:center">懊悔减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_comfort_eater</td>
<td style="text-align:center">食以慰藉减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_inappetetic</td>
<td style="text-align:center">没有食欲减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_journaller</td>
<td style="text-align:center">写日记者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_confider</td>
<td style="text-align:center">倾诉者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_athletic</td>
<td style="text-align:center">健身减压时触发</td>
</tr>
<tr>
<td style="text-align:center">压力（stress_on_actions）</td>
<td style="text-align:center">stress_pulse</td>
<td style="text-align:center">暂时忽略，注释说这个块可能会被删</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_reduced</td>
<td style="text-align:center">压力等级降低时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_1</td>
<td style="text-align:center">压力等级变为1时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_2</td>
<td style="text-align:center">压力等级变为2时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_3</td>
<td style="text-align:center">压力等级变为3时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_4</td>
<td style="text-align:center">压力等级变为4时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_1_event</td>
<td style="text-align:center">压力达到1级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_2_event</td>
<td style="text-align:center">压力达到2级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_3_event</td>
<td style="text-align:center">压力达到3级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_1_event_prison</td>
<td style="text-align:center">角色在监狱中，压力达到1级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_2_event_prison</td>
<td style="text-align:center">角色在监狱中，压力达到2级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_3_event_prison</td>
<td style="text-align:center">角色在监狱中，压力达到3级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center">头衔（title_on_actions）</td>
<td style="text-align:center">on_title_destroyed</td>
<td style="text-align:center">头衔被销毁时对头衔持有者触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_gain</td>
<td style="text-align:center">头衔获得时对该头衔的新持有者触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_gain_inheritance</td>
<td style="text-align:center">继承头衔时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_gain_usurpation</td>
<td style="text-align:center">篡夺头衔时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_lost</td>
<td style="text-align:center">失去头衔时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_explicit_claim_gain</td>
<td style="text-align:center">获得宣称时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_explicit_claim_lost</td>
<td style="text-align:center">失去宣称时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_rank_up</td>
<td style="text-align:center">头衔改变使角色升级时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_rank_down</td>
<td style="text-align:center">头衔改变使角色降级时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_vassal_gained</td>
<td style="text-align:center">得到封臣时触发</td>
</tr>
<tr>
<td style="text-align:center">特质（traits_on_actions）</td>
<td style="text-align:center">assign_trait_events</td>
<td style="text-align:center">到新压力等级时获取特质</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">assign_trait_ai_on_action</td>
<td style="text-align:center">AI随机获取特质的触发系统</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">assign_trait_on_action</td>
<td style="text-align:center">获取特殊特质</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ongoing_trait_events</td>
<td style="text-align:center">持有特殊特质时触发</td>
</tr>
<tr>
<td style="text-align:center">教程（tutorial）</td>
<td style="text-align:center">on_game_start_with_tutorial</td>
<td style="text-align:center">用教程开局时触发</td>
</tr>
<tr>
<td style="text-align:center">战争（war_on_actions）</td>
<td style="text-align:center">on_war_transferred</td>
<td style="text-align:center">战争中防御者改变时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_join_war_as_secondary</td>
<td style="text-align:center">角色作为战争的次要攻击者/次要防御者时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_started</td>
<td style="text-align:center">战争开始时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_won_attacker</td>
<td style="text-align:center">攻方赢得战争时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_won_defender</td>
<td style="text-align:center">守方赢得战争时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_white_peace</td>
<td style="text-align:center">战争无条件和平时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_invalidated</td>
<td style="text-align:center">战争无效时触发</td>
</tr>
<tr>
<td style="text-align:center">体重（weight_on_actions）</td>
<td style="text-align:center">on_weight_changed</td>
<td style="text-align:center">体重改变时触发（会触发一系列前面健康中的on_action）</td>
</tr>
<tr>
<td style="text-align:center">巫师（witch_on_actions）</td>
<td style="text-align:center">convert_to_witchcraft_failure_outcome</td>
<td style="text-align:center">转巫师失败时触发</td>
</tr>
<tr>
<td style="text-align:center">年度（yearly_on_actions）</td>
<td style="text-align:center">yearly_global_pulse</td>
<td style="text-align:center">每年1月1日触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">yearly_playable_pulse</td>
<td style="text-align:center">每年固定时间对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">three_year_playable_pulse</td>
<td style="text-align:center">每3年对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">five_year_playable_pulse</td>
<td style="text-align:center">每5年对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">quarterly_playable_pulse</td>
<td style="text-align:center">每季度对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">random_yearly_playable_pulse</td>
<td style="text-align:center">每年随机日期对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">random_yearly_everyone_pulse</td>
<td style="text-align:center">每年随机日期对所有角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">five_year_everyone_pulse</td>
<td style="text-align:center">每5年对所有角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">three_year_pool_pulse</td>
<td style="text-align:center">每3年对穷人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">prison_maintenance_pulse</td>
<td style="text-align:center">角色监狱里关着人时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ai_character_pulse</td>
<td style="text-align:center">对AI触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_yearly_events</td>
<td style="text-align:center">每年随机日期触发</td>
</tr>
<tr>
<td style="text-align:center">活动-宴会（activities/feast_on_actions）</td>
<td style="text-align:center">feast_main_event_selection</td>
<td style="text-align:center">选择宴会主事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_start_events</td>
<td style="text-align:center">宴会开始触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_default_event_selection</td>
<td style="text-align:center">默认宴会主事件中对参与者触发的事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_default_host_event_selection</td>
<td style="text-align:center">默认宴会主事件中对举办者触发的事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_default_fallback</td>
<td style="text-align:center">宴会默认的返回事件</td>
</tr>
<tr>
<td style="text-align:center">活动-打猎（activities/hunt_on_actions）</td>
<td style="text-align:center">hunt_start_events</td>
<td style="text-align:center">打猎开始时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hunt_random_pulse</td>
<td style="text-align:center">打猎过程中随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hunt_end_pulse</td>
<td style="text-align:center">打猎结束触发</td>
</tr>
<tr>
<td style="text-align:center">活动-朝圣（activities/pilgrimage_on_actions）</td>
<td style="text-align:center">pilgrimage_setup</td>
<td style="text-align:center">朝圣开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_journey_events</td>
<td style="text-align:center">朝圣过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hajj_journey_events</td>
<td style="text-align:center">伊斯兰朝圣过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_journey_event_fallback</td>
<td style="text-align:center">朝圣默认的返回事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_destination_events</td>
<td style="text-align:center">朝圣目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hajj_destination_events</td>
<td style="text-align:center">伊斯兰目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">christian_destination_events</td>
<td style="text-align:center">基督徒目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">jewish_destination_events</td>
<td style="text-align:center">犹太人目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">muslim_destination_events</td>
<td style="text-align:center">穆斯林目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hindu_destination_events</td>
<td style="text-align:center">印度教目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">buddhist_destination_events</td>
<td style="text-align:center">佛教徒目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">jain_destination_events</td>
<td style="text-align:center">耆那教目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">zoroastrian_destination_events</td>
<td style="text-align:center">拜火教目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">norse_destination_events</td>
<td style="text-align:center">挪威人目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">tengri_destination_events</td>
<td style="text-align:center">腾格里目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pagan_destination_events</td>
<td style="text-align:center">无信仰者目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_generic_destination_events</td>
<td style="text-align:center">普通目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_return_events</td>
<td style="text-align:center">朝圣后返回事件</td>
</tr>
<tr>
<td style="text-align:center">生活方式-外交（lifestyles/diplomacy_lifestyle_on_actions）</td>
<td style="text-align:center">diplomacy_lifestyle_progress_pulse</td>
<td style="text-align:center">外交生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_ongoing_events</td>
<td style="text-align:center">外交生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_common_events</td>
<td style="text-align:center">外交生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_uncommon_events</td>
<td style="text-align:center">外交生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_rare_events</td>
<td style="text-align:center">外交生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_unavailable_events</td>
<td style="text-align:center">外交生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_foreign_special_1010_court_visit_events</td>
<td style="text-align:center">外交事件链1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_foreign_special_1010_court_visit_interesting_relation_spy_outcome_events</td>
<td style="text-align:center">外交事件链2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commission_epic_ongoing</td>
<td style="text-align:center">制作家族史诗事件</td>
</tr>
<tr>
<td style="text-align:center">生活方式-普通（lifestyles/general_lifestyle_on_actions）</td>
<td style="text-align:center">on_perks_refunded</td>
<td style="text-align:center">玩家改生活方式时退还技能触发</td>
</tr>
<tr>
<td style="text-align:center">生活方式-谋略（lifestyles/intrigue_lifestyle_on_actions）</td>
<td style="text-align:center">intrigue_lifestyle_progress_pulse</td>
<td style="text-align:center">谋略生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_ongoing_events</td>
<td style="text-align:center">谋略生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_common_events</td>
<td style="text-align:center">谋略生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_uncommon_events</td>
<td style="text-align:center">谋略生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_rare_events</td>
<td style="text-align:center">谋略生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_unavailable_events</td>
<td style="text-align:center">谋略生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center">生活方式-学识（lifestyles/learning_lifestyle_on_actions）</td>
<td style="text-align:center">learning_lifestyle_progress_pulse</td>
<td style="text-align:center">学识生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_ongoing_events</td>
<td style="text-align:center">学识生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_common_events</td>
<td style="text-align:center">学识生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_uncommon_events</td>
<td style="text-align:center">学识生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_rare_events</td>
<td style="text-align:center">学识生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_unavailable_events</td>
<td style="text-align:center">学识生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">book_translation_story_events</td>
<td style="text-align:center">翻译书事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">mystic_communion_side_effect_events</td>
<td style="text-align:center">神秘圣餐事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center">生活方式-军事（lifestyles/martial_lifestyle_on_actions）</td>
<td style="text-align:center">martial_lifestyle_progress_pulse</td>
<td style="text-align:center">军事生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_ongoing_events</td>
<td style="text-align:center">军事生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_common_events</td>
<td style="text-align:center">军事生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_uncommon_events</td>
<td style="text-align:center">军事生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_rare_events</td>
<td style="text-align:center">军事生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_unavailable_events</td>
<td style="text-align:center">军事生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">horse_riding_accident_outcome</td>
<td style="text-align:center">骑马意外事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">search_for_troops_event_selection</td>
<td style="text-align:center">搜索部队事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_offer</td>
<td style="text-align:center">获得指挥官特质的机会</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_test</td>
<td style="text-align:center">获得指挥官特质的测试</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_success</td>
<td style="text-align:center">成功获得指挥官特质</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_failure</td>
<td style="text-align:center">未能获得指挥官特质</td>
</tr>
<tr>
<td style="text-align:center">生活方式-管理（lifestyles/stewardship_lifestyle_on_actions）</td>
<td style="text-align:center">stewardship_lifestyle_progress_pulse</td>
<td style="text-align:center">管理生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_ongoing_events</td>
<td style="text-align:center">管理生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_common_events</td>
<td style="text-align:center">管理生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_uncommon_events</td>
<td style="text-align:center">管理生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_rare_events</td>
<td style="text-align:center">管理生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_unavailable_events</td>
<td style="text-align:center">管理生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">map_painting_event_selection</td>
<td style="text-align:center">绘制地图选项</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">map_painting_outcome</td>
<td style="text-align:center">绘制地图结果</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_road_building_chain</td>
<td style="text-align:center">修路事件链</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_road_building_events</td>
<td style="text-align:center">修路事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_domesday</td>
<td style="text-align:center">末日审判事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_domesday_end</td>
<td style="text-align:center">默认审判结束事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_duty_special_2000_mediation_stage_1</td>
<td style="text-align:center">调解事件阶段1（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_duty_special_2000_mediation_stage_2</td>
<td style="text-align:center">调解事件阶段2（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_duty_special_2000_mediation_background_events</td>
<td style="text-align:center">调解背景事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sell_titles_side_effect_events</td>
<td style="text-align:center">买卖头衔副作用事件</td>
</tr>
<tr>
<td style="text-align:center">关系-主教（relations/bishop_on_actions）</td>
<td style="text-align:center">bishop_ongoing</td>
<td style="text-align:center">有主教时随机触发</td>
</tr>
<tr>
<td style="text-align:center">关系-父母（relations/parent_on_actions）</td>
<td style="text-align:center">parent_ongoing</td>
<td style="text-align:center">有父母时随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">parent_meddling_outcome</td>
<td style="text-align:center">父母干涉的结果</td>
</tr>
<tr>
<td style="text-align:center">关系-关系（relations/relation_on_actions）</td>
<td style="text-align:center">relation_upgrade_quarterly_pulse</td>
<td style="text-align:center">关系升级事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_quarterly_pulse</td>
<td style="text-align:center">恋人事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing</td>
<td style="text-align:center">恋人事件（一年一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing_fallback</td>
<td style="text-align:center">恋人事件的返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing_distance</td>
<td style="text-align:center">异地恋事件（一年一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing_distance_fallback</td>
<td style="text-align:center">异地恋事件返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_status_changes</td>
<td style="text-align:center">恋爱状态改变</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_set_relation_lover</td>
<td style="text-align:center">有恋人时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_lover</td>
<td style="text-align:center">失去恋人时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">friendship_quarterly_pulse</td>
<td style="text-align:center">朋友事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">friendship_status_changes</td>
<td style="text-align:center">朋友状态改变</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">friendship_ongoing</td>
<td style="text-align:center">朋友事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_set_relation_friend</td>
<td style="text-align:center">得到朋友</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_friend</td>
<td style="text-align:center">失去朋友（只和关系破裂有关，不会因为朋友凉了而触发）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_death_relation_friend</td>
<td style="text-align:center">朋友去世</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rival_quarterly_pulse</td>
<td style="text-align:center">仇敌事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rival_relation_changes</td>
<td style="text-align:center">仇敌改变事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rivalry_ongoing</td>
<td style="text-align:center">仇敌事件（一年一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rivalry_ongoing_fallback</td>
<td style="text-align:center">仇敌事件返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_set_relation_rival</td>
<td style="text-align:center">得到仇敌</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_rival</td>
<td style="text-align:center">失去仇敌</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">mentor_student_quarterly_pulse</td>
<td style="text-align:center">师生事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">mentor_student_relation_changes</td>
<td style="text-align:center">师生关系改变</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_guardian</td>
<td style="text-align:center">解除监护人时对被监护人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_death_relation_guardian</td>
<td style="text-align:center">有监护人的被监护人死亡时，对被监护人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_ward</td>
<td style="text-align:center">解除监护人时对监护人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_death_relation_ward</td>
<td style="text-align:center">有被监护人的监护人死亡时，对监护人触发</td>
</tr>
<tr>
<td style="text-align:center">关系-兄弟（relations/sibling_on_actions）</td>
<td style="text-align:center">sibling_quarterly_pulse</td>
<td style="text-align:center">兄弟事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sibling_statuses</td>
<td style="text-align:center">兄弟状态</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ongoing_sibling</td>
<td style="text-align:center">兄弟事件</td>
</tr>
<tr>
<td style="text-align:center">关系-配偶（relations/spouse_on_actions）</td>
<td style="text-align:center">spouse_ongoing</td>
<td style="text-align:center">配偶事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">spouse_councillor_default_on_action</td>
<td style="text-align:center">配偶内阁事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_politics_setup</td>
<td style="text-align:center">接下来的几个应该都是指配偶和内阁其他人的互动事件，不太确定，因此不写了。</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_politics_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">chivalry_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">chivalry_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_intrigue_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_intrigue_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">manage_domain_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">manage_domain_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">patronage_setup</td>
<td style="text-align:center">配偶赞助开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">patronage_task_on_action</td>
<td style="text-align:center">配偶赞助任务</td>
</tr>
<tr>
<td style="text-align:center">关系-封臣（relations/vassal_on_actions）</td>
<td style="text-align:center">on_vassal_become_powerful</td>
<td style="text-align:center">封臣变强力时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">vassal_ongoing</td>
<td style="text-align:center">有封臣时触发</td>
</tr>
<tr>
<td style="text-align:center">计谋-绑架（schemes/abduct_on_actions）</td>
<td style="text-align:center">abduct_setup</td>
<td style="text-align:center">绑架开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">standard_abduct_method_setup</td>
<td style="text-align:center">绑架方式（？没绑架过，不清楚流程）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">abduct_succeeded</td>
<td style="text-align:center">绑架成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">abduct_failed</td>
<td style="text-align:center">绑架失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">abduct_ongoing</td>
<td style="text-align:center">绑架进行中</td>
</tr>
<tr>
<td style="text-align:center">计谋-拉拢（schemes/befriend_on_actions）</td>
<td style="text-align:center">befriend_ongoing</td>
<td style="text-align:center">交友进行中</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_dislike_ongoing</td>
<td style="text-align:center">和不喜欢的人交友</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_rival_ongoing</td>
<td style="text-align:center">和仇敌交友</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_critical_success</td>
<td style="text-align:center">交友成功关键点（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_success</td>
<td style="text-align:center">交友成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_failure</td>
<td style="text-align:center">交友失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_critical_failure</td>
<td style="text-align:center">交友失败关键点（？不确定）</td>
</tr>
<tr>
<td style="text-align:center">计谋-宣称权位（schemes/claim_throne_on_actions）</td>
<td style="text-align:center">claim_throne_setup</td>
<td style="text-align:center">宣称开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">standard_claim_throne_method_setup</td>
<td style="text-align:center">宣称方法</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">claim_throne_succeeded</td>
<td style="text-align:center">宣称成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">claim_throne_failed</td>
<td style="text-align:center">宣称失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">claim_throne_ongoing</td>
<td style="text-align:center">宣称进行中</td>
</tr>
<tr>
<td style="text-align:center">计谋-廷臣（schemes/court_on_actions）</td>
<td style="text-align:center">court_ongoing</td>
<td style="text-align:center">廷臣事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_outcome</td>
<td style="text-align:center">廷臣事件结果</td>
</tr>
<tr>
<td style="text-align:center">计谋-私奔（schemes/elope_on_actions）</td>
<td style="text-align:center">elope_ongoing</td>
<td style="text-align:center">私奔进行时</td>
</tr>
<tr>
<td style="text-align:center">计谋-牵制（schemes/fabricate_hook_on_actions）</td>
<td style="text-align:center">abricate_hook_method_success_outcome</td>
<td style="text-align:center">伪造牵制成功结果</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">fabricate_hook_ongoing</td>
<td style="text-align:center">伪造牵制进行中</td>
</tr>
<tr>
<td style="text-align:center">计谋-谋杀（schemes/murder_on_actions）</td>
<td style="text-align:center">murder_method_selection</td>
<td style="text-align:center">（dbq这部分我懒得写了…）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">infant_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">child_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">incapable_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">dungeon_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">house_arrest_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">standard_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_save_roll</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_save_response</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_succeeded</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_failed</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_ongoing</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">计谋-勾引（schemes/seduce_on_actions）</td>
<td style="text-align:center">seduce_ongoing_milestone_1</td>
<td style="text-align:center">勾引阶段1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_ongoing_milestone_2</td>
<td style="text-align:center">勾引阶段2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_success</td>
<td style="text-align:center">勾引成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_generic_success</td>
<td style="text-align:center">勾引成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_failure</td>
<td style="text-align:center">勾引失败</td>
</tr>
<tr>
<td style="text-align:center">计谋-拉拢（schemes/sway_on_actions）</td>
<td style="text-align:center">sway_success</td>
<td style="text-align:center">拉拢成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sway_failure</td>
<td style="text-align:center">拉拢失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sway_ongoing</td>
<td style="text-align:center">拉拢进行时</td>
</tr>
<tr>
<td style="text-align:center">周期故事-猫（story_cycles/story_cycle_cat_on_actions）</td>
<td style="text-align:center">ongoing_cat_events</td>
<td style="text-align:center">有猫时触发的事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">story_cycle_cat_pet_decision_on_actions</td>
<td style="text-align:center">决议养猫</td>
</tr>
<tr>
<td style="text-align:center">周期故事-狗（story_cycles/story_cycle_dog_on_actions）</td>
<td style="text-align:center">ongoing_dog_events</td>
<td style="text-align:center">有狗时触发事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">story_cycle_dog_pet_decision_on_actions</td>
<td style="text-align:center">决议养狗</td>
</tr>
<tr>
<td style="text-align:center">周期故事-打猎神秘动物（story_cycle_hunt_mystical_animal_on_actions）</td>
<td style="text-align:center">ongoing_hunt_mystical_animal_events</td>
<td style="text-align:center">打猎时的神秘动物</td>
</tr>
<tr>
<td style="text-align:center">周期故事-谋杀系列（story_cycles/story_cycle_murders_at_court_on_actions）</td>
<td style="text-align:center">murders_at_court_events</td>
<td style="text-align:center">谋杀系列事件（就是那个很奇怪可怕的发现尸体等等一系列事件）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murders_at_court_confrontation</td>
<td style="text-align:center">最终结果</td>
</tr>
<tr>
<td style="text-align:center">周期故事-宴会？（story_cycles/story_cycle_party_baron_on_actions）</td>
<td style="text-align:center">party_baron_events</td>
<td style="text-align:center">看本地化文件是宴会上的事情，不知道这个要怎么解释</td>
</tr>
<tr>
<td style="text-align:center">周期故事-农民（story_cycles/story_cycle_peasant_affair_on_actions）</td>
<td style="text-align:center">peasant_affair_shows_up_at_court</td>
<td style="text-align:center">农民来时触发（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">peasant_affair_looking_for_peasant</td>
<td style="text-align:center">寻找农民</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">peasant_affair_peasant_at_court</td>
<td style="text-align:center">农民来找你时触发（比如想让你认个儿子）</td>
</tr>
<tr>
<td style="text-align:center">周期故事-重建罗马（story_cycles/story_cycle_roman_restoration_on_actions）</td>
<td style="text-align:center">on_action_roman_restoration_pulse</td>
<td style="text-align:center">重建罗马触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_action_orthodox_pentarchy_pulse</td>
<td style="text-align:center">拜占庭恢复五大牧首区</td>
</tr>
<tr>
<td style="text-align:center">周期故事-受尊敬的领主（story_cycles/story_cycle_statecraft_lifestyle_respected_liege_on_actions）</td>
<td style="text-align:center">ongoing_respected_liege_events</td>
<td style="text-align:center">受尊敬的领主（这块代码还没写，是空的）</td>
</tr>
<tr>
<td style="text-align:center">周期故事-战马（story_cycles/story_cycle_warhorse_on_actions）</td>
<td style="text-align:center">ongoing_warhorse_events</td>
<td style="text-align:center">有战马时随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">breed_warhorse</td>
<td style="text-align:center">战马繁殖事件</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode记录-1</title>
    <url>/2020/12/21/Leetcode%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">链接</a></p>
<p>给定一个整数数组<code>nums</code>和一个整数目标值<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>2 &lt;= <code>nums.length</code> &lt;= 103</li>
<li>-109 &lt;= <code>nums[i]</code> &lt;= 109</li>
<li>-109 &lt;= <code>target</code> &lt;= 109</li>
<li>只会存在一个有效答案</li>
</ol>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    * returnSize=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> result[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;numsSize; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]==target)&#123;</span><br><span class="line">                result[<span class="number">0</span>]=i;</span><br><span class="line">                result[<span class="number">1</span>]=j;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ol>
<li>指针没学好，所以其实还是没懂为什么一开始要指定<code>* returnSize=2;</code></li>
<li>是最普通的遍历判断是否正确的过程，没有什么复杂算法</li>
<li>第3行如果不用静态数组，则最后返回的时候数组生命周期就结束了，会返回一个空数组</li>
<li>还有一些同样思路的代码写法，但是输出的时候不对，总是输出<code>]</code>，猜测和OJ系统的gcc有关，暂且不管</li>
</ol>
<h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><p><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/" target="_blank" rel="noopener">参考链接</a></p>
<ol>
<li><p>哈希表（C语言的哈希表代码略长，所以改用python）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashtable = dict()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
</li>
<li><p>首尾递进查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sorted_id = sorted(range(len(nums)), key=<span class="keyword">lambda</span> k: nums[k])</span><br><span class="line">        head = <span class="number">0</span></span><br><span class="line">        tail = len(nums) - <span class="number">1</span></span><br><span class="line">        sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]]</span><br><span class="line">        <span class="keyword">while</span> sum_result != target:</span><br><span class="line">            <span class="keyword">if</span> sum_result &gt; target:</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum_result &lt; target:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]]</span><br><span class="line">        <span class="keyword">return</span> [sorted_id[head], sorted_id[tail]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-6</title>
    <url>/2020/12/16/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-6/</url>
    <content><![CDATA[<h1 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h1><h2 id="基础格式"><a href="#基础格式" class="headerlink" title="基础格式"></a>基础格式</h2><ol>
<li><p>特质相关的文件有两个，第一个是对特质的说明，存放在文件夹<code>Crusader Kings III\game\common\traits</code>中，文件名为<code>00_traits.txt</code>，同目录下有一个<code>_traits.info</code>是说明怎么写特质；第二个是本地化文本文件，<code>Crusader Kings III\game\localization\simp_chinese\traits_l_simp_chinese.yml</code>，其他语言的也是类似路径。</p>
</li>
<li><p>目前游戏里有277个特质，在<a href="https://ck3.parawikis.com/wiki/%E7%89%B9%E8%B4%A8" target="_blank" rel="noopener">wiki</a>中已经有人整理过特质的分类和效果等信息。</p>
</li>
<li><p>从<code>_traits.info</code>中我们可以看到，一个特质<code>trait_&lt;key&gt;</code>对应的描述在本地化文本中应该是<code>trait_&lt;key&gt;_desc</code>，而默认图标是<code>gfx/interface/icons/traits/&lt;trait&gt;.dds</code>文件。</p>
</li>
<li><p>特质默认加给玩家角色，也就是<code>root</code>。</p>
</li>
<li><p>显然，一个最基础的特质<code>test_trait</code>由3部分组成：</p>
<ol>
<li><p>特质图标：<code>gfx/interface/icons/traits/test_trait.dds</code></p>
</li>
<li><p>特质内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test_trait &#x3D; &#123;</span><br><span class="line">	index &#x3D; 278</span><br><span class="line">	desc &#x3D; &#123;</span><br><span class="line">		first_valid &#x3D; &#123;</span><br><span class="line">			triggered_desc &#x3D; &#123;</span><br><span class="line">				trigger &#x3D; &#123;</span><br><span class="line">					NOT &#x3D; &#123; exists &#x3D; this &#125;</span><br><span class="line">				&#125;</span><br><span class="line">				desc &#x3D; trait_test_trait_desc</span><br><span class="line">			&#125;</span><br><span class="line">			desc &#x3D; trait_test_trait_character_desc</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特质文本描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> # test traits</span><br><span class="line"> trait_test_trait:0 &quot;XXX&quot;</span><br><span class="line"> trait_test_trait_desc:0 &quot;XXX&quot;</span><br><span class="line"> trait_test_trait_character_desc:0 &quot;XXX&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要注意的是，在特质内容中，为了保证触发特效时该角色是存在的，我们需要进行<code>first_valid</code>来验证<code>Root</code>存在。</p>
</li>
<li><p>文本描述中，如果需要出现角色的名字，可以通过<code>[ROOT.GetCharacter.GetFirstNameNoTooltip]</code>来获取角色名。</p>
</li>
</ol>
</li>
<li><p>当我们按照上一条中，准备好对应的图标，并在mod文件夹中建立了<code>traits</code>文件夹和相应的特质文件，以及本地化内容也新建了文件，就会得到如下文件结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- test</span><br><span class="line">	- common</span><br><span class="line">		- traits</span><br><span class="line">			01_traits.txt</span><br><span class="line">	- gfx</span><br><span class="line">		- interface</span><br><span class="line">			- icons</span><br><span class="line">				- traits</span><br><span class="line">					test_trait.dds</span><br><span class="line">	- localization</span><br><span class="line">		- simp_chinese</span><br><span class="line">			- traits_test_l_simp_chinese.yml</span><br><span class="line">	descriptor.mod</span><br></pre></td></tr></table></figure>
<p>需要注意的是，特质文件和本地化文件的文件名本身并不是很重要，但是如果和CK3官方的那俩文件重名，则需要把那两个文件中的内容也原封不动复制过来，否则本身自带的特质就会都没法用。</p>
</li>
<li><p>准备好一系列文件以后，打开游戏通过<code>add_traits</code>指令增加特质，就可以看到对应的特质了。</p>
</li>
</ol>
<h2 id="一些具体设置"><a href="#一些具体设置" class="headerlink" title="一些具体设置"></a>一些具体设置</h2><ol>
<li>除了上述的文本描述以外，特质还可以增加很多具体设置，例如对角色的影响、获取的触发条件等等。以下内容是对<code>_traits.info</code>文件的翻译。</li>
<li><code>health</code>：表示该特质对健康的修正，例如在特质身心俱悉（<code>whole_of_body</code>）中，有一条<code>health = 0.5</code>，表示有该特质的角色健康+0.5。</li>
<li><code>fertility</code>：表示该特质对生育力的修正百分比，例如还是身心俱悉中，有一条<code>fertility = 0.2</code>表示该角色的生育力+25%。</li>
<li><code>inherit_chance</code>：表示该特质遗传给孩子的概率，例如特质梅毒<code>great_pox</code>中有一条<code>inherit_chance = 10</code>，表示遗传概率是10%。</li>
<li><code>birth</code>：表示有百分之多少的人会带着这个特质出生。</li>
<li><code>random_creation</code>：表示有百分之多少的人会带着这个特质被创造出来。和出生不一样的是，创造是指通过命令行生成和修改人物。不过根据检索，<code>00_traits</code>文件里的<code>birth</code>和<code>random_creation</code>都是一起出现的，且值相等。</li>
<li><code>triggered_opinion</code>：这一条应该是针对角色好感度修正特质的触发器，它包括以下内容：<ol>
<li><code>opinion_modifier</code>：修正的好感度类型</li>
<li><code>parameter</code>：要检查的布尔值参数</li>
<li><code>check_missing</code>：检查参数是否没设置（或设置为 false），而不是设置为 true</li>
<li><code>same_faith</code>：相同信仰</li>
<li><code>same_dynasty</code>：相同宗族</li>
<li><code>ignore_opinion_value_if_same_trait</code>：设置为<code>yes</code>的时候，会对有相同特质的角色不进行好感度修正，但是惩罚理由还在</li>
<li><code>male_only</code>和<code>female_only</code>很显然分别是仅限男性和仅限女性</li>
</ol>
</li>
<li><code>compatibility</code>：这是用于<code>compatibility_modifier</code>和<code>trait_compatibility</code>这两个触发器的，是检查特质持有者与列出的特质的兼容性。感觉是指获取某一特质后，再获取其他特质的概率会受这个列表值的修正。具体怎么用还不太明白，之后补充。</li>
<li><code>parent_inheritance_sex</code>：可以是<code>male/female/all</code>，表示该特质可以从父亲/母亲/双亲继承。</li>
<li><code>child_inheritance_sex</code>：值同上，表示该特质可以遗传给男孩/女孩/所有孩子。</li>
<li><code>genetic</code>：默认是<code>no</code>，如果被设置为<code>yes</code>，则表示特征可以是非活动状态。子级可以从活动和非活动父特征中继承该特征。活动特征继承为 100% 的机会，非活动特征为 50% 的机会。如果从父母两个成功继承该特征，则该特征将变为活动状态。如果仅从一个父级继承，则它是非活动状态。（可以理解成生物学基因的隐性显性）。</li>
<li><code>inherit_from_real_father</code>：是否可以从亲生父亲那里继承，其实不太懂这个和前面<code>parent_inheritance_sex</code>有什么不一样的。</li>
<li><code>enables_inbred</code>：概括来说这个标志为<code>yes</code>时意味着这个特质是近亲繁殖的。</li>
<li><code>good</code>：特质标识为好的（默认值是<code>no</code>，表示坏的）。</li>
<li><code>genetic_constraint_all</code>：这种遗传约束将在获得特征时应用。</li>
<li><code>forced_portrait_age_index</code>：年龄索引，可以设置多个，但是我还不知道年龄索引是什么东西，以后补充。</li>
<li><code>portrait_extremity_shift</code>：这个值是一个表示百分比的小数，角色获得对应特质时，每个变形基因都会按这个百分比向 0 或 1 移动，具体是0还是1看基因本身接近哪个，比如该值为0.25， 基因值为0.4，则0.4将向0偏移0.25，从而变成0.3。</li>
<li><code>ugliness_portrait_extremity_shift</code>：和上一条一样，但是获得此特质时，与角色最极端的单一特征（在公共/基因中定义）相关的每个变形基因都会按此百分比向 0 或 1 移动。关于这里的特征、基因等词还不太了解，以后再补充。</li>
<li><code>immortal</code>：设置为<code>yes</code>后，获得该特质的角色会停止视觉老化，使角色对自然死亡免疫。仍然可以被脚本杀死。生育能力将匹配视觉年龄。可以使用<code>set_immortal_age</code>更改视觉年龄。</li>
<li><code>physical, health_trait, fame</code>：这三个设置为<code>yes</code>则分别表示该特质是和物理、健康、名誉相关。</li>
<li><code>trait_exclusive_if_realm_contains</code>：这个值是<code>{}</code>，大括号里可以填东西，表示随机分配给指挥官时考虑的地形类型列表。只有当指挥官的文化包含具有列表中指定的地形类型之一的省时，才分配/考虑这些特征。</li>
<li><code>blocks_from_claim_inheritance</code>：设置为<code>yes</code>时，有该特质的角色无法继承头衔宣称。</li>
<li><code>blocks_from_claim_inheritance_from_dynasty</code>：同上，设置为<code>yes</code>时，有该特质的角色无法从宗族成员那里继承头衔宣称。</li>
<li><code>shown_in_ruler_designer</code>：默认是<code>yes</code>，设置为<code>yes</code>时，可以在自定义角色的那个地方的特质列表中看到该特质。</li>
<li><code>ruler_designer_cost</code>：默认是0，同上，是指自定义角色时该特质消耗的点数。</li>
<li><code>valid_sex</code>：可以是<code>all/male/female</code>，默认是<code>all</code>，表示该特质可以由什么性别的角色获得。</li>
</ol>
<h2 id="如何使角色得到特质"><a href="#如何使角色得到特质" class="headerlink" title="如何使角色得到特质"></a>如何使角色得到特质</h2><p>和命令行一样，在<code>mod</code>里需要角色获取特质的时候，<code>add_trait = trait_ID</code>即可。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-5</title>
    <url>/2020/11/08/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-5/</url>
    <content><![CDATA[<h1 id="条件式"><a href="#条件式" class="headerlink" title="条件式"></a>条件式</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>条件式的基本结构和CK2里一样，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &#x3D; &#123;</span><br><span class="line">	limit &#x3D; &#123;</span><br><span class="line">		# 条件</span><br><span class="line">	&#125;</span><br><span class="line">	# 符合条件时执行的指令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实条件式不仅限于if语句，在其他地方也会出现这样<code>limit = ...</code>的句式，用来表示执行指令的条件。</p>
<p>接下来沿用之前的例子，将送钱的事件写一个条件式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; give_money</span><br><span class="line">give_money.1 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; give_money.1.t</span><br><span class="line">	desc &#x3D; give_money.1.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.a</span><br><span class="line">		add_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; -500</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.b</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.c</span><br><span class="line">		if &#x3D; &#123;</span><br><span class="line">			limit &#x3D; &#123;</span><br><span class="line">				gold &gt;1000</span><br><span class="line">			&#125;</span><br><span class="line">			remove_short_term_gold &#x3D; 1000</span><br><span class="line">			add_prestige &#x3D; 500</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，现在第三个选项是有条件执行的，当金币大于1000时，会执行减少金钱增加虔诚的指令，而金币不足则不会执行。具体到游戏中，界面如下图，当右上角金币只有26的时候，第三个选项是没有直接影响；而金币超过1000时，则第三个选项变成了扣钱换虔诚。</p>
<p><img src="https://i.loli.net/2020/12/05/nUe1ExpMmFwiJgr.png" alt="image-20201205211819919"></p>
<p><img src="https://i.loli.net/2020/12/05/EMmug4AC7KRUFrS.png" alt="image-20201205212017719"></p>
<h2 id="增加分支"><a href="#增加分支" class="headerlink" title="增加分支"></a>增加分支</h2><p>在一些情况下，我们需要表达“如果满足条件，则执行A指令；反之，则执行B指令”，这种情况就不能简单地用上面的结构来实现，而是使用else语句，具体结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &#x3D; &#123;</span><br><span class="line">	limit &#x3D; &#123;</span><br><span class="line">		# 条件</span><br><span class="line">	&#125;</span><br><span class="line">	# 符合条件时执行的指令</span><br><span class="line">&#125;</span><br><span class="line">else &#x3D; &#123;</span><br><span class="line">	# 不符合条件时执行的指令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们希望，当金钱不够1000时加200虔诚，不扣钱，那就如下改写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.c</span><br><span class="line">	if &#x3D; &#123;</span><br><span class="line">		limit &#x3D; &#123;</span><br><span class="line">			gold &gt;1000</span><br><span class="line">		&#125;</span><br><span class="line">		remove_short_term_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; 500</span><br><span class="line">	&#125;</span><br><span class="line">	else &#x3D; &#123;</span><br><span class="line">		add_prestige &#x3D; 200</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体效果如下图，当金币够1000时，和前面一样；而金币不够1000时，则只有加200虔诚。</p>
<p><img src="https://i.loli.net/2020/12/05/42FCzK9NsnlEhZ5.png" alt="image-20201205213507855"></p>
<p><img src="https://i.loli.net/2020/12/05/VbFYSnlX19IqHAp.png" alt="image-20201205213724688"></p>
<ul>
<li>需要补充说明的是，CK2中没有else语句，而是通过增加break来实现分支的；相反，CK3中无法通过break来实现分支。</li>
</ul>
<h1 id="随机性结果"><a href="#随机性结果" class="headerlink" title="随机性结果"></a>随机性结果</h1><p>当我们希望某个选项的结果随机出现的时候，就需要用到<code>Random</code>，它有以下两种用法：</p>
<ol>
<li><p>该选项有一定概率得到某种结果，或者无事发生：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">random &#x3D; &#123;</span><br><span class="line">	chance &#x3D; 概率值</span><br><span class="line">	选项结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，我们将之前的事件中的第二个选项修改成如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random &#x3D; &#123;</span><br><span class="line">		chance &#x3D; 50</span><br><span class="line">		add_gold &#x3D; 1000</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个选项很容易理解，有50%的概率得到1000金币，游戏中的截图如下：</p>
<p><img src="https://i.loli.net/2020/12/10/GLtuAOkoBDZ4S8h.png" alt="image-20201210193754167"></p>
<p>顺带一提，明明是50%的概率，我却直到第5次才获得1000……</p>
</li>
<li><p>更多情况我们会希望得到多个随机结果，这时就要用<code>Random_list</code>，结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">random_list &#x3D; &#123;</span><br><span class="line">	概率1 &#x3D; &#123;</span><br><span class="line">		第一个结果</span><br><span class="line">	&#125;</span><br><span class="line">	概率2 &#x3D; &#123;</span><br><span class="line">		第二个结果</span><br><span class="line">	&#125;</span><br><span class="line">	概率3 &#x3D; &#123;</span><br><span class="line">		第三个结果</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种结构下，每个情况的触发概率并不是直接的百分比，而是该选项值占所有概率总和的百分比，具体来说，比如（30，30，15）这样的组合中，第一个选项的概率并不是30%，而是30/75，也就是40%。</p>
<p>我们再将刚才的事件进行如下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random_list &#x3D; &#123;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 1000</span><br><span class="line">		&#125;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 100</span><br><span class="line">		&#125;</span><br><span class="line">		15 &#x3D; &#123;</span><br><span class="line">			remove_short_term_gold &#x3D; 200</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样修改后，游戏中的截图如下：</p>
<p><img src="https://i.loli.net/2020/12/10/T1wtGmAWIkvqrCo.png" alt="image-20201210194729366"></p>
</li>
</ol>
<h2 id="有触发的随机性条件"><a href="#有触发的随机性条件" class="headerlink" title="有触发的随机性条件"></a>有触发的随机性条件</h2><p>虽然到目前为止还没学触发（Trigger），但大致意思应该能看懂，和前面if语句中的limit有点像。</p>
<p>如果某个随机选项有触发条件，那么当满足条件时，该选项的概率值才会参与计算，例如下面这个事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random_list &#x3D; &#123;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;</span><br><span class="line">				gold &gt; 1000</span><br><span class="line">			&#125;</span><br><span class="line">			add_gold &#x3D; 1000</span><br><span class="line">		&#125;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 100</span><br><span class="line">		&#125;</span><br><span class="line">		15 &#x3D; &#123;</span><br><span class="line">			remove_short_term_gold &#x3D; 200</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当金币不足1000时，可以看到游戏中截图如下：</p>
<p><img src="https://i.loli.net/2020/12/10/EkoGJDMLstROlY5.png" alt="image-20201210195304419"></p>
<p>而当金币够1000时，事件就变成了：</p>
<p><img src="https://i.loli.net/2020/12/10/mp8YdqW7IS1R2vZ.png" alt="image-20201210195404539"></p>
<h2 id="修改随机权重"><a href="#修改随机权重" class="headerlink" title="修改随机权重"></a>修改随机权重</h2><p>有时候我们希望某个随机结果的权重根据不同的条件而发生改变，例如前面的事件中，同样是得到1000金币，我们希望根据不同的管理值会有不同的概率。这样的效果我们可以使用<code>modifier</code>来实现，具体事件代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random_list &#x3D; &#123;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;</span><br><span class="line">				gold &gt; 1000</span><br><span class="line">			&#125;</span><br><span class="line">			modifier &#x3D; &#123;</span><br><span class="line">				add &#x3D; stewardship</span><br><span class="line">			&#125;</span><br><span class="line">			add_gold &#x3D; 1000</span><br><span class="line">		&#125;			</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 100</span><br><span class="line">		&#125;</span><br><span class="line">		15 &#x3D; &#123;</span><br><span class="line">			remove_short_term_gold &#x3D; 200</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的含义就是，该选项有3个随机结果，分别是金币+1000，金币+100，金币-200，其概率组合是（30+管理值，30，15）。</p>
<p>那么在游戏中我们可以看到，该角色管理值是8，对应的事件如下：</p>
<p><img src="https://i.loli.net/2020/12/10/htkEOdT9qS3xBQY.png" alt="image-20201210203011631"></p>
<p>需要注意的是，不能直接把类似stewardship这样的词放到概率值那里，如果我们希望直接用stewardship当概率，则应该按下面的形式来写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">random_list &#x3D; &#123;</span><br><span class="line">	0 &#x3D; &#123;</span><br><span class="line">		modifier &#x3D; &#123;</span><br><span class="line">			add &#x3D; stewardship</span><br><span class="line">		&#125;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，我尝试给modifier加trigger或者if语句，都失败了，可能它只能单独出现吧。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-4</title>
    <url>/2020/11/08/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-4/</url>
    <content><![CDATA[<h1 id="事件模组"><a href="#事件模组" class="headerlink" title="事件模组"></a>事件模组</h1><p><a href="https://ck3.paradoxwikis.com/Event_modding" target="_blank" rel="noopener">链接</a></p>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>事件在<code>events</code>文件夹下的<code>.txt</code>文件中。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>整体结构与<a href="https://ck2.paradoxwikis.com/Event_modding" target="_blank" rel="noopener">CK2</a>的事件很相似，但是对语法进行了一些调整，并增加了大量额外的功能，其中许多功能是可选的。此处将介绍每个事件所必须的部分，并在稍后部分中单独介绍其他内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example.1 &#x3D; &#123;</span><br><span class="line">	desc &#x3D; example.1.desc</span><br><span class="line">	</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; example.1.a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好该mod并加载，即可在游戏中的控制台输入<code>event triggers [example.1]</code>来触发该事件。</p>
<h3 id="ID和命名空间"><a href="#ID和命名空间" class="headerlink" title="ID和命名空间"></a>ID和命名空间</h3><p>ID是事件独一无二的标志。</p>
<h3 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h3><p>这些是确定事件种类和外观的顶级变量。它们具有有限的值集。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
<th>Possible values</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>事件类型，决定root的范围。</td>
<td>* character_event none (when an event doesn’t use the root scope at all)</td>
</tr>
<tr>
<td>hidden</td>
<td>如果设置为true，则该事件不会显示出来，只会在后台触发。可用于执行与玩家不立即相关的维护事件。</td>
<td>true, false</td>
</tr>
</tbody>
</table>
</div>
<h2 id="画像"><a href="#画像" class="headerlink" title="画像"></a>画像</h2><h3 id="画像位置"><a href="#画像位置" class="headerlink" title="画像位置"></a>画像位置</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Portrait Position</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>left_portrait</td>
<td>出现在事件场景的左边。</td>
</tr>
<tr>
<td>right_portrait</td>
<td>出现在事件场景的右边。</td>
</tr>
<tr>
<td>lower_left_portrait</td>
<td>出现在事件场景的左下方。</td>
</tr>
<tr>
<td>lower_center_portrait</td>
<td>出现在事件场景的中下方。</td>
</tr>
<tr>
<td>lower_right_portrait</td>
<td>出现在事件场景的右下方。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example_event.1001 &#x3D; &#123;</span><br><span class="line">	left_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT # 无论是什么角色，都显示在此事件窗口位置，显示所选的动画。</span><br><span class="line">		animation &#x3D; fear # 请注意，具有某些遗传特征（例如，巨人主义、侏儒主义）的角色更改其角色模型具有不同的动画，如果将其中一个动画分配给没有该模型的角色，则可能会发生崩溃。</span><br><span class="line">	&#125;</span><br><span class="line">	right_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">		animation &#x3D; scheme</span><br><span class="line">	&#125;</span><br><span class="line">	lower_left_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">	&#125;</span><br><span class="line">	lower_center_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">	&#125;</span><br><span class="line">	lower_right_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段mod所对应的事件如下图所示。</p>
<p><img src="https://i.loli.net/2020/11/08/GlaYmiW15KjkUzF.png" alt="img"></p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Animation</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>happiness</td>
<td>dismissal</td>
<td>prison_dungeon</td>
<td>admiration</td>
</tr>
<tr>
<td>disgust</td>
<td>schadenfreude</td>
<td>stress</td>
<td>personality_compassionate</td>
</tr>
<tr>
<td>pain</td>
<td>ecstasy</td>
<td>fear</td>
<td>rage</td>
</tr>
<tr>
<td>anger</td>
<td>flirtation_left</td>
<td>shame</td>
<td>boredom</td>
</tr>
<tr>
<td>shock</td>
<td>worry</td>
<td>scheme</td>
<td>personality_bold</td>
</tr>
<tr>
<td>personality_callous</td>
<td>personality_irrational</td>
<td>personality_content</td>
<td>flirtation</td>
</tr>
<tr>
<td>disbelief</td>
<td>personality_cynical</td>
<td>personality_rational</td>
<td>personality_dishonorable</td>
</tr>
<tr>
<td>idle</td>
<td>paranoia</td>
<td>personality_vengeful</td>
<td>disapproval</td>
</tr>
<tr>
<td>sick</td>
<td>beg</td>
<td>personality_zealous</td>
<td>newborn</td>
</tr>
<tr>
<td>love</td>
<td>sadness</td>
<td>personality_honorable</td>
<td>personality_forgiving</td>
</tr>
<tr>
<td>personality_greedy</td>
<td>personality_coward</td>
<td>severelyinjured</td>
<td>severelywounded</td>
</tr>
<tr>
<td>war_attacker</td>
<td>war_defender</td>
<td>war_over_win</td>
<td>grief</td>
</tr>
</tbody>
</table>
</div>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Theme</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>abduct_scheme</td>
<td>alliance</td>
<td>bastardy</td>
<td>battle</td>
</tr>
<tr>
<td>befriend_scheme</td>
<td>claim_throne_scheme</td>
<td>corruption</td>
<td>crown</td>
</tr>
<tr>
<td>culture_change</td>
<td>death</td>
<td>default</td>
<td>diplomacy</td>
</tr>
<tr>
<td>diplomacy_family_focus</td>
<td>diplomacy_foreign_affairs_focus</td>
<td>diplomacy_majesty_focus</td>
<td>dread</td>
</tr>
<tr>
<td>dungeon</td>
<td>dynasty</td>
<td>education</td>
<td>fabricate_hook_scheme</td>
</tr>
<tr>
<td>faith</td>
<td>family</td>
<td>feast_activity</td>
<td>friend_relation</td>
</tr>
<tr>
<td>friendly</td>
<td>generic_intrigue_scheme</td>
<td>healthcare</td>
<td>hunt_activity</td>
</tr>
<tr>
<td>hunting</td>
<td>intrigue</td>
<td>intrigue_intimidation_focus</td>
<td>intrigue_skulduggery_focus</td>
</tr>
<tr>
<td>intrigue_temptation_focus</td>
<td>learning</td>
<td>learning_medicine_focus</td>
<td>learning_scholarship_focus</td>
</tr>
<tr>
<td>learning_theology_focus</td>
<td>love</td>
<td>lover_relation</td>
<td>marriage</td>
</tr>
<tr>
<td>martial</td>
<td>martial_authority_focus</td>
<td>martial_chivalry_focus</td>
<td>martial_strategy_focus</td>
</tr>
<tr>
<td>medicine</td>
<td>mental_break</td>
<td>mental_health</td>
<td>murder_scheme</td>
</tr>
<tr>
<td>party</td>
<td>pet</td>
<td>physical_health</td>
<td>pilgrimage_activity</td>
</tr>
<tr>
<td>pregnancy</td>
<td>prison</td>
<td>realm</td>
<td>recovery</td>
</tr>
<tr>
<td>rival_relation</td>
<td>romance_scheme</td>
<td>secret</td>
<td>seduce_scheme</td>
</tr>
<tr>
<td>seduction</td>
<td>skull</td>
<td>stewardship</td>
<td>stewardship_domain_focus</td>
</tr>
<tr>
<td>stewardship_duty_focus</td>
<td>stewardship_wealth_focus</td>
<td>sway_scheme</td>
<td>unfriendly</td>
</tr>
<tr>
<td>vassal</td>
<td>war</td>
<td>witchcraft</td>
</tr>
</tbody>
</table>
</div>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Background</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>alley_day</td>
<td>alley_night</td>
<td>armory</td>
<td>army_camp</td>
</tr>
<tr>
<td>battlefield</td>
<td>bedchamber</td>
<td>burning_building</td>
<td>corridor_day</td>
</tr>
<tr>
<td>corridor_night</td>
<td>council_chamber</td>
<td>courtyard</td>
<td>docks</td>
</tr>
<tr>
<td>dungeon</td>
<td>farmland</td>
<td>feast</td>
<td>gallows</td>
</tr>
<tr>
<td>garden</td>
<td>market</td>
<td>market_east</td>
<td>market_india</td>
</tr>
<tr>
<td>market_tribal</td>
<td>market_west</td>
<td>physicians_study</td>
<td>sitting_room</td>
</tr>
<tr>
<td>study</td>
<td>tavern</td>
<td>temple</td>
<td>temple_church</td>
</tr>
<tr>
<td>temple_generic</td>
<td>temple_mosque</td>
<td>temple_scope</td>
<td>terrain</td>
</tr>
<tr>
<td>terrain_activity</td>
<td>terrain_scope</td>
<td>throne_room</td>
<td>throne_room_east</td>
</tr>
<tr>
<td>throne_room_india</td>
<td>throne_room_mediterranean</td>
<td>throne_room_scope</td>
<td>throne_room_tribal</td>
</tr>
<tr>
<td>throne_room_west</td>
<td>wilderness</td>
<td>wilderness_desert</td>
<td>wilderness_forest</td>
</tr>
<tr>
<td>wilderness_forest_pine</td>
<td>wilderness_mountains</td>
<td>wilderness_scope</td>
<td>wilderness_steppe</td>
</tr>
</tbody>
</table>
</div>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>当选择好背景后，对应的环境也会被自动选择，但如果有必要可以自行指定覆盖。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Environment</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>environment_body</td>
<td>environment_council</td>
<td>environment_cw_east_main</td>
</tr>
<tr>
<td>environment_cw_east_spouse</td>
<td>environment_cw_east_throneroom_main</td>
<td>environment_cw_east_throneroom_spouse</td>
</tr>
<tr>
<td>environment_cw_india_main</td>
<td>environment_cw_india_spouse</td>
<td>environment_cw_india_throneroom_main</td>
</tr>
<tr>
<td>environment_cw_india_throneroom_spouse</td>
<td>environment_cw_mediterranean_main</td>
<td>environment_cw_mediterranean_spouse</td>
</tr>
<tr>
<td>environment_cw_mediterranean_throneroom_main</td>
<td>environment_cw_mediterranean_throneroom_spouse</td>
<td>environment_cw_tavern</td>
</tr>
<tr>
<td>environment_cw_tavern_spouse</td>
<td>environment_cw_tribal_main</td>
<td>environment_cw_tribal_spouse</td>
</tr>
<tr>
<td>environment_cw_west</td>
<td>environment_cw_west_spouse</td>
<td>environment_event_alley</td>
</tr>
<tr>
<td>environment_event_alley_day</td>
<td>environment_event_armory</td>
<td>environment_event_battlefield</td>
</tr>
<tr>
<td>environment_event_bedchamber</td>
<td>environment_event_church</td>
<td>environment_event_corridor_day</td>
</tr>
<tr>
<td>environment_event_courtyard</td>
<td>environment_event_desert</td>
<td>environment_event_docks</td>
</tr>
<tr>
<td>environment_event_dungeon</td>
<td>environment_event_farms</td>
<td>environment_event_feast</td>
</tr>
<tr>
<td>environment_event_forest</td>
<td>environment_event_forest_pine</td>
<td>environment_event_gallows</td>
</tr>
<tr>
<td>environment_event_garden</td>
<td>environment_event_genericcamp</td>
<td>environment_event_market_east</td>
</tr>
<tr>
<td>environment_event_market_tribal</td>
<td>environment_event_market_west</td>
<td>environment_event_mosque</td>
</tr>
<tr>
<td>environment_event_mountains</td>
<td>environment_event_sittingroom</td>
<td>environment_event_standard</td>
</tr>
<tr>
<td>environment_event_steppe</td>
<td>environment_event_study</td>
<td>environment_event_study_physician</td>
</tr>
<tr>
<td>environment_event_tavern</td>
<td>environment_event_temple</td>
<td>environment_event_throne_room_west</td>
</tr>
<tr>
<td>environment_frontend_east_heir</td>
<td>environment_frontend_east_main</td>
<td>environment_frontend_east_secondary</td>
</tr>
<tr>
<td>environment_frontend_india_heir</td>
<td>environment_frontend_india_main</td>
<td>environment_frontend_india_secondary</td>
</tr>
<tr>
<td>environment_frontend_mediterranean_heir</td>
<td>environment_frontend_mediterranean_main</td>
<td>environment_frontend_mediterranean_secondary</td>
</tr>
<tr>
<td>environment_frontend_tribal_heir</td>
<td>environment_frontend_tribal_main</td>
<td>environment_frontend_tribal_secondary</td>
</tr>
<tr>
<td>environment_frontend_west_heir</td>
<td>environment_frontend_west_main</td>
<td>environment_frontend_west_secondary</td>
</tr>
<tr>
<td>environment_head</td>
<td>environment_hud</td>
<td>environment_portrait_editor</td>
</tr>
<tr>
<td>environment_shoulders</td>
<td>environment_standard</td>
<td>environment_torso</td>
</tr>
<tr>
<td>environment_war_overview</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>是使事件工作的附加内容。</p>
<h3 id="on-trigger-fail"><a href="#on-trigger-fail" class="headerlink" title="on_trigger_fail"></a>on_trigger_fail</h3><p>当触发器失败时运行该项。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>解释一个描述如何由多个字符串组成，例如<code>first_valid</code>和所有其他选项。</p>
<h3 id="即时模块"><a href="#即时模块" class="headerlink" title="即时模块"></a>即时模块</h3><p>该代码块中的内容会在事件触发时立即执行，甚至早于标题、描述和画像的渲染等等。一般用于设置变量和保存范围，或想要实现无玩家控制的功能影响。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>事件中的选项可以由用户选择。每个事件可以有任意数量的选项，包括无选项（一个典型的例子就是隐藏事件）。每个选项在主事件中如下定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example.1 &#x3D; &#123;</span><br><span class="line">	[...]</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		# option info</span><br><span class="line">	&#125;</span><br><span class="line">	[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列表格介绍了<code>option</code>块中的可选关键字：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>Yes</td>
<td>Points to a localization key for the event option button text.</td>
<td>name=example.1.a</td>
</tr>
<tr>
<td>(effects)</td>
<td>No</td>
<td>Any <a href="https://ck3.paradoxwikis.com/Effect" target="_blank" rel="noopener">effects</a> that the option may have can be written directly in the <code>option</code> block.</td>
<td>play_music_cue = mx_cue_banquet</td>
</tr>
<tr>
<td>trigger</td>
<td>No</td>
<td>Defines a <a href="https://ck3.paradoxwikis.com/Trigger" target="_blank" rel="noopener">trigger</a> that has to be fulfilled for the option to be valid and thus available to the user. Not to be confused with the <a href="https://ck3.paradoxwikis.com/Event_modding#Trigger" target="_blank" rel="noopener">main event trigger</a>.</td>
<td><code>trigger = { has_trait = shy }</code></td>
</tr>
<tr>
<td>show_as_unavailable</td>
<td>No</td>
<td>If the option is invalid, but this trigger is, the option will be  shown, but disabled. This behavior is also influenced by the  EVENT_OPTIONS_SHOWN_HIDE_UNAVAILABLE define.</td>
<td><code>show_as_unavailable = { short_term_gold &lt; medium_gold_value }</code></td>
</tr>
<tr>
<td>highlight_portrait</td>
<td>No</td>
<td>Highlights the event portrait of this character while this option is hovered. This is in addition to the automatic highlighting when  hovering an event option that has an effect that affects portrait  characters.</td>
<td>highlight_portrait = scope:custom</td>
</tr>
</tbody>
</table>
</div>
<h3 id="结束后"><a href="#结束后" class="headerlink" title="结束后"></a>结束后</h3><p>该代码块描述了事件发生后运行的内容。</p>
<h3 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h3><p>有什么类型的小部件。</p>
<h2 id="On-actions"><a href="#On-actions" class="headerlink" title="On_actions"></a>On_actions</h2><p>这部分wiki上是不完整的，先不详细写了。</p>
<p>该部分分为两类：On_actions from Code和On_actions Not from Code（即from script）</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>这部分wiki也不完整，以后有了在写。</p>
<p>分为两部分：触发事件 和 技术与设计模式。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>Echarts的配置</title>
    <url>/2020/10/31/Echarts%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>今天发现了一个可以用在markdown的前端画图js，<a href="https://echarts.apache.org/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts" target="_blank" rel="noopener">ECharts</a>。在hexo的next主题中使用它需要进行一些配置。</p>
<a id="more"></a>
<p>首先需要说明的是，hexo的网页渲染方式有ejs和swig两种。</p>
<p>对于ejs方式的主题，直接在主题目录下的<code>layout\_partial\head.ejs</code>中加入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://echarts.baidu.com/dist/echarts.common.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>在博客站点文件的命令行中执行<code>npm install hexo-tag-echarts --save</code>即可。</p>
<p>而对于swig方式的主题要复杂一些。</p>
<ol>
<li><p>下载ECharts的js文件：<a href="https://echarts.apache.org/zh/download.html" target="_blank" rel="noopener">下载链接</a></p>
</li>
<li><p>然后在<code>next\layout\</code>文件夹下，找到<code>_layout.swig</code>文件，并用文本查看器打开，在下面代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;main id=<span class="string">"main"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main-inner"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content-wrap"</span>&gt;</span><br><span class="line">      &lt;div id=<span class="string">"content"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;% include '_third-party/</span>duoshuo-hot-articles.swig<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">      &#123;% include '</span>_partials/comments.swig<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &#123;% if theme.sidebar.display !== '</span>remove<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">      &#123;% block sidebar %&#125;&#123;% endblock %&#125;</span></span><br><span class="line"><span class="string">    &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/main&gt;</span></span><br></pre></td></tr></table></figure>
<p>的<strong>前面</strong>添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- echarts --&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/echarts.common.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存退出。</p>
</li>
<li><p>在博客站点文件的命令行中执行<code>npm install hexo-tag-echarts --save</code>。</p>
</li>
</ol>
<p>到此为止就可以了，新建一个markdown文件，把下列代码放进去就可以看到本页最下面的echarts示例了。（直接复制粘贴，<strong>不要</strong>放代码块里）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% echarts 400 &#39;85%&#39; %&#125;</span><br><span class="line">&#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: &quot;某站点用户访问来源&quot;,</span><br><span class="line">        subtext: &quot;ECharts示例&quot;,</span><br><span class="line">        x: &quot;center&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        trigger: &quot;item&quot;,</span><br><span class="line">        formatter: &quot;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">        orient: &quot;vertical&quot;,</span><br><span class="line">        x: &quot;left&quot;,</span><br><span class="line">        data: [&quot;直接访问&quot;, &quot;邮件营销&quot;, &quot;联盟广告&quot;, &quot;视频广告&quot;, &quot;搜索引擎&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    toolbox: &#123;</span><br><span class="line">        show: true,</span><br><span class="line">        feature: &#123;</span><br><span class="line">            mark: &#123;</span><br><span class="line">                show: true</span><br><span class="line">            &#125;,</span><br><span class="line">            dataView: &#123;</span><br><span class="line">                show: true,</span><br><span class="line">                readOnly: true</span><br><span class="line">            &#125;,</span><br><span class="line">            restore: &#123;</span><br><span class="line">                show: true</span><br><span class="line">            &#125;,</span><br><span class="line">            saveAsImage: &#123;</span><br><span class="line">                show: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    calculable: true,</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;访问来源&quot;,</span><br><span class="line">            type: &quot;pie&quot;,</span><br><span class="line">            radius: &quot;55%&quot;,</span><br><span class="line">            center: [&quot;50%&quot;, &quot;60%&quot;],</span><br><span class="line">            data: [</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 335,</span><br><span class="line">                    name: &quot;直接访问&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 310,</span><br><span class="line">                    name: &quot;邮件营销&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 234,</span><br><span class="line">                    name: &quot;联盟广告&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 135,</span><br><span class="line">                    name: &quot;视频广告&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 1548,</span><br><span class="line">                    name: &quot;搜索引擎&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endecharts %&#125;</span><br></pre></td></tr></table></figure>
<div id="echarts69" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts69'));
        // 指定图表的配置项和数据
        var option = {
    title: {
        text: "某站点用户访问来源",
        subtext: "ECharts示例",
        x: "center"
    },
    tooltip: {
        trigger: "item",
        formatter: "{a} <br/>{b} : {c} ({d}%)"
    },
    legend: {
        orient: "vertical",
        x: "left",
        data: ["直接访问", "邮件营销", "联盟广告", "视频广告", "搜索引擎"]
    },
    toolbox: {
        show: true,
        feature: {
            mark: {
                show: true
            },
            dataView: {
                show: true,
                readOnly: true
            },
            restore: {
                show: true
            },
            saveAsImage: {
                show: true
            }
        }
    },
    calculable: true,
    series: [
        {
            name: "访问来源",
            type: "pie",
            radius: "55%",
            center: ["50%", "60%"],
            data: [
                {
                    value: 335,
                    name: "直接访问"
                },
                {
                    value: 310,
                    name: "邮件营销"
                },
                {
                    value: 234,
                    name: "联盟广告"
                },
                {
                    value: 135,
                    name: "视频广告"
                },
                {
                    value: 1548,
                    name: "搜索引擎"
                }
            ]
        }
    ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-3</title>
    <url>/2020/10/05/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<p>接下来是事件和决议的简单写法。</p>
<a id="more"></a>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="一些文件说明"><a href="#一些文件说明" class="headerlink" title="一些文件说明"></a>一些文件说明</h2><ol>
<li><p>首先在<code>...\Crusader Kings III\game\common\event_themes</code>文件夹中，可以看到<code>00_event_themes.txt</code>文件，里面记录了游戏中的事件主题，不同的主题会有不同的图标、音乐和背景。</p>
</li>
<li><p>其次在<code>...\Crusader Kings III\game\common\event_backgrounds</code>文件夹中，可以看到<code>01_event_backgrounds.txt</code>文件，里面记录了上一条提到的背景对应的信息，包括图片、环境和氛围，例如对于<code>event_background = study</code>的事件主题而言，它的背景信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">study &#x3D; &#123;</span><br><span class="line">	background &#x3D; &#123;</span><br><span class="line">		reference &#x3D; &quot;gfx&#x2F;interface&#x2F;illustrations&#x2F;event_scenes&#x2F;study.dds&quot;</span><br><span class="line">		environment &#x3D; &quot;environment_event_study&quot;</span><br><span class="line">		ambience &#x3D; &quot;event:&#x2F;SFX&#x2F;Events&#x2F;Backgrounds&#x2F;office_workplace&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来在<code>...\Crusader Kings III\game\events</code>文件夹中，可以看到大量事件的具体说明，其中的<code>_events.info</code>文件介绍了事件格式。</p>
</li>
</ol>
<h2 id="事件格式"><a href="#事件格式" class="headerlink" title="事件格式"></a>事件格式</h2><ol>
<li><p>以勒索事件为例来分析事件格式，勒索事件一共有3种：勒索被拒绝、勒索某人造成恐惧、被勒索带来压力。</p>
<p>这里分析第一种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blackmail.0001 &#x3D; &#123;</span><br><span class="line">	title &#x3D; blackmail.0001.t</span><br><span class="line">	desc &#x3D; blackmail.0001.desc</span><br><span class="line">	theme &#x3D; intrigue</span><br><span class="line">	left_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; scope:recipient</span><br><span class="line">		animation &#x3D; dismissal</span><br><span class="line">	&#125;</span><br><span class="line">	# TODO_CD: Add a check that the secret has not yet been exposed</span><br><span class="line">	immediate &#x3D; &#123;</span><br><span class="line">		play_music_cue &#x3D; mx_cue_murder</span><br><span class="line">	&#125;</span><br><span class="line">	after &#x3D; &#123; remove_variable &#x3D; currently_blackmailing &#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; blackmail.0001.a</span><br><span class="line">		scope:target &#x3D; &#123;</span><br><span class="line">			expose_secret &#x3D; root</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; blackmail.0001.b</span><br><span class="line">		scope:target &#x3D; &#123;</span><br><span class="line">			disable_exposure_by &#x3D; root</span><br><span class="line">		&#125;</span><br><span class="line">		ai_chance &#x3D; &#123;</span><br><span class="line">			factor &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>title</code>和<code>desc</code>两个字段对应的内容可以在文本文件（<code>...\Crusader Kings III\game\localization\simp_chinese\event_localization\blackmail_events_l_simp_chinese.yml</code>）中看到；</p>
<p><code>theme</code>是<code>intrigue</code>，在之前的事件主题中可以找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">intrigue &#x3D; &#123;</span><br><span class="line">	icon &#x3D; &#123;</span><br><span class="line">		reference &#x3D; &quot;gfx&#x2F;interface&#x2F;icons&#x2F;event_types&#x2F;type_intrigue.dds&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	sound &#x3D; &#123;</span><br><span class="line">		reference &#x3D; &quot;event:&#x2F;SFX&#x2F;Events&#x2F;Themes&#x2F;sfx_event_theme_type_intrigue&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	background &#x3D; &#123;</span><br><span class="line">		event_background &#x3D; corridor_night</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说该事件出现时会有如上图标音乐和背景。</p>
<p>接下来<code>left_portrait</code>是说事件发生时左边的人物形象，这里还可以根据需要设置<code>right_portrait, lower_left_portrait, lower_center_portrait, lower_right_portrait</code>。</p>
<p><code>immediate</code>和<code>after</code>根据字面意思来理解应该是指事件发生时和发生后所触发的效果。</p>
<p>接下来两个<code>option</code>表示这个事件有两个选项，分别对应的文字是<code>blackmail.0001.a</code>和<code>blackmail.0001.b</code>，对应的结果是暴露用来勒索的秘密和放弃勒索。</p>
</li>
<li><p>事件的写法还涉及很多东西，之后再继续看，然后先看看决议。</p>
</li>
</ol>
<h1 id="决议"><a href="#决议" class="headerlink" title="决议"></a>决议</h1><ol>
<li>决议文件存放在<code>...\Crusader Kings III\game\common\decisions</code>中，同样有一个<code>_decisions.info</code>来说明决议的大致格式。</li>
<li>决议的格式和事件其实大同小异，就不记录了。</li>
</ol>
<h1 id="一个基础尝试"><a href="#一个基础尝试" class="headerlink" title="一个基础尝试"></a>一个基础尝试</h1><p>我希望做一个决议，通过决议触发一个事件，而该事件有3个选项，分别是</p>
<ol>
<li>消耗500威望给我1000金钱；</li>
<li>无事发生；</li>
<li>消耗1000金钱给我500威望。</li>
</ol>
<p>那么首先新建一个mod文件夹，它的路径是<code>C:\Users\LiKun\Documents\Paradox Interactive\Crusader Kings III\mod\test</code>，需要注意的是，在<code>C:\Users\LiKun\Documents\Paradox Interactive\Crusader Kings III\mod</code>文件夹里同时会出现一个<code>test.mod</code>，它指向我们mod的路径，内容是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version&#x3D;&quot;0.0&quot;</span><br><span class="line">tags&#x3D;&#123;</span><br><span class="line">	&quot;Historical&quot;</span><br><span class="line">&#125;</span><br><span class="line">name&#x3D;&quot;test&quot;</span><br><span class="line">supported_version&#x3D;&quot;1.1.*&quot;</span><br><span class="line">path&#x3D;&quot;C:&#x2F;Users&#x2F;LiKun&#x2F;Documents&#x2F;Paradox Interactive&#x2F;Crusader Kings III&#x2F;mod&#x2F;test&quot;</span><br></pre></td></tr></table></figure>
<p>接下来，我们在mod文件夹中按照游戏本体那样逐层建立所需要的文件夹，这里一定要严格弄清楚所有路径。建立好的文件夹和文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- test</span><br><span class="line">	- common</span><br><span class="line">		- decisions</span><br><span class="line">			give_money_decision.txt</span><br><span class="line">	- events</span><br><span class="line">		- give_money_events</span><br><span class="line">			give_money_events.txt</span><br><span class="line">	- localization</span><br><span class="line">		- simp_chinese</span><br><span class="line">			- event_localization</span><br><span class="line">				give_money_l_simp_chinese.yml</span><br><span class="line">			decisions_test_l_simp_chinese.yml</span><br><span class="line">	descriptor.mod</span><br></pre></td></tr></table></figure>
<p>我首先写的是事件，也就是<code>give_money_events.txt</code>，该文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; give_money</span><br><span class="line"></span><br><span class="line">give_money.1 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; give_money.1.t</span><br><span class="line">	desc &#x3D; give_money.1.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.a</span><br><span class="line">		add_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; -500</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.b</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.c</span><br><span class="line">		remove_short_term_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; 500</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是非常简单的格式，一共3个选项，没有任何触发限制。其中<code>title, desc, name</code>等需要替换成文字的地方，之后在文本文件会增加内容。</p>
<p>需要注意的是，这里用<code>add_gold</code>增加金钱，用<code>remove_short_term_gold</code>减少金钱，是因为我发现<code>add_gold = -1000</code>根本不会生效，查了一下现成的和金钱有关的事件文档，发现用的是<code>remove_short_term_gold</code>，但这个句式到底是什么意思目前也不是很确定。</p>
<p>接下来写决议文件<code>give_money_decision.txt</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">give_money_decision &#x3D; &#123;</span><br><span class="line">	picture &#x3D; &quot;gfx&#x2F;interface&#x2F;illustrations&#x2F;decisions&#x2F;decision_personal_religious.dds&quot;</span><br><span class="line">	desc &#x3D; give_money_decision_desc</span><br><span class="line">	is_valid_showing_failures_only &#x3D; &#123;</span><br><span class="line">		is_available_adult &#x3D; yes</span><br><span class="line">	&#125;</span><br><span class="line">	effect &#x3D; &#123;</span><br><span class="line">		custom_tooltip &#x3D; give_money_decision_effect_tooltip</span><br><span class="line">		trigger_event &#x3D; give_money.1</span><br><span class="line">	&#125;</span><br><span class="line">	ai_check_interval &#x3D; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里增加了需要成年人的限制，<code>custom_tooltip = give_money_decision_effect_tooltip</code>是指效果区域会显示<code>give_money_decision_effect_tooltip</code>所对应的文字，而<code>trigger_event = give_money.1</code>表示确认该决议后，会触发事件<code>give_money.1</code>。</p>
<p>事件和决议都写好以后，就开始完成文本内容，首先是决议文本<code>decisions_test_l_simp_chinese.yml</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> give_money_decision:0 &quot;我好穷啊&quot;</span><br><span class="line"> give_money_decision_tooltip:0 &quot;收点钱。&quot;</span><br><span class="line"> give_money_decision_desc:0 &quot;想要钱吗？&quot;</span><br><span class="line"> give_money_decision_effect_tooltip:0 &quot;点击按钮一键收钱。&quot;</span><br><span class="line"> give_money_decision_confirm:0 &quot;当然&quot;</span><br></pre></td></tr></table></figure>
<p>完成这部分内容后，该决议在游戏中的效果就是</p>
<p><img src="https://i.loli.net/2020/10/06/HQoYAK7JVivqI62.png" alt="image-20201006221530141"></p>
<p>相应的，事件文本也是一样的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> give_money.1.t:0 &quot;给我打钱！&quot;</span><br><span class="line"> give_money.1.desc:0 &quot;神说要有钱。&quot;</span><br><span class="line"> give_money.1.option.a:0 &quot;好，我喜欢！&quot;</span><br><span class="line"> give_money.1.option.b:0 &quot;不了不了。&quot;</span><br><span class="line"> give_money.1.option.c:0 &quot;你这是看不起我！&quot;</span><br></pre></td></tr></table></figure>
<p>游戏中的效果是</p>
<p><img src="https://i.loli.net/2020/10/06/MWy7KlRpa1wA4kN.png" alt="image-20201006221637015"></p>
<p>把文件们都保存好，就完成了第一个基础mod了。</p>
<p>补充一个重要说明，文件的编码格式非常重要，统一采用UTF-8-BOM编码，不然会出问题。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-2</title>
    <url>/2020/10/04/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>这次了解一下决议和事件的图标相关的事情。</p>
<a id="more"></a>
<h1 id="关于图片"><a href="#关于图片" class="headerlink" title="关于图片"></a>关于图片</h1><ol>
<li>游戏中出现的过场图、背景图、事件图标等等基本存放在<code>...\Crusader Kings III\game\gfx\interface</code>文件夹中，比如<code>...\interface\bookmarks</code>里存着开场选人物时的界面贴图，而<code>...\interface\illustrations</code>文件夹里则存着很多尺寸大一些的图（例如过场图、决议说明界面的图等等）；</li>
<li>这些贴图都是dds格式，不同使用场景的贴图有不同尺寸，可以给PS装dds插件然后打开查看；</li>
<li>以决议为例，代码段落中会有<code>picture</code>这个选项，例如<code>create_cadet_branch_decision</code>中的是<code>picture = &quot;gfx/interface/illustrations/decisions/decision_dynasty_house.dds&quot;</code>，如果要自己写决议，或者想把某个决议的图像修改成其他样式，就在这里进行替换，注意dds文件的尺寸等；</li>
<li>开场<code>bookmarks</code>的贴图和上面的不太一样，经过反复分析我发现，在bookmarks文件（<code>...\Crusader Kings III\game\common\bookmarks\00_bookmarks.txt</code>）中，预设的六个是<code>bm_867_northmen</code>、<code>bm_867_adventurers</code>等等，而在<code>...\Crusader Kings III\game\gfx\interface\bookmarks</code>中存在和这些名字相同的六个dds文件，每个可选的人物也类似，总之是dds文件的名字要和bookmarks文件里设定的选项保持一致，这样游戏里会自动对应起来。</li>
<li>图片暂时就先看到这里。</li>
</ol>
<h1 id="关于文本"><a href="#关于文本" class="headerlink" title="关于文本"></a>关于文本</h1><ol>
<li><p>游戏中出现的文本存放在<code>...\Crusader Kings III\game\localization</code>文件夹中，每个语言有一个文件夹；</p>
</li>
<li><p>每个文本文件是<code>.yml</code>格式的，可以用记事本的编辑器打开修改；</p>
</li>
<li><p>文本内容格式是：<code>文本名称:0 &quot;text&quot;</code>，这其中的0也见过写成1的，目前不知道是什么区别，也许和路径有关吧。文本名称的命名有固定格式，比如bookms的命名方式是<code>bm_year_bookmarkname</code>，而对应的描述则是<code>bm_year_bookmarkname_desc</code>，如下是一个例子；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bm_1066_conqueror:0 &quot;Norman England&quot;</span><br><span class="line">bm_1066_conqueror_desc:0 &quot;William has defeated the Anglo-Saxon king Harold at the Battle of Hastings and is crowned king of England, starting an age of Norman rule over the kingdom.&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用的时候，注意名称的统一即可，例如：</p>
<p>在common文件夹的决议文件中，成立葡萄牙的决议如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form_portugal_decision &#x3D; &#123;</span><br><span class="line">	picture &#x3D; &quot;gfx&#x2F;interface&#x2F;illustrations&#x2F;decisions&#x2F;decision_dynasty_house.dds&quot;</span><br><span class="line">	major &#x3D; yes</span><br><span class="line">	ai_check_interval &#x3D; 60</span><br><span class="line">	desc &#x3D; form_portugal_decision_desc</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>那么对应的文本内容则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form_portugal_decision:0 &quot;成立葡萄牙&quot;</span><br><span class="line">form_portugal_decision_desc:0 &quot;一旦我控制了伊比利亚半岛的西海岸，我就能成立葡萄牙王国，并且建立自己独特的文化。&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>目前先看到这里，还有很多问题之后再说。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-1</title>
    <url>/2020/10/03/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>首先新建一个mod文件。</p>
<a id="more"></a>
<h1 id="新建Mod"><a href="#新建Mod" class="headerlink" title="新建Mod"></a>新建Mod</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>启动器里找到mod新建会自动生成相关文件；</li>
<li>也可以文档里找到<code>...\Paradox Interactive\Crusader Kings III\mod</code>文件夹（如果没有就新建），新建<code>test.mod</code>文件，用随便什么编辑器打开，输入一系列内容并保存。</li>
</ol>
<h2 id="test-mod文件"><a href="#test-mod文件" class="headerlink" title="test.mod文件"></a><code>test.mod</code>文件</h2><ol>
<li><p>启动器生成的该文件基础内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version&#x3D;&quot;0.0&quot;</span><br><span class="line">tags&#x3D;&#123;</span><br><span class="line">	&quot;Historical&quot;</span><br><span class="line">&#125;</span><br><span class="line">name&#x3D;&quot;test&quot;</span><br><span class="line">supported_version&#x3D;&quot;1.0.3&quot;</span><br><span class="line">path&#x3D;&quot;C:&#x2F;Users&#x2F;LiKun&#x2F;Documents&#x2F;Paradox Interactive&#x2F;Crusader Kings III&#x2F;mod&#x2F;test&quot;</span><br></pre></td></tr></table></figure>
<p><code>version</code>和<code>supported_version</code>自己可以看着改。</p>
</li>
<li><p>可以附加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">picture &#x3D; 图像文件名</span><br></pre></td></tr></table></figure>
<p>指定mod开场图片。</p>
</li>
<li><p>ck2可以设定<code>replace_path</code>，覆盖文件夹中的所有内容，ck3是否可以还没试过，之后看看。</p>
</li>
</ol>
<h2 id="common文件夹"><a href="#common文件夹" class="headerlink" title="common文件夹"></a><code>common</code>文件夹</h2><ol>
<li><p>正常来说ck3游戏本体内容不在上面那个文档里，而在其他安装路径，比如<code>C:\Program 1\Steam\steamapps\common\Crusader Kings III</code>，在这个文件夹中的<code>...\game\common</code>文件夹中存放着很多游戏相关文件，接下来试图逐一分析。</p>
</li>
<li><p>文件夹里有很多文件夹和一个<code>achievement_groups.txt</code>，这个txt文件内容看上去是对成就进行分组，分为<code>very_easy_achievements</code>, <code>easy_achievements</code>, <code>medium_achievements</code>, <code>hard_achievements</code>, <code>very_hard_achievements</code>，文件夹中的第一个是<code>achievements</code>，包括<code>standard_achievements.txt</code>和<code>msgrdk_achievements.json</code>。</p>
<ol>
<li><p><code>standard_achievements.txt</code>中的内容格式是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">成就名 &#x3D; &#123;</span><br><span class="line">	possible &#x3D; &#123;</span><br><span class="line">		# 成就起始条件</span><br><span class="line">	&#125;</span><br><span class="line">	happened &#x3D; &#123;</span><br><span class="line">		custom_description &#x3D; &#123;</span><br><span class="line">			# 成就达成要求</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol>
<li><p><code>msgrdk_achievements.json</code>看起来是给每个成就映射了一个数字编号，总共55个。</p>
</li>
<li><p>目前对成就这部分很不熟悉，可能有理解错的内容。</p>
</li>
</ol>
<ol>
<li><p><code>activities</code>文件夹，这里看上去是五个主要活动的说明，这五个都是决议里的，但应该不是决议。</p>
<ol>
<li><p><code>_activities.info</code> 说明了具体格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name_of_activity &#x3D; &#123;</span><br><span class="line">	expiration_days &#x3D; X 			# default number of days after an activity is started to it&#39;s expiration</span><br><span class="line">	days_until_auto_start &#x3D; X 		# number of days from an activity is spawned until it&#39;s started (regardless of if participants have arrived or not)</span><br><span class="line">	valid &#x3D; trigger					# checked daily on the activity scope</span><br><span class="line">	on_spawn &#x3D; effect 				# executed on the activity when spawned</span><br><span class="line">	on_activate &#x3D; effect			# executed on the activity when started (all invitations replied to or auto started)</span><br><span class="line">	on_complete &#x3D; effect			# executed on the activity when completed through complete_activity &#x3D; yes (ignored if complete_activity &#x3D; no)</span><br><span class="line">	on_expire &#x3D; effect				# executed on the activity when expiring from timeout</span><br><span class="line">	on_participant_death			# executed on the dying character during death, activity set as scope:activity</span><br><span class="line">	on_invalidated &#x3D; effect			# executed on the activity when failing the valid trigger	</span><br><span class="line">	solo &#x3D; yes						# marks the activity as a solo activity (no guests)</span><br><span class="line">	has_activity_window &#x3D; yes		# determines if a certain activity should show a window or not</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来结合其他几个具体文件来理解。</p>
</li>
<li><p><code>00_activity_feast.txt</code> 宴会：</p>
<ol>
<li><p><code>expiration_days = 300</code> 持续300天</p>
</li>
<li><p><code>has_activity_window = yes</code> 有事件窗口</p>
</li>
<li><p><code>days_until_auto_start = 20</code> 默认20天后开始</p>
</li>
<li><p><code>frame = 2</code></p>
</li>
<li><p><code>color = { 0.853906 0.867188 0.105469 1 }</code></p>
</li>
<li><pre><code>valid = {
        activity_owner = {
            is_alive = yes
            is_imprisoned = no
        }
    }
</code></pre><p>宴会期间每天检查召开宴会的人活着且没被关起来。</p>
</li>
<li><p><code>on_spawn</code>这段很长，大致是宴会事件生成时同时执行的内容，主要是设置潜在宾客列表<code>potential_guests</code>。这段有个<code>if</code>语句，提到条件和配偶有关，没配偶似乎是会随机初始化一个配偶，没太看懂这个设计。</p>
</li>
<li><p><code>on_activate</code> 也很长，大致是宴会事件开始时触发的，如果没人来，就结束这个事件，<code>feast.2003</code>可能就是结束宴会的意思；如果有人来，给召开宴会的人选关键事件，再从宾客里选人参与到这个事件中，这里提到<code>reveler（狂欢者？）</code>会得到两点不知道是生活方式还是生活经验的奖励。而作为客人，<code>reveler（狂欢者？）</code>会得到一点，此外针对所有客人，会移除宴会邀请的拦截器（？这里还得之后再看）。</p>
</li>
<li><p><code>on_complete</code> 宴会结束时，主人和封臣似乎会有什么互动，每个参与者的目标体重（？）会改变。</p>
</li>
<li><p><code>on_expire</code> 宴会到期以后会触发<code>feast.2002</code>。注释说这个不应出现，只是作为异常记录。</p>
</li>
<li><p><code>on_participant_death</code>是空的。</p>
</li>
<li><p><code>on_invalidated</code> 失效的情况？</p>
</li>
</ol>
</li>
<li><p><code>00_activity_hunt.txt</code> 打猎：</p>
<ol>
<li>和刚才的宴会不同，这里有<code>solo = yes</code>，说明可以一个人打猎。</li>
<li><code>frame</code>和<code>color</code>暂时还是不太理解。</li>
<li>这里的很多限制都要求是健康成年人。</li>
</ol>
</li>
<li><p><code>00_activity_meditation.txt</code> 冥想：</p>
<ol>
<li>同样可以一个人进行。</li>
</ol>
</li>
<li><p>看上去冥想是宗教决议中的一个：<code>religious_decision.0211</code></p>
</li>
<li><p><code>00_activity_pilgrimage.txt</code> 朝圣：因为没看懂就没什么能说的。</p>
</li>
<li><p><code>00_activity_witch_ritual.txt</code> 巫术仪式：</p>
<ol>
<li>其实也没看懂，看起来是可以搞巫术仪式的，但是限制有点多。</li>
<li>似乎是有个宴会，参加宴会的可以为所欲为，还会有不一样的音乐（？<code>play_music_cue = &quot;mx_cue_sacredrite&quot;</code>）。</li>
<li>这里提到的事件有<code>witch.3003</code> <code>witch.3010</code> <code>witch.3098</code>。</li>
</ol>
</li>
<li><p>补充一下：从<code>event</code>文件夹的内容来看，官方没搞冥想和巫术仪式，以后可能会有吧。</p>
</li>
</ol>
</li>
<li><p><code>ai_goaltypes</code>文件夹和<code>ai_war_stances</code>，这俩看名字是和AI设定有关的。</p>
<ol>
<li><code>ai_goaltypes</code>文件夹里只有<code>00_testgoals.txt</code>，内容相当于是空的，可能是留着做mod用。</li>
<li><code>ai_war_stances</code>文件夹里有<code>_ai_war_stances.info</code>和<code>00_ai_war_stances.txt</code>：<ol>
<li><code>_ai_war_stances.info</code>说明了战争立场格式，注释说无法添加新的或者删除现有的，但是都能改。</li>
<li>这里设定的是AI战争时的目标优先级，优先级范围是1-1000，有一个战争目标列表。</li>
<li>有一个变量<code>enemy_unit_priority</code>，这个值目前设置为100，是指对于战力不到该AI一半的敌军单位，战争优先级数字会增加100，该值的影响似乎会随着敌军单位战力的增长而降低，当敌军战力和该AI战力一样的时候这个值就被看作0。</li>
<li><code>00_ai_war_stances.txt</code>是具体的优先级设定，分为进攻方和防御方：<ol>
<li>作为进攻方的AI，在进攻时作战优先级由高到低：目标省（<code>wargoal_province</code> 500）、敌军所在地（<code>enemy_unit_province</code> 300 这个翻译我猜的，可能不对）、敌军首都（<code>enemy_capital_province</code> 150）、敌军省（<code>enemy_province</code> 100）、敌军盟友省（<code>enemy_ally_province</code> 75）、首都（<code>capital_province</code> 50）、普通省（<code>province</code> 25）、保卫战争目标省（<code>defend_wargoal_province</code> 5）。</li>
<li>作为进攻方的AI，在防御时会优先找敌军所在地（<code>enemy_unit_province</code> 500），其次才是战争目标省（<code>wargoal_province</code> 300），其他和刚才一样。</li>
<li>作为防御方，也有和上面一样的两部分。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><code>bookmark_portraits</code>文件夹看上去是存了游戏命令行里生成的外貌数据。</p>
</li>
<li><p><code>bookmark</code>文件夹中有<code>00_bookmarks.txt</code>，这里存了游戏开局可以选的剧本数据，一共6个时代（3个867和3个1066），设定了起止时间和可选的几个角色以及角色们的相关数据。</p>
</li>
<li><p>后面还有好多好多文件夹，等以后用到了再看吧……</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>使用算法和数据结构解决问题-1</title>
    <url>/2020/09/28/%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-1/</url>
    <content><![CDATA[<h1 id="第一章-前言"><a href="#第一章-前言" class="headerlink" title="第一章 前言"></a>第一章 前言</h1><h2 id="1-1-目标"><a href="#1-1-目标" class="headerlink" title="1.1 目标"></a>1.1 目标</h2><ol>
<li><p>回顾计算机科学、编程和解决问题的想法。</p>
</li>
<li><p>理解“抽象”及其在解决问题的过程中发挥的作用。</p>
</li>
<li><p>理解和实现抽象数据类型的概念。</p>
</li>
<li><p>复习 <code>Python</code> 编程语言。</p>
</li>
</ol>
<h2 id="1-2-开始"><a href="#1-2-开始" class="headerlink" title="1.2 开始"></a>1.2 开始</h2><p>自从第一台通过贴片电缆和开关来传达人与机器之间指令的电子计算机问世以来，我们对编程的思考方式已经发生了许多变化。与社会的许多方面一样，计算机技术的变化为计算机科学家提供了越来越多的工具和平台来练习他们的技术，更快的处理器、高速网络和大型内存容量等进步也为计算机科学家带来必须面对的复杂性。在这飞速发展的过程中，仍然有一些基本原则保持不变。计算科学关注于使用计算机来解决问题。</p>
<p>无疑，你花了相当长的时间（真的吗？）学习解决问题的基础知识，并且对读懂问题并开发解决方案充满信心。你还了解到编程通常很难（并不），大规模问题的复杂性和求解方案的复杂性往往会掩盖与求解过程相关的基本思想。</p>
<p>本章强调了其余部分内容的两个重要方面。首先，它回顾了计算机科学以及算法和数据结构研究必须符合的框架，特别是我们需要研究这些主题的原因，以及理解这些主题如何帮助我们更好地解决问题。其次，我们复习一下<code>Python</code>编程语言。虽然我们无法提供详细、详尽的参考，但我们将为将在其余各章中出现的基本构造和想法提供实例和解释。</p>
<h2 id="1-3-什么是计算科学"><a href="#1-3-什么是计算科学" class="headerlink" title="1.3 什么是计算科学"></a>1.3 什么是计算科学</h2><p>可能是由于名称中包含了”计算机“一词，计算科学通常很难定义。如你所知，计算科学并不仅仅是对计算机的研究。尽管计算机作为学科中的工具发挥了重要的支持作用，但它们仅仅是工具。</p>
<p>计算科学是对求解问题过程中的问题、求解过程以及解决方案的研究，针对给定问题，计算科学家的目标是设计算法——这是解决任何可能出现的问题的指令所对应的分布说明列表。算法帮助我们解决问题的有限过程，是解决方案。</p>
<p>我们可以认为计算科学就是研究算法，然而，我们必须注意，一些可能无解的问题也会被包含进来。虽然证明这种说法超出了本文的范围，但一些无解问题对于研究计算科学的人而言很重要。通过包含两种类型的问题，我们可以通过以下方式来定义计算科学：计算科学对问题解决方案的研究，以及对无解问题的研究。</p>
<p>”<strong>可计算</strong>“一词再描述问题和解决方案时也很常见。我们说，如果存在一个算法来解决问题，则该问题是可计算的。计算科学的另一种定义是：对可计算和不可计算的问题的研究、对算法存在性与不存在性的研究。在任何情况下，你都会注意到”计算机“一词没有出现，解决方案与机器是独立的。</p>
<p>因为它涉及到问题求解过程，所以计算科学也是<strong>抽象</strong>的研究。抽象使我们能够以分离逻辑和物理的方式来看代问题和解决方案。我们使用一个常见的例子来熟悉这一基本思想。</p>
<p>想象你今天可能开到学校或公司的汽车（我没车）。作为一个司机、汽车的用户，为了用车实现目的，你与汽车之间发生了一些交互，你进车、插钥匙、启动、换档、刹车、加速和转向以便驾驶。从抽象的角度来看，我们可以说你看到了汽车的逻辑视角。为了将你从一个地方送到另一个地方，你使用了汽车设计者所提供的函数，这些函数有时被称为<strong>接口</strong>。</p>
<p>另一方面，修理汽车的机械师则持有不同的观点。她不仅需要知道如何开车，还需要知道执行所有我们认为理所当然的函数的全部细节。她需要理解发动机的工作原理、变速箱如何换档、如何控制温度等等。这被称为物理视角——”引擎盖下的细节“。</p>
<p>在我们使用计算机时也发生了同样的事情。大多数人在不了解原理的情况下使用计算机来编写文档、发送和接收电子邮件、浏览网页、播放音乐、存储图像和玩游戏，他们从逻辑或者用户的视角来看计算机。而计算科学家、程序员、技术支持人员和系统管理员对计算机的看法则有很大不同，他们必须知道操作系统如何工作、如何配置网络协议以及如何编写控制功能的各种脚本，他们必须能够控制底层细节，而用户则只是简单想象这些。</p>
<p>这两个例子的共同点在于，抽象的用户（有时也被称为客户端）并不需要了解详细信息，而只需要知道接口的工作方式。接口是用户与底层复杂系统的通信方式。我们可以来看另一个抽象的例子：<code>Python</code>中的<code>math</code>模块。当我们导入该模块后，就可以实现如下计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.sqrt(<span class="number">16</span>)</span><br><span class="line"><span class="number">4.0</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这是<strong>过程抽象(procedural abstraction)</strong>的示例。我们不一定知道平方根是如何计算的，但我们知道函数的调用以及如何使用它。如果我们正确执行导入，我们可以假定函数将为我们提供正确的结果。我们知道有人实现了平方根问题的解决方案，但我们并不关心是如何实现的，只需要知道如何使用它。这有时称为进程的”黑盒”视图。我们简单地将接口描述为：函数的名称、需要什么（参数）以及将返回什么，而具体内容则隐藏在接口中，如图1.1。</p>
<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="https://i.loli.net/2020/11/06/UwFpIlg9mroSa8i.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图1.1 过程抽象</div> </center>

<h3 id="1-3-1-什么是编程"><a href="#1-3-1-什么是编程" class="headerlink" title="1.3.1 什么是编程"></a>1.3.1 什么是编程</h3><p><strong>编程</strong>是将算法编码为符号（编程语言）从而使其可以在计算机上执行的过程。尽管存在许多编程语言和许多不同类型的计算机，但重要的第一步是提出解决方案，没有算法就没有程序。</p>
<p>计算机科学不是编程的研究，然而编程是计算机科学家工作的一个重要部分。编程通常是我们为解决方案创建的表示。因此，这种语言表示和创建过程成为学科的基本部分。</p>
<p>算法根据表示问题实例所需的数据和产生预期结果所需的步骤集来描述问题的解决方案。编程语言必须提供一种符号方式来表示进程和数据。为此，语言提供了控件构造和数据类型。</p>
<p>控件构造允许以方便而明确的方式表示算法步骤。算法至少需要执行顺序处理、决策选择和重复控制迭代的构造（注：简单来说就是顺序、选择、循环）。只要编程语言提供这些基本语句，它就可以用于算法表示。</p>
<p>计算机中的所有数据项都表示为二进制数字字符串。为了给这些字符串赋予意义，我们需要有<strong>数据类型</strong>。数据类型为此二进制数据提供解释，以便我们可以从与所解决的问题有意义的术语中分析数据。这些低级的内置数据类型（有时称为基元数据类型）为算法开发提供了构建基块。</p>
<p>例如，大多数编程语言为整数提供了数据类型，计算机内存中的二进制数字字符串可以解释为整数，并给出我们通常与整数关联的典型含义（例如 23、654 和 -19）。此外，数据类型还提供数据项可以参与的操作的说明，对于整数，加法、减法和乘法等操作是通用的。我们期望该数字类型的数据可以参与这些算术运算。</p>
<p>我们经常遇到的困难是，问题及其解决方法非常复杂。这些简单的语言所提供的构造和数据类型虽然肯定足以表示复杂的解决方案，但往往会使我们再处理问题的过程中处于不利地位。我们需要控制这种复杂性和协助创建解决方案的方法。</p>
<h3 id="1-3-2-为什么要学习数据结构和抽象数据类型"><a href="#1-3-2-为什么要学习数据结构和抽象数据类型" class="headerlink" title="1.3.2 为什么要学习数据结构和抽象数据类型"></a>1.3.2 为什么要学习数据结构和抽象数据类型</h3><p>为了管理问题的复杂性和解决问题的过程，计算机科学家们使用抽象，使他们能够专注于”大局”，而不会迷失在细节中。通过创建问题域的模型，我们能够利用更好、更高效的问题求解过程。这些模型允许我们以与问题本身更加一致的方式来描述我们的算法将处理的数据。</p>
<p>在前文中，我们提到过程抽象是一个隐藏特定函数的详细信息的过程，以允许用户或客户端在非常高的级别上查看它。现在，我们把注意力转向一个类似的想法，即<strong>数据抽象</strong>。<strong>抽象数据类型</strong>（有时称为<strong>ADT</strong>）是对我们如何查看数据及其允许操作的逻辑描述，我们并不关心如何实现该数据类型。这意味着我们只关心数据所代表的是什么，而不关心数据是如何构造的。通过提供这种抽象级别，我们围绕数据创建封装，其理念是，在用户视图中，通过封装将实现过程的详细信息隐藏起来，这被称为信息隐藏。</p>
<p>图 1.2 显示了抽象数据类型及其操作方式的图片。用户使用抽象数据类型指定的操作与接互。抽象数据类型是用户与之交互的 shell。实现过程被隐藏在更深的一层，而用户并不关心实现过程的详细信息。</p>
<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="https://i.loli.net/2020/11/12/iqCUNtAdfyQEM16.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图1.2 抽象数据类型</div> </center>

<p>抽象数据类型的实现（通常称为数据结构）要求我们使用一些编程构造和基元数据类型的集合提供数据的物理视图。正如我们前面所讨论的，这两个视图的分离将使我们能够在无需说明模型实际构建的细节的情况下，定义我们问题的复杂数据模型，它提供了<strong>实现独立性</strong>的数据视图。由于实现抽象数据类型通常有很多不同的方法，因此这种实现独立性允许程序员切换实现过程的详细信息，而无需更改数据用户与其交互的方式，用户可以继续专注于解决问题的过程。</p>
<h3 id="1-3-3-为什么要学习算法"><a href="#1-3-3-为什么要学习算法" class="headerlink" title="1.3.3 为什么要学习算法"></a>1.3.3 为什么要学习算法</h3><p>计算机科学家通过经验学习，通过看到别人解决问题和自己解决问题来学习。接触不同的问题解决技术，并了解不同的算法是如何设计的，这有助于我们面对下一个具有挑战性的问题。通过思考许多不同的算法，我们可以开始开发模式识别，以便下次出现类似的问题时，可以更好地解决它。</p>
<p>算法通常彼此大不相同，例如前文中的<code>sqrt</code>示例，完全有可能有许多不同的方法来具体实现计算平方根的函数。某种算法使用的资源可能比另一种算法少很多，而某种算法可能需要10倍的时间才能返回结果。我们希望有一些办法来比较这两种解决方案，即使它们都是有效方案，一种也许会比另一种更好。我们可能会认为一种方法更高效，或者运行得更快或使用更少的内存。当我们研究算法时，我们可以学习分析技术，这些分析技术使我们能够仅根据解决方案自身的特点进行比较和对比，而不是基于用于实现它们的程序或计算机的特性。</p>
<p>在最坏的情况下，我们可能有一个难以解决的棘手问题，这意味着没有算法可以在实际的时间内解决问题。能够区分那些有解决办法的问题、没有解决办法的问题和存在解决方案但需要太多时间或其他资源才能合理工作的问题是很重要的。</p>
<p>我们往往需要确定和决定解决方案之间的权衡，作为计算机科学家，除了解决问题的能力外，我们还需要了解和理解解决方案的评估技术。最后，往往有很多方法可以解决问题。找到一个解决方案，然后决定它是否是好的，是我们将不断重复完成的任务。</p>
<h2 id="1-4-基础Python复习"><a href="#1-4-基础Python复习" class="headerlink" title="1.4 基础Python复习"></a>1.4 基础Python复习</h2><p>在本节中，我们将回顾编程语言 Python，并提供上一节中想法的一些更详细的示例。如果你是 Python 的初学者，或者发现需要有关任何内容的更多信息，我们建议你参考诸如<code>Python Language Reference</code>或<code>Python Tutorial</code>这样的资源。在这里我们的目标是重新认识Python语言，并加强一些后几章中的核心概念。</p>
<p>Python 是一种现代、易于学习、面向对象的编程语言。它有一组强大的内置数据类型和易于使用的控件构造。由于 Python 是一种解释性语言，因此只需查看和描述交互式会话，就可以了解它。你应该记得，解释器在提示<code>&gt;&gt;&gt;</code>时显示操作，然后评估您提供的 Python 构造。例如下面这段代码展示了提示、打印功能、结果和下一个提示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"Algorithms and Data Structures"</span>)</span><br><span class="line">Algorithms <span class="keyword">and</span> Data Structures</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-1-从数据开始"><a href="#1-4-1-从数据开始" class="headerlink" title="1.4.1 从数据开始"></a>1.4.1 从数据开始</h3>]]></content>
      <categories>
        <category>Problem Solving with Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-4</title>
    <url>/2020/08/13/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-4/</url>
    <content><![CDATA[<p>在这里记录一些学到的技巧。</p>
<a id="more"></a>
<ol>
<li>对边缘倒角（ctrl+B）可以让边缘变得平滑</li>
<li>通过细分线段+连接两个点的方式把一些不合适的平面分成两个合适的四边形</li>
<li>要做一个凹下去或者凸起的圆柱形效果时，先挤出（E）一点，再挤出完整长度，最后再继续挤出一点，这样在表面细分以后的效果就还是圆柱</li>
<li>要在一个平面开一个圆洞时，先找好圆心（两条线十字交叉的点），选中这个点然后倒角（ctrl+B），这里要勾选“仅顶点”，或者用ctrl+shift+B这个快捷键倒角，然后选2段，再把轮廓调小（大概0.2左右的样子），让它形状圆一些，最后球形化（alt+shift+S），把系数调最大（1），这样加个细分修改器就是标准圆形了。需要掏洞或者做圆柱的时候可以参考第3条来挤出。</li>
<li>安装md3插件的情况下，物体模式下直接ctrl+3可以方便地细分。</li>
</ol>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-3</title>
    <url>/2020/08/11/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-3/</url>
    <content><![CDATA[<p>第二课是建模型相关操作</p>
<p>开始学材质，感觉会比之前的内容有意思。</p>
<a id="more"></a>
<ol>
<li>漫射材质：光照会均匀分布在物体表面，适合粗糙的材质，比如毛发、布料等。</li>
<li>反射材质：会反射周围景观，降低粗糙度就会反射得清楚一些，类似镜子。</li>
<li>透射材质：玻璃水晶等，降低粗糙度会更透明，不同物体有不同折射率，可以查表填对应的数值。</li>
<li>发光材质：就是普通的发光</li>
<li>修改alpha模式可以做玻璃罩的效果</li>
</ol>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>python+sklearn+keras+lstm回归预测问题</title>
    <url>/2020/07/24/python-sklearn-keras-lstm%E5%9B%9E%E5%BD%92%E9%A2%84%E6%B5%8B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>因为接到了股票价格预测的任务，所以开始研究怎么写代码。实际上代码是网上现成的，并不需要自己研究算法和网络结构，复制粘贴再重新组合一下就好，所以难度不大。之前做过sklearn的分类问题，现在做回归，思路是差不多的。</p>
<a id="more"></a>
<p>具体场景是：给定某时间段内的股票价格数据，预测接下来的走势；用同样的算法预测其他股票，看准确率是否有变化；老师的想法是对比国内外市场的差异，看是否在机器学习算法中也有体现。</p>
<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>这里先列一下所有导入的包，可能有一些实际没用上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing, svm</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime <span class="keyword">as</span> date</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neighbors</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> ensemble</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> ExtraTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> quandl</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="comment">#from pandas_datareader import data</span></span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="comment"># 下面这几个是lstm用的</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense, Dropout, LSTM</span><br></pre></td></tr></table></figure>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><ol>
<li><p>使用quandl获取数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> quandl</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">start = date(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">end = date.today()</span><br><span class="line">quandl.ApiConfig.api_key = <span class="string">"gEyzpvmpXReFE8Z8TEps"</span></span><br><span class="line">stock_df = pd.DataFrame(quandl.get(<span class="string">"WIKI/GOOGL"</span>, start_date=start, end_date=end))</span><br></pre></td></tr></table></figure>
<p>第一行导入包；</p>
<p>第二行第三行设置要获取的数据时间范围</p>
<p>第四行设置api_key，这里是需要到quandl官网注册账户，注册好以后会得到这个key，可以用免费数据。注册的时候分为3步，填名字邮箱密码啥的，第三步的时候会需要点一个人机验证的东西才能注册成功，如果没出现人机验证且无法点注册的按钮，说明需要翻墙。</p>
<p>第五行通过<code>quandl.get()</code>函数可以得到所需数据，转成<code>pandas</code>格式方便后续分析。这里的<code>WIKI/GOOGL</code>是谷歌的股票数据在quandl网站上的代码，不过我看不懂那个网站，不清楚要怎么找其他公司和时间的数据，所以暂时就先只用这个了。</p>
</li>
<li><p>通过tushare和pandas_datareader这两个模块也可以获取数据，此外还有其他相关网站。</p>
</li>
<li><p>发现pandas_datareader实际上不太行，查了一下找到了新的数据，数据来源是雅虎财经：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line">start_date = <span class="string">"2000-01-01"</span></span><br><span class="line">end_date = <span class="string">"2018-12-01"</span></span><br><span class="line">stock_df = yf.download(tickers = <span class="string">"MCD"</span>, start = start_date, end = end_date)</span><br></pre></td></tr></table></figure>
<p>这里<code>start_date</code>和<code>end_date</code>也可以写成前面<code>date(2000,1,1)</code>的样子，<code>tickers</code>的参数是可以百度到的股票代码，如果是上海的就是<code>600673.SS</code>这种代码后面加<code>.SS</code>，深圳是<code>.SZ</code>，香港是<code>.HK</code>，美国就是那串字母本身，此外，香港的代码查到的都是五位数，但是在这里要把最高位的0去掉，只用四位数。</p>
<p><code>yf.download</code>会直接返回<code>pandas</code>的<code>dataframe</code>结构，方便后续处理。</p>
<p>和前面那个<code>quandl</code>的比起来，简单了很多，但是有时候会运行很慢，等十几分钟也不出结果。</p>
</li>
</ol>
<h2 id="sklearn的普通方法"><a href="#sklearn的普通方法" class="headerlink" title="sklearn的普通方法"></a>sklearn的普通方法</h2><ol>
<li><p>把预测要用的数据列提取出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df = stock_df[[<span class="string">'Open'</span>, <span class="string">'High'</span>, <span class="string">'Low'</span>, <span class="string">'Close'</span>, <span class="string">'Volume'</span>]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里使用过去一天的数据来预测当天的收盘价，因此要新建一列来存下一天的收盘价作为机器学习的目标值<code>y</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df[<span class="string">'object'</span>] = stock_df[<span class="string">'Close'</span>].shift(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把除了目标列以外的其他数据单独提出来作为<code>X</code>，并做标准化处理，然后去掉最后一行（因为最后一行没有下一天的目标值，所以没法用）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array(stock_df.drop([<span class="string">'object'</span>], <span class="number">1</span>))</span><br><span class="line">X = preprocessing.scale(X)</span><br><span class="line">X = X[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>把目标列提出来作为<code>y</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">y = np.array(stock_df[<span class="string">'object'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>划分训练集和测试集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把要用的模型都准备好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models = []</span><br><span class="line">models.append((<span class="string">'DecisionTree'</span>, tree.DecisionTreeRegressor()))</span><br><span class="line">models.append((<span class="string">'LR'</span>, linear_model.LinearRegression()))</span><br><span class="line">models.append((<span class="string">'KNN'</span>, neighbors.KNeighborsRegressor()))</span><br><span class="line">models.append((<span class="string">'RF'</span>, ensemble.RandomForestRegressor(n_estimators=<span class="number">20</span>)))</span><br><span class="line">models.append((<span class="string">'ABR'</span>, ensemble.AdaBoostRegressor(n_estimators=<span class="number">50</span>)))</span><br><span class="line">models.append((<span class="string">'SVM'</span>, svm.SVR(gamma=<span class="string">'auto'</span>)))</span><br><span class="line">models.append((<span class="string">'GBRT'</span>, ensemble.GradientBoostingRegressor(n_estimators=<span class="number">100</span>)))</span><br><span class="line">models.append((<span class="string">'Bagging'</span>, BaggingRegressor()))</span><br><span class="line">models.append((<span class="string">'ExtraTree'</span>, ExtraTreeRegressor()))</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历所有模型，在训练集上10折交叉验证并输出模型评价，在测试集上计算均方根误差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, model <span class="keyword">in</span> models:</span><br><span class="line">    scores = cross_val_score(model, x_train, y_train, cv=<span class="number">10</span>, scoring=<span class="literal">None</span>)</span><br><span class="line">    print(<span class="string">'%s: %f (%f)'</span> % (name, scores.mean(), scores.std()))</span><br><span class="line">    model.fit(x_train, y_train)</span><br><span class="line">    <span class="comment">#print(model.score(x_test, y_test))</span></span><br><span class="line">    y_predict = model.predict(x_test)</span><br><span class="line">    print(<span class="string">'RMSE: '</span>, np.sqrt(metrics.mean_squared_error(y_test,y_predict)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来要随便选个模型画图看看</p>
<ol>
<li><p>选模型并用训练集训练模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = ensemble.GradientBoostingRegressor(n_estimators=<span class="number">100</span>)</span><br><span class="line">clf.fit(x_train, y_train)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从所有的X中，选取后30%，用模型预测结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index = len(X)*<span class="number">7</span>//<span class="number">10</span></span><br><span class="line">predict_x = X[index:]</span><br><span class="line">predict_y = clf.predict(predict_x)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在原本的<code>dataframe</code>中新建一列来存这个预测结果，这样后面画图能直接用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df[<span class="string">'Predict'</span>] = np.nan			<span class="comment">#新建一列并初始化为空值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> predict_y:						<span class="comment">#遍历预测结果</span></span><br><span class="line">    stock_df[<span class="string">'Predict'</span>][index] = i		<span class="comment">#从预测的第一个数开始填值</span></span><br><span class="line">    index += <span class="number">1</span>							<span class="comment">#移动到下一个值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>画图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(stock_df[<span class="string">'Close'</span>], label=<span class="string">'Close'</span>, color=<span class="string">'deepskyblue'</span>)	<span class="comment">#实际值</span></span><br><span class="line">stock_df[<span class="string">'Predict'</span>].plot()										<span class="comment">#预测值</span></span><br><span class="line">plt.legend(loc=<span class="number">4</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Date'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Price'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="lstm"><a href="#lstm" class="headerlink" title="lstm"></a>lstm</h2><ol>
<li><p>预处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df[<span class="string">'Date'</span>] = stock_df.index</span><br><span class="line">data = stock_df.sort_index(ascending=<span class="literal">True</span>, axis=<span class="number">0</span>)</span><br><span class="line">new_data = pd.DataFrame(index=range(<span class="number">0</span>, len(stock_df)), columns=[<span class="string">'Date'</span>, <span class="string">'Close'</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(data)):</span><br><span class="line">    new_data[<span class="string">'Date'</span>][i] = data[<span class="string">'Date'</span>][i]</span><br><span class="line">    new_data[<span class="string">'Close'</span>][i] = data[<span class="string">'Close'</span>][i]</span><br><span class="line"><span class="comment"># setting index</span></span><br><span class="line">new_data.index = new_data.Date</span><br><span class="line">new_data.drop(<span class="string">'Date'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这样的结果就是把日期和收盘价单独提出来了</p>
</li>
<li><p>划分训练集和测试集，是7:3划分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataset = new_data.values</span><br><span class="line">t_len = len(dataset)*<span class="number">7</span>//<span class="number">10</span></span><br><span class="line">train = dataset[<span class="number">0</span>:t_len, :]</span><br><span class="line">valid = dataset[t_len:, :]</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理训练集数据，lstm会利用过去一段时间的数据，这里设置为过去60天</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#标准化处理</span></span><br><span class="line">scaler = MinMaxScaler(feature_range=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">scaled_data = scaler.fit_transform(dataset)</span><br><span class="line"><span class="comment">#定义列表存放数据</span></span><br><span class="line">x_train, y_train = [], []</span><br><span class="line"><span class="comment">#对于每一天的y，x的值都是过去60天的收盘价</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60</span>, len(train)):</span><br><span class="line">    x_train.append(scaled_data[i - <span class="number">60</span>:i, <span class="number">0</span>])</span><br><span class="line">    y_train.append(scaled_data[i, <span class="number">0</span>])</span><br><span class="line"><span class="comment">#把x的格式改成训练需要的格式</span></span><br><span class="line">x_train, y_train = np.array(x_train), np.array(y_train)</span><br><span class="line">x_train = np.reshape(x_train, (x_train.shape[<span class="number">0</span>], x_train.shape[<span class="number">1</span>], <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立和训练lstm模型，这里训练50轮，实际上感觉100轮和50轮没什么差别；这里用了4层lstm，但实际上感觉一层就够了。在训练时用均方根误差作为指标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create and fit the LSTM network</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=<span class="number">50</span>, return_sequences=<span class="literal">True</span>, input_shape=(x_train.shape[<span class="number">1</span>], <span class="number">1</span>)))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(units = <span class="number">50</span>, return_sequences = <span class="literal">True</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(units = <span class="number">50</span>, return_sequences = <span class="literal">True</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(units=<span class="number">50</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.compile(loss=<span class="string">'mean_squared_error'</span>, optimizer=<span class="string">'adam'</span>)</span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">50</span>, batch_size=<span class="number">32</span>, verbose=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这些lstm模型用的激活函数是默认的<code>tanh</code>，然后训练时会有错误信息，据一些人说是可以忽略的，参见<a href="https://github.com/tensorflow/tensorflow/issues/30263" target="_blank" rel="noopener">链接</a>。如果把激活函数改成<code>sigmoid</code>，就没报错了，但是发现训练结果格外不好，不清楚是我操作问题还是这个激活函数就不合适。总之暂且先用<code>tanh</code>。</p>
</li>
<li><p>准备测试集，这里和训练集一样，往前倒60个数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = new_data[len(new_data) - len(valid) - <span class="number">60</span>:].values</span><br><span class="line">inputs = inputs.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">inputs = scaler.transform(inputs)</span><br><span class="line">X_test, Y_test = [], []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60</span>, inputs.shape[<span class="number">0</span>]):</span><br><span class="line">    X_test.append(inputs[i - <span class="number">60</span>:i, <span class="number">0</span>])</span><br><span class="line">X_test = np.array(X_test)</span><br><span class="line">X_test = np.reshape(X_test, (X_test.shape[<span class="number">0</span>], X_test.shape[<span class="number">1</span>], <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>用训练好的lstm模型对测试集进行测试并把值改回标准化前的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">closing_price = model.predict(X_test)</span><br><span class="line">closing_price = scaler.inverse_transform(closing_price)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出均方根误差</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rms &#x3D; np.sqrt(np.mean(np.power((valid - closing_price), 2)))</span><br><span class="line">print(rms)</span><br></pre></td></tr></table></figure>
</li>
<li><p>和sklearn一样的画图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train = new_data[:t_len]</span><br><span class="line">valid = new_data[t_len:]</span><br><span class="line">valid[<span class="string">'Predictions'</span>] = closing_price</span><br><span class="line">plt.plot(train[<span class="string">'Adj. Close'</span>], color=<span class="string">'deepskyblue'</span>, label = <span class="string">'Adj. Close'</span>)</span><br><span class="line">plt.plot(valid[<span class="string">'Adj. Close'</span>], color=<span class="string">'deepskyblue'</span>)</span><br><span class="line">plt.plot(valid[<span class="string">'Predictions'</span>], label = <span class="string">'Predict'</span>)</span><br><span class="line">plt.legend(loc=<span class="number">4</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Date'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Price'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><ol>
<li>之后有空的时候再增加这些算法的理论介绍</li>
<li>回归和分类的代码结构差不多，只是函数名称和模型评价指标不太一样，关于评价指标可以参考<a href="https://scikit-learn.org/stable/modules/model_evaluation.html#the-scoring-parameter-defining-model-evaluation-rules" target="_blank" rel="noopener">这个</a>。</li>
</ol>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sklearn</tag>
        <tag>keras</tag>
        <tag>lstm</tag>
        <tag>回归</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-N-in-One: A Novel Location-Based-Service</title>
    <url>/2020/07/18/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-N-in-One-A-Novel-Location-Based-Service/</url>
    <content><![CDATA[<h1 id="新的LBS系统"><a href="#新的LBS系统" class="headerlink" title="新的LBS系统"></a>新的LBS系统</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ol>
<li>现有LBS基于单一POI，而现实里用户需要多POI的LBS</li>
<li>本文将单一POI的LBS扩展为使用单个查询请求多个POI的LBS</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li>场景：用户希望同时查询某地点附近的多个兴趣点（例如饭店和KTV都需要）</li>
<li>和单兴趣点推荐的差别：要综合考虑多个兴趣点的评价和距离以及用户需求，例如吃完饭去KTV这种场景就需要推荐的饭店和KTV近一些</li>
<li>本文实现的功能：<ol>
<li>Ranking mode（排序模式）：根据每个兴趣点的评价和兴趣点之间的距离，提供一个按评分排序的列表中的前K个兴趣点组合</li>
<li>Service area mode（服务区模式）：找出一个包含了最多兴趣点的矩形区域</li>
</ol>
</li>
<li>挑战性：<ol>
<li>受限于兴趣点之间的距离，实现”N-in-One”与单纯找N个相互独立的兴趣点并不同；</li>
<li>服务区模式可能会有木桶效应问题：返回的聚类结果可能因为有一个或多个热门兴趣点被排除。</li>
</ol>
</li>
<li>本文提出：<ol>
<li>排序模式：基于平面扫描算法，垂直线从右往左扫描兴趣点区域，遇到兴趣点时回溯和已经记录的兴趣点匹配，以查找最优K聚类；为实现回溯过程中的POI匹配，引入“可查看网络”；</li>
<li>服务区模式：引入“瓶颈值”来描述 POI 的重复使用数，使用计算几何来识别给定大小的矩形，该矩形可以覆盖尽可能多的最佳Q群集，同时减少木桶效应。</li>
</ol>
</li>
<li>本文组织结构：<ol>
<li>第二部分、第三部分分别介绍排序模式和服务区模式</li>
<li>第四部分仿真实验</li>
<li>第五部分相关研究</li>
<li>第六部分总结</li>
</ol>
</li>
</ol>
<h2 id="“N-IN-ONE”-LBS-IN-THE-RANKING-MODE"><a href="#“N-IN-ONE”-LBS-IN-THE-RANKING-MODE" class="headerlink" title="“N-IN-ONE” LBS IN THE RANKING MODE"></a>“N-IN-ONE” LBS IN THE RANKING MODE</h2><h3 id="Metric-to-Evaluate-a-POI-Cluster"><a href="#Metric-to-Evaluate-a-POI-Cluster" class="headerlink" title="Metric to Evaluate a POI Cluster"></a>Metric to Evaluate a POI Cluster</h3><p>POI聚类$\Pi=\{p_1,…,p_N\}$，其中$p_j$是第$j$个兴趣点位置</p>
<p><strong>定义1</strong>  POI聚类的直径：覆盖该聚类所有兴趣点的最小圆直径</p>
<p><strong>定义2</strong>  POI聚类的中心：覆盖该聚类所有兴趣点的最小圆圆心</p>
<p>最小圆问题：直径取决于聚类中距离最远的两点之间的距离上限</p>
<p><strong>评估函数</strong>：</p>
<script type="math/tex; mode=display">
R(\Pi)=\sum_{j=1}^{N}\alpha_je_j-\beta D(\Pi)-\gamma d(\Pi,c)</script><p>其中，$e_j$是对该聚类内第$j$个兴趣点的评估值，$\alpha_j$是对应的权重；$D(\Pi)$是聚类的直径，体现了聚类的离散程度，$\beta$是对应的权重；$d(\Pi,c)$是当前位置$c$到聚类中心的距离，$\gamma$是对应权重。所有权重由用户自己决定。</p>
<h3 id="Overview-of-Our-Algorithm-for-the-Ranking-Mode"><a href="#Overview-of-Our-Algorithm-for-the-Ranking-Mode" class="headerlink" title="Overview of Our Algorithm for the Ranking Mode"></a>Overview of Our Algorithm for the Ranking Mode</h3><p>用户兴趣区域内有$n$个POI，集合表示为$\Omega$，$||\Omega||=n$</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>所有POI根据x坐标升序排列（即标号大的POI出现在右边）</li>
<li>垂直线从右向左扫描兴趣区域</li>
<li>当垂直线扫到了某个POI，算法会检查之前找到的POI聚类，并将该POI加到之前的聚类中形成新聚类，聚类中所有元素的POI类型在任何时刻都不同</li>
<li>基于新聚类，更新最优K结果</li>
<li>当兴趣区域内的POI都被扫描过时，上述过程结束，最终的最优K结果被推送给用户</li>
</ol>
<p><strong>关键问题</strong>：扫描到一个POI时，如何从之前的POI集合中高效识别那些需要被回溯的</p>
<p><strong>解决方法</strong>：引入可视网络的概念，$N=(\Omega,E)$，$\Omega$是兴趣点集合，E是可视线集合</p>
<p>可视线：由扫描到的POI及其可视点之一决定。当扫描到某个POI $P_i$时，算法根据其可视线回溯L层邻近POI</p>
<p>L层邻近POI：可视网络中，比$P_i$扫描得早、且从$P_i$出发可通过最多L个可视线到达的POI</p>
<p>采用递归方法，整体分为两步：</p>
<ol>
<li>构建可视网络</li>
<li>移动和回溯</li>
</ol>
<h3 id="Constructing-the-Viewable-Network"><a href="#Constructing-the-Viewable-Network" class="headerlink" title="Constructing the Viewable Network"></a>Constructing the Viewable Network</h3><p>构建可视网络的思路大致是：从右向左扫描点（也就是从最后一个点开始），每扫描到一个点就看它右边是否有没被挡住可以直接相连的点，如果有就连起来，这样一直扫到最左边的点（也就是第一个点），网络就构建好了。</p>
<p>实际上这个网络扫描的方向并不一定要这样，也可以从左往右。</p>
<p>时间复杂度的分析和证明省略。</p>
<p>该算法的具体流程如下：</p>
<p>​    输入：POI集合根据x坐标升序排列</p>
<ol>
<li>扫描线自右向左扫描</li>
<li>当扫描到$P_n$、$P_{n-1}$、$P_{n-2}$的时候：<ol>
<li>$P_n$、$P_{n-1}$、$P_{n-2}$加到集合V里，集合V用来存放已经扫描过的点；</li>
<li>如果$P_i$是集合V的凸包的顶点，就把$P_i$加到集合$C^P(V)$里；</li>
<li>如果$L_i$是集合V的凸包的边，就把$L_i$加到集合$C^E(V)$里；</li>
<li>把集合$C^E(V)$加到集合E里，集合E用来存放可视线；</li>
</ol>
</li>
<li>令$i=n-2$</li>
<li>重复循环一下流程：<ol>
<li>令$i=i-1$</li>
<li>遍历集合$C^P(V)$中的点记作$P_k$，如果点$P_i$、$P_k$之间的连线与集合$C^E(V)$的交集是点$P_k$，则把$P_k$加入集合$A_i$，集合$A_i$用来存放点$P_i$的可视点</li>
<li>遍历集合$A_i$中的所有$P_k$，把点$P_i$、$P_k$之间的连线加入到之前的边集合E中</li>
<li>把$P_i$加入集合V中</li>
<li>按之前的规则更新集合$C^P(V)$和$C^E(V)$</li>
</ol>
</li>
<li>$i=0$时结束循环，集合E就是所有可视边</li>
</ol>
<h3 id="Searching-Heterogeneous-POIs"><a href="#Searching-Heterogeneous-POIs" class="headerlink" title="Searching Heterogeneous POIs"></a>Searching Heterogeneous POIs</h3><ol>
<li>总共有$n$个兴趣点</li>
<li>兴趣点异构，总共有$j$个类型</li>
<li>有$j$个异构兴趣点的聚类的集合记作$G_j$，而$G_1$是有$n$个聚类的集合，其中每个聚类都包含一个兴趣点</li>
<li>垂直线从第$n-j+1$个点开始扫描，L层邻接POI集合最多有$j$个POI，这也是构建包含j-1个异构兴趣点的聚类的最小兴趣点编号</li>
<li>整个算法递归地根据$G_{j-1}$计算$G_j$，具体过程如下：<ol>
<li>每当扫描到一个兴趣点$P_i$时，遍历$G_{j-1}$中的聚类，如果某个聚类属于$P_i$的L层邻接POI集合，则把该聚类加到一个新集合$S_{i,j-1}$中</li>
<li>第一步中的聚类遍历结束后，遍历得到的集合$S_{i,j-1}$中的聚类，如果$P_i$和这个聚类异构，则把$P_i$和这个聚类组成的集合加到集合$G_j$中</li>
<li>继续用同样的思路扫描兴趣点$P_{i-1}$，这样循环直到$P_1$被扫描完</li>
<li>最终得到$G_j$作为异构兴趣点聚类</li>
</ol>
</li>
</ol>
<p>复杂度分析省略。</p>
<h3 id="Searching-the-Best-K-Results-in-the-Ranking-Mode"><a href="#Searching-the-Best-K-Results-in-the-Ranking-Mode" class="headerlink" title="Searching the Best K Results in the Ranking Mode"></a>Searching the Best K Results in the Ranking Mode</h3><p>算法1构建可视网络得到的可视线记作$E$；算法2寻找异构兴趣点聚类的集合记作$G_{N-1}$（它包括所有具有N-1个异构兴趣点的聚类）；兴趣点$P_i$的L层邻接兴趣点记作$L_i$。</p>
<ol>
<li>从第$i=n-N+1$个兴趣点开始，从右向左扫描所有兴趣点</li>
<li>遍历$G_{N-1}$中的聚类，如果聚类属于$L_i$，则把聚类加到一个新集合$S_{i,N-1}$中</li>
<li>遍历新集合$S_{i,N-1}$中的聚类，如果$P_i$和聚类异构，则把$P_i$和这个聚类组成的集合插入到列表B中，插入顺序按聚类的评价降序</li>
<li>如果列表B中的元素个数大于K，则删去最后一个元素</li>
<li>继续扫描第$i-1$个兴趣点，执行相同的操作，直到扫描到$P_1$</li>
</ol>
<p>复杂度分析省略。</p>
<h2 id="“N-IN-ONE”-LBS-IN-THE-SERVICE-AREA-MODE"><a href="#“N-IN-ONE”-LBS-IN-THE-SERVICE-AREA-MODE" class="headerlink" title="“N-IN-ONE” LBS IN THE SERVICE AREA MODE"></a>“N-IN-ONE” LBS IN THE SERVICE AREA MODE</h2><p>服务区：给定长宽的矩形区域，该区域内的兴趣点密度最大，且所有兴趣点都属于最优Q聚类</p>
<p>矩形区域的权重受三个因素影响：</p>
<ol>
<li>矩形覆盖的最优兴趣点聚类个数</li>
<li>矩形内的兴趣点聚类评分</li>
<li>兴趣点聚类的分布</li>
</ol>
<p><strong>定义3.1</strong>  如果一个兴趣点聚类$\Pi$的中心在某区域$\Gamma$内，则称该聚类在该区域内。</p>
<p>就此将聚类视作其中心点，将该问题转变为<code>maximizing range sum</code>（最大子序列？）</p>
<p>当一个兴趣点属于多个聚类时，我们称它被多个聚类复用了。这种情况如果该兴趣点不可用，则会导致区域内大量聚类都不可用，这不好。</p>
<p><strong>定义3.2</strong>  一个矩形区域内聚类集合的瓶颈值$B$是指，该区域内被复用次数最多的兴趣点所对应的复用次数。</p>
<p><strong>定义3.3</strong> 矩形的权重由该区域内聚类的评分和该区域的瓶颈值决定，计算公式如下：</p>
<script type="math/tex; mode=display">
W(C)=\varepsilon\sum_{\Pi\in C}R(\Pi)-\eta B</script><p>其中，$\varepsilon$和$\eta$都是常数系数。</p>
<p>找服务区的算法流程：</p>
<p>复杂度分析省略。</p>
<h2 id="PERFORMANCE-EVALUATION"><a href="#PERFORMANCE-EVALUATION" class="headerlink" title="PERFORMANCE EVALUATION"></a>PERFORMANCE EVALUATION</h2><h3 id="Performance-Evaluation-Based-on-Synthetic-Data"><a href="#Performance-Evaluation-Based-on-Synthetic-Data" class="headerlink" title="Performance Evaluation Based on Synthetic Data"></a>Performance Evaluation Based on Synthetic Data</h3><h3 id="Performance-Evaluation-Based-on-Real-World-Data"><a href="#Performance-Evaluation-Based-on-Real-World-Data" class="headerlink" title="Performance Evaluation Based on Real-World Data"></a>Performance Evaluation Based on Real-World Data</h3><p>实验部分不看了，省略。</p>
<h2 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h2><p>当前LBS领域的热点研究：基于位置信息的推荐系统，尤其是兴趣点推荐</p>
<ol>
<li>潜在Dirichlet分配（LDA）</li>
<li>朴素贝叶斯</li>
<li>地理概率分析框架，策略性地考虑多个因素</li>
<li>动态聚类算法识别运动轨迹</li>
</ol>
<p>路线推荐同样热门</p>
<ol>
<li>分析用户交通路线来得到两地之间最受欢迎的路线</li>
<li>基于集体知识的路线推荐框架</li>
<li>候选-生成-验证策略得到K近邻轨迹</li>
<li>KNN+更多因素的分析</li>
<li>LIT前缀挖掘算法</li>
<li>网络优化问题</li>
<li>轨迹大数据</li>
</ol>
<p>本文和上述内容的共同点：给用户返回多个POI</p>
<p>不同点：本文侧重查询，是LBS的基础服务；上述侧重推荐，是LBS的衍生服务</p>
<p>本文的创新性：现有LBS的基础服务不涉及多POI查询，本文针对基础服务进行了改进</p>
<h2 id="CONCLUSION-AND-FUTURE-WORK"><a href="#CONCLUSION-AND-FUTURE-WORK" class="headerlink" title="CONCLUSION AND FUTURE WORK"></a>CONCLUSION AND FUTURE WORK</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>LBS</tag>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-2</title>
    <url>/2020/07/07/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<p>第二课是建模型相关操作</p>
<a id="more"></a>
<p>我发现了，blender入门教程其实就是教快捷键。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进入编辑模式</td>
<td style="text-align:center">TAB</td>
</tr>
<tr>
<td style="text-align:center">切换选择模式</td>
<td style="text-align:center">W</td>
</tr>
<tr>
<td style="text-align:center">环选，例如点竖线会把横着一圈选中，而点横线会把竖着的一圈选中</td>
<td style="text-align:center">alt+左键</td>
</tr>
<tr>
<td style="text-align:center">连选</td>
<td style="text-align:center">ctrl</td>
</tr>
<tr>
<td style="text-align:center">多选（这个和上一个刚好和windows系统的操作相反）</td>
<td style="text-align:center">shift</td>
</tr>
<tr>
<td style="text-align:center">全选</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">取消全选</td>
<td style="text-align:center">双击A</td>
</tr>
<tr>
<td style="text-align:center">挤出</td>
<td style="text-align:center">E</td>
</tr>
<tr>
<td style="text-align:center">环切，环切确认的时候滚动滚轮可以一次切好几个</td>
<td style="text-align:center">ctrl+R</td>
</tr>
<tr>
<td style="text-align:center">倒角</td>
<td style="text-align:center">ctrl+B</td>
</tr>
<tr>
<td style="text-align:center">内插面</td>
<td style="text-align:center">I（进编辑模式，双击I会有不太一样的效果，但是我说不清是什么样的）</td>
</tr>
<tr>
<td style="text-align:center">环切</td>
<td style="text-align:center">ctrl+R</td>
</tr>
<tr>
<td style="text-align:center">偏移环切线</td>
<td style="text-align:center">ctrl+shift+R</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>typora图床功能设置</title>
    <url>/2020/07/07/typora%E5%9B%BE%E5%BA%8A%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>终于不用自己上传github然后再复制链接到markdown了！</p>
<a id="more"></a>
<ol>
<li><p>打开typora，文件—&gt;偏好设置—&gt;图像，然后按照下图设置：</p>
<p><img src="https://pic3.zhimg.com/80/v2-2f7c965687ee0689ced4a80a608599be_1440w.jpg" alt="img"></p>
</li>
<li><p>设置好以后点下载或更新，下载更新结束以后，浏览器打开<a href="https://sm.ms/home/apitoken" target="_blank" rel="noopener">smms</a>并注册账号和登录，注册的时候要填用户名和邮箱，登录的时候不是邮箱登录而是用户名登录；</p>
</li>
<li><p>注册并登录以后打开<a href="https://sm.ms/home/apitoken" target="_blank" rel="noopener">新链接</a>，secret token那里是空的，点下面的generate secret token，会得到一串字符，如下图：</p>
<p><img src="https://pic2.zhimg.com/80/v2-f8e838a39e52ef233bca3c190af483f1_1440w.jpg" alt="img"></p>
</li>
<li><p>回到刚才的typora，还是图像那里，打开配置文件，如果要选应用程序就找记事本之类的编辑器；</p>
</li>
<li><p>把下面的代码复制粘贴进去和保存：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"picBed"</span>: &#123;</span><br><span class="line">    <span class="attr">"uploader"</span>: <span class="string">"smms"</span>, <span class="comment">// 代表当前的默认上传图床为 SM.MS,</span></span><br><span class="line">    <span class="attr">"smms"</span>: &#123;</span><br><span class="line">      <span class="attr">"token"</span>: <span class="string">"这里面的token换成你上个页面的申请的token"</span> <span class="comment">//一定要换</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"picgoPlugins"</span>: &#123;&#125; <span class="comment">// 为插件预留</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>到此为止就好了，还是在图像那里，点验证图片上传选项，可以验证一下有没有问题。</p>
</li>
</ol>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/137310314" target="_blank" rel="noopener">知乎链接</a></p>
]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-1</title>
    <url>/2020/07/06/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<p>因为种种原因，我决定培养个兴趣爱好，于是开始学blender。</p>
<a id="more"></a>
<p>第一课是移动旋转缩放的操作。</p>
<h2 id="快捷键记录"><a href="#快捷键记录" class="headerlink" title="快捷键记录"></a>快捷键记录</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">视角旋转</td>
<td style="text-align:center">鼠标中键按着拖动</td>
</tr>
<tr>
<td style="text-align:center">视角缩放</td>
<td style="text-align:center">滚动鼠标滚轮</td>
</tr>
<tr>
<td style="text-align:center">视角平移</td>
<td style="text-align:center">shift+鼠标中键按着拖动</td>
</tr>
<tr>
<td style="text-align:center">物体移动</td>
<td style="text-align:center">G</td>
</tr>
<tr>
<td style="text-align:center">物体缩放</td>
<td style="text-align:center">S</td>
</tr>
<tr>
<td style="text-align:center">物体旋转</td>
<td style="text-align:center">R</td>
</tr>
<tr>
<td style="text-align:center">物体删除</td>
<td style="text-align:center">Delete或者X</td>
</tr>
<tr>
<td style="text-align:center">撤销操作</td>
<td style="text-align:center">Ctrl+Z</td>
</tr>
<tr>
<td style="text-align:center">插入关键帧</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">新建各种物体</td>
<td style="text-align:center">shift+A</td>
</tr>
<tr>
<td style="text-align:center">进入/退出编辑模式</td>
<td style="text-align:center">TAB（需要安装M3工具）</td>
</tr>
<tr>
<td style="text-align:center">新建一条边（存疑）</td>
<td style="text-align:center">Ctrl+R</td>
</tr>
<tr>
<td style="text-align:center">进入面模式</td>
<td style="text-align:center">3（不是小键盘的那个）</td>
</tr>
<tr>
<td style="text-align:center">选中某条竖线所在的横面</td>
<td style="text-align:center">alt+左键点击</td>
</tr>
<tr>
<td style="text-align:center">复制物体</td>
<td style="text-align:center">shift+D</td>
</tr>
<tr>
<td style="text-align:center">平面细分</td>
<td style="text-align:center">Ctrl+3</td>
</tr>
<tr>
<td style="text-align:center">打开切换视图面板，可以插入智能摄像机，还可以锁定视图</td>
<td style="text-align:center">pagedown（需要安装M3工具）</td>
</tr>
<tr>
<td style="text-align:center">进入摄像机视图</td>
<td style="text-align:center">0（小键盘的那个，没小键盘就得改设置或者鼠标点视图按钮）</td>
</tr>
<tr>
<td style="text-align:center">选多个物体</td>
<td style="text-align:center">按住shift左键点物体们</td>
</tr>
<tr>
<td style="text-align:center">物体组合</td>
<td style="text-align:center">Ctrl+P 最后一个被选中的是父物体</td>
</tr>
<tr>
<td style="text-align:center">进入/退出四视图</td>
<td style="text-align:center">Ctrl+alt+Q</td>
</tr>
<tr>
<td style="text-align:center">进入各种视图</td>
<td style="text-align:center">~</td>
</tr>
<tr>
<td style="text-align:center">开/关工具栏</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">快捷键进入移动旋转缩放后在坐标轴操作</td>
<td style="text-align:center">分别按XYZ</td>
</tr>
<tr>
<td style="text-align:center">快捷键进入移动旋转缩放后在某平面操作</td>
<td style="text-align:center">按shift+锁定不变的那个轴</td>
</tr>
<tr>
<td style="text-align:center">物体位置角度缩放归0</td>
<td style="text-align:center">alt+G/R/S</td>
</tr>
<tr>
<td style="text-align:center">打开变换面板</td>
<td style="text-align:center">Ctrl+A</td>
</tr>
</tbody>
</table>
</div>
<h2 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h2><p>学着<a href="https://www.bilibili.com/video/BV1T4411N7GE?p=5" target="_blank" rel="noopener">这个</a>做的</p>
<p>我好困啊懒得写了</p>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Combinatorial Multi-Armed Bandit Based Unknown Worker Recruitment in Heterogeneous Crowdsensing</title>
    <url>/2020/07/05/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Combinatorial%20Multi-Armed%20Bandit%20Based%20Unknown%20Worker%20Recruitment%20in%20Heterogeneous%20Crowdsensing/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li>本文研究问题：异构群智感知系统（也就是众包）中对未知worker的招募</li>
<li>本文场景：requester招募workers收集某城市交通路口一段时间内的交通数据，整个收集过程分为多轮，每轮包含一些和地点有关的任务，对应一个交通路口。每个任务有权重，表示重要性。每个worker能做一个或多个任务，且不同worker能做的任务可能不一样。worker会告诉平台自己能做的任务和期望收到的费用。worker完成任务的质量服从未知分布。</li>
<li>本文目的：设计worker招聘方案，在给定预算的情况下，最大限度提高总任务完成质量。</li>
<li>本文面临的挑战：平台不知道worker的质量分布</li>
<li>本文解决挑战的方法：让worker先完成一些任务，然后从任务结果里学习worker的质量，最后从中找最好的worker，简单来说分为exploration和exploitation。本文需要平衡这两个过程，从而实现目标（这么看一开始被完成的那些任务就被牺牲了）。</li>
<li>本文将上述问题概括为组合多臂老虎机模型（ Combinatorial Multi Armed Bandit），并且说和现存的CMAB模型都不一样；然后本文用扩展的上置信界算法（Upper Confidence Bound）。多臂老虎机模型我之前听说过，但是完全不了解，所以要先查一下。</li>
<li>本文贡献：<ol>
<li>介绍了这个场景并把它概括为多臂老虎机</li>
<li>用UCB来解决这个问题</li>
<li>研究了扩展问题：worker质量和期望收费都不知道的场景</li>
<li>做了仿真实验，分析了性能</li>
</ol>
</li>
</ol>
<h2 id="Combinatorial-Multi-Armed-Bandit"><a href="#Combinatorial-Multi-Armed-Bandit" class="headerlink" title="Combinatorial Multi Armed Bandit"></a>Combinatorial Multi Armed Bandit</h2><ol>
<li>实质是未知概率情况下的选择问题，比如赌博</li>
<li>具体来说，重复一个选择过程，每次有k个选项或动作可供选择，每次选择一个动作后会获得相应的奖励。目标是为了最大化k次后的奖励。选项对应的收益服从某种未知概率分布，对于实验者本人而言是黑箱，因此需要采取各种可能的方式来最大化收益。</li>
<li>基础思路：每一轮根据之前的结果更新对收益的期望，期望计算方法为[之前采取该选项所得到的所有收益]/[之前采取过该选项的次数]，也就是平均每次得到的收益；只要时间够长，这个算出来的期望就会接近真实收益。</li>
</ol>
<h2 id="System-model-and-problem"><a href="#System-model-and-problem" class="headerlink" title="System model and problem"></a>System model and problem</h2><ol>
<li>字母符号表示：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>t</td>
<td>当前轮数，第t轮</td>
</tr>
<tr>
<td>N</td>
<td>N个workers的集合，第i个worker</td>
</tr>
<tr>
<td>M</td>
<td>M个任务的集合，第j个任务</td>
</tr>
<tr>
<td>B</td>
<td>预算</td>
</tr>
<tr>
<td>$w_j$</td>
<td>第j个任务的权重，所有权重加起来的和是1</td>
</tr>
<tr>
<td>L</td>
<td>每个worker会向平台提交L个任务候选</td>
</tr>
<tr>
<td>$p_i^l=\langle M_i^l,c_i^l \rangle$</td>
<td>第i个worker提交的第l个选项，其中$M_i^l$表示该worker的任务候选集合，$c_i^l$表示收费</td>
</tr>
<tr>
<td>$c_i^l=\varepsilon_i f(\vert M_i^l \vert)$</td>
<td>每个worker的收费与该选项包含的任务数正相关，每个worker的收费系数不同</td>
</tr>
<tr>
<td>$P_i=\{p_i^l \vert 1&lt;=l&lt;=L\}$</td>
<td>第i个worker提交的选项集合</td>
</tr>
<tr>
<td>$P=U_{i\in N}P_i $</td>
<td>所有选项集合</td>
</tr>
<tr>
<td>$q_{i,j}^t \vert j\in M_i^l$</td>
<td>第i个worker在第t轮完成第j个任务的质量</td>
</tr>
<tr>
<td>$P^t\subset P$</td>
<td>第t轮中平台对所有workers所选的选项集合</td>
</tr>
<tr>
<td>$p_i^l\in P^t$</td>
<td>第t轮平台对第i个worker选了其第l个选项</td>
</tr>
<tr>
<td>$u^j(P^t)$</td>
<td>第t轮采用方案$P^t$时的第j个任务的最终质量（所有完成任务结果中最好的那个）</td>
</tr>
<tr>
<td>$u(P^t)$</td>
<td>第t轮采用方案$P^t$时所有任务的最终质量和，也就是上一个符号乘权重再加起来</td>
</tr>
<tr>
<td>$n_i^l(t)$</td>
<td>第i个worker的第l个选项被选的次数</td>
</tr>
<tr>
<td>$n_i(t)$</td>
<td>第i个worker被学习过的次数</td>
</tr>
<tr>
<td>$\overline{q}_{i(t)}$</td>
<td>截至到第t轮学习到的第i个worker的质量</td>
</tr>
</tbody>
</table>
</div>
<p>   需要注意：虽然worker可以提交L个任务候选，但是每一轮只能最终完成一个选项，这里假设$c_i^1$到$c_i^L$是从小到大排的，也就是说最后一个的收费最高，且实际中，c的取值一般和M的长度（就是任务数量）正相关。</p>
<ul>
<li><p>这里有个奇怪的问题，我以为每个选项就是单独一个任务，然后c是对应的收费，但是看起来每个选项是任务集合，然后c是收费，也就是说比如有5个任务用abcde表示，某个worker的选项就会是{a,b,收费3}{b,c,d,收费5}{a,c,d,e,收费10}，这样看起来好奇怪。希望后面有解释。</p>
</li>
<li><p>虽然这样的设定有点别扭，不过解释是说：每一轮每个worker完成$|M_i^l|$个任务，也就会学习到到$|M_i^l|$个任务质量，就是说任务质量会被学习$|M_i^l|$次，这和传统CMAB不一样。</p>
</li>
<li><p>每轮每个worker最多定一个选项（也可以不选）</p>
</li>
</ul>
<ol>
<li><p>要研究的问题：给定预算，每轮招募K个workers，使得所有轮中完成的所有任务的权重加起来最大。</p>
</li>
<li><p>数学模型：</p>
<p>目标函数最大化：$E[\sum_{t\geq1}u(P^t) ]$    所有轮下来总期望收益最大</p>
<p>约束：$\sum_{t\geq1}\sum_{p_i^l\in P^t}c_i^l\leq B$    花费不超过预算</p>
<p>​            $|P^t|=K \  for\ \forall t&gt;1$    每一轮都招K个workers，不多不少</p>
<p>​            $\sum_{l=1}^LI\{p_i^l\in P^t\}\leq 1$    每个worker的选项最多一个</p>
</li>
</ol>
<h2 id="Algorithm-Design"><a href="#Algorithm-Design" class="headerlink" title="Algorithm Design"></a>Algorithm Design</h2><ol>
<li><p>本文模型：K臂的组合多臂赌博机</p>
</li>
<li><p>本文方法：</p>
<ol>
<li>扩展的上置信界算法（UCB）学习任务质量</li>
<li>增加了对最大化权重的考虑</li>
<li>每轮用贪心算法招K个workers：最大化任务质量和招募费用的比（单位费用的任务质量最大化）</li>
</ol>
<h3 id="原本的UCB算法"><a href="#原本的UCB算法" class="headerlink" title="原本的UCB算法"></a>原本的UCB算法</h3><ol>
<li>总的来说就是估计置信区间</li>
<li>我们认为真实的那个未知概率或者说收益是p，而根据尝试和计算推断出的概率是$\widetilde{p}$，这两个概率之间存在差值，即：$\widetilde{p}-\Delta \leq p \leq \widetilde{p}+\Delta$，这个范围就是置信区间，算法的目的就是通过一次次尝试缩小置信区间</li>
<li>该算法的流程是在所有臂里找$\widetilde{p}+\Delta$最大的那个，根据一系列完全没看的数学定理，$\Delta=\sqrt{2\ln T /n}$，T是目前进行过的轮数，n是这个臂已经被选过的次数，每一轮执行完会更新数据。具体来说，$\widetilde{p}$最大，选这个选项的收益就越大，而$\Delta$越大，这个选项之前被选中的次数就越小。</li>
<li>总结一下就是会考虑每个臂已经估计过的历史记录，尽可能去探索次数较少和收益较高的臂，兼顾收益和探索。</li>
</ol>
<h3 id="本文的算法"><a href="#本文的算法" class="headerlink" title="本文的算法"></a>本文的算法</h3><ol>
<li>在第t轮中，若第i个worker的第l个选项被选中，则$n_i^l(t)=n_i^l(t-1)+1$（就是比上一轮的多1），反之则保持上一轮的值不变</li>
<li>$n_i(t)$的值是第t轮时的第i个worker每个选项的$n_i^l(t)$和该选项任务数（也就是$|M_i^l|$）相乘，然后所有的加起来，表示第i个worker的质量被学习过的次数</li>
<li>用普通的总值/总次数更新worker的质量（$\overline {q}_i(t)$），用不太一样的UCB平衡探索和收益（$\widehat{q}_i (t)$）</li>
<li>每一轮都是最大化权重*$\widehat{q}_i (t)$，也就是根据之前结果的信息推断出的最大收益</li>
</ol>
<h3 id="本文的流程"><a href="#本文的流程" class="headerlink" title="本文的流程"></a>本文的流程</h3><ol>
<li>最一开始，对于每个worker平台都让他去完成候选列表中的第一个任务（就是最便宜的那个）,由此初始化$n_i^l(t)$、$n_i(t)$、$\overline{q}_i(t)$。</li>
<li>接下来的每一轮中，都以最大化单位费用的收益增长为目的来选择K个worker和它们的任务，也就是说([选择这个任务选项的收益]-[选之前的收益])/[选这个任务的开销]，要找使得这个式子最大的那个任务选项。要注意这一步中，当某个worker已经被选了任务，那他的其他选项都不会再被考虑</li>
<li>第t轮的K个worker选好以后，开始各自完成任务，做完以后平台计算任务质量，由此更新$n_i^l(t)$、$n_i(t)$、$\overline{q}_i(t)$、$\widehat{q}_i (t)$。同时，目前为止的所有轮获得的收益也更新了，平台根据预算还剩多少决定是否进行下一轮。</li>
</ol>
<h3 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h3><ol>
<li>实质是01背包问题</li>
<li>经过一系列我还没看的计算，该算法复杂度是$O(NLK^3\ln \tau(B))$</li>
</ol>
</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol>
<li><p>扩展问题场景：所有worker的质量和收费都未知，收费未知是指$c_i^l=\varepsilon_i f(|M_i^l|)$这个公式里的参数$\varepsilon_i$未知，公式里的函数$f()$是公开的。具体来说，在第t轮，worker的任务已经选定后，worker根据当前电量、环境、网络等估计一个第t轮的收费参数$\varepsilon_i^t$，该值在0和1之间，且有下限$\varepsilon_{min}$，所有轮的$\varepsilon_i^t$独立同分布，分布未知，期望是$\varepsilon_i$。</p>
</li>
<li><p>每一轮开始时，首先是平台选worker和任务，然后是worker报价，接着平台算一下预算够不够，不够的话就结束，反之就进入做任务的环节，之后的流程和上一部分一样。</p>
</li>
<li><p>问题在于：$\varepsilon_i$也需要学习，而且每一轮会被学习一次，这和之前的任务质量不太一样。</p>
<h3 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h3><ol>
<li>新增一个符号表示：$m_i(t)=\sum_{l=1}^Ln_i^l(t)$，表示$\varepsilon_i$目前被学习过的次数（第i个worker的所有选项目前被选过的次数）</li>
<li>新增另一个符号表示：$\overline \varepsilon_i (t) $，计算方法和前面p那个类似，也是[在此之前的值*在此之前的次数+这次的值]/[在此之前的次数+1]</li>
<li>同样也新增了$\widehat  \varepsilon_i (t)$，和前面的一样</li>
<li>把之前那个目标函数里的费用部分用这里新的符号改写然后化简，但是这里化简以后的没看懂（问了一下作者，是从regret部分分析出来的，然后又看了看之前没看的证明，发现是证明部分分析的）</li>
<li>于是整个流程就和之前的一模一样，只是目标函数换了</li>
<li>算法性能分析和前面一样，还没看，感觉不重要</li>
</ol>
</li>
</ol>
<h2 id="Performance-Evaluation"><a href="#Performance-Evaluation" class="headerlink" title="Performance Evaluation"></a>Performance Evaluation</h2><ol>
<li>实验部分对平台的介绍格外简单，用的公开数据集，这部分没什么能说的</li>
<li>实验主要关注：期望质量和期望费用（就是前面计算的俩参数）</li>
<li>实验内容是和另一种常用的CMAB的算法做对比</li>
<li>针对第一个算法：分析了预算的影响（500-1000），招募工人数K的变化（得出K小一些更好，但是意味着要来更多轮），用均匀分布作为例子对比了准确率</li>
<li>针对第二个算法：估计了质量和预算的关系，改变工人数之后的性能（和上一个不太一样了）</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ol>
<li>没啥总结的，这个论文就这样了</li>
<li>之后有时间就看看性能证明那里，不过个人觉得十有八九是已有证明改编的</li>
<li>看了一点证明，还没完全看懂，大致了解思路了，不过不打算继续看了…..</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>Combinatorial Multi Armed Bandit</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程期末作业</title>
    <url>/2020/06/13/python%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<p>实际上在这之前还有两课讲<code>scikit</code>库，不过没作业，就不整理内容了。</p>
<a id="more"></a>
<h1 align = "center">北京师范大学2019～2020学年第二学期期末大作业</h1>
<h1 align = "center">（研究生）</h1>

<p><strong>课程名称：</strong><u>Python编程之美</u>   &nbsp;&emsp;&emsp;&emsp; <strong>任课教师姓名：</strong><u>邓擎琼</u></p>
<p><strong>总分</strong>：<u>40</u>   </p>
<p><strong>院 系：</strong><u>人工智能学院</u> &nbsp;&emsp;&emsp;&emsp; <strong>年级：</strong><u>2019级</u></p>
<p><strong>姓 名：</strong><u>李琨</u>   &nbsp;&emsp;&emsp;&emsp; <strong>学 号：</strong><u>201931210003</u></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题号</th>
<th style="text-align:center">第一题</th>
<th style="text-align:center">第二题</th>
<th style="text-align:center">第三题</th>
<th style="text-align:center">第四题</th>
<th style="text-align:center">第五题</th>
<th style="text-align:right">总分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">得分</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p><strong>阅卷教师（签字）：</strong><u> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;</u></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><ol>
<li>读入北京历史天气数据（北京天气.xlsx）；  <font color='red'>分值：3</font><br>或者：从<a href="http://www.tianqihoubao.com/lishi/beijing.html" target="_blank" rel="noopener">http://www.tianqihoubao.com/lishi/beijing.html</a><br>网站上通过爬虫把北京2011年-至今的天气数据爬下来，并保存为Excel文件；  <font color='red'>分值：10</font></li>
<li>读入北京空气质量数据（北京空气质量.xlsx），并把该数据和第1步中得到的北京天气数据进行融合，得到一个同时包含天气和空气质量的表格数据，保存为Excel文件；   <font color='red'>分值：5</font></li>
<li>对2011-2019年的每一年，统计这一年中白天为晴、雨、多云、阴、雪、雾霾、扬沙的天数，并绘制成饼图；    <font color='red'>分值：4</font></li>
<li>对2014-2019年的每一年，统计这一年中持续1天污染的次数、持续2天污染的次数、持续3天污染的次数、持续4天污染的次数和持续5天及以上有污染的次数，把所有年份的统计结果绘制成一幅柱状图；    <font color='red'>分值：6</font></li>
<li>在北京历史天气和空气质量数据的基础上，根据当天的天气情况以及前两天的天气及空气质量情况，预测当天的空气质量等级，要求至少比较两种算法，从中选出较优的算法并确定最优超参数（如果算法有超参数的话） 。  <font color='red'>分值：15</font></li>
</ol>
<h2 id="承诺："><a href="#承诺：" class="headerlink" title="承诺："></a>承诺：</h2><p>本人承诺本程序是自己编写的，没有抄袭。</p>
<h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><p>首先列出所有用到的库，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures, StandardScaler</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OrdinalEncoder, OneHotEncoder, LabelEncoder</span><br></pre></td></tr></table></figure>
<ol>
<li>考虑到题目中有画图的要求，而内容有中文，因此先将<code>plt</code>的字体改为中文字体。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><ol>
<li><p>首先分析天气数据的<a href="http://www.tianqihoubao.com/lishi/beijing.html" target="_blank" rel="noopener">网页链接</a>，该页面并不直接包含天气数据，而是包含了指向每个月天气数据的链接，因此需要先从该页面把所有月份的链接提取出来。经过分析可知，该页面所有链接都在<code>class_=&quot;box pcity&quot;</code>的<code>div</code>块中，是<code>a</code>标签，因此可以通过以下函数来获取所有链接，该函数将所有链接存放在一个列表中并返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_href</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：获取所有天气链接</span></span><br><span class="line"><span class="string">    参数：无</span></span><br><span class="line"><span class="string">    返回值：href_list 所有天气链接的列表</span></span><br><span class="line"><span class="string">    使用方式：list = get_href()</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 设置网页链接和head等信息</span></span><br><span class="line">    url = <span class="string">'http://www.tianqihoubao.com/lishi/beijing.html'</span></span><br><span class="line">    head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">    <span class="comment"># 获取网页文件并分析</span></span><br><span class="line">    html = requests.get(url, headers=head)</span><br><span class="line">    bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">    <span class="comment"># 找到所有天气链接所在区块</span></span><br><span class="line">    allLinks = bsObj.find_all(<span class="string">'div'</span>, class_=<span class="string">"box pcity"</span>)</span><br><span class="line">    href_list = []</span><br><span class="line">    <span class="comment"># 提取所有链接并存入列表返回</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> allLinks[:<span class="number">10</span>]:</span><br><span class="line">        aLink = i.find_all(<span class="string">'a'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> aLink:</span><br><span class="line">            href = urljoin(url, j[<span class="string">'href'</span>])</span><br><span class="line">            href_list.append(href)</span><br><span class="line">    <span class="keyword">return</span> href_list</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到所有链接的列表后，遍历该列表即可访问每个月的天气数据网页，分析这些网页可以发现，天气数据存放在<code>table</code>中，每一行的标签为<code>tr</code>，每一项的标签为<code>td</code>，而一行有四项，分别是日期、天气、温度、风力风向，其中第一行是表格头，因此可以从表格的第二行（第二个<code>tr</code>）开始遍历，获取所有<code>td</code>的内容（是一个长度为4的列表），将内容逐一处理再存放在列表中。遍历完成后即可得到所有天气数据，我将这些数据存放在列表中并返回，函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis_href</span><span class="params">(href_list)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：分析处理天气链接里的数据</span></span><br><span class="line"><span class="string">    参数：href_list 天气链接列表</span></span><br><span class="line"><span class="string">    返回值：lists 所有处理后的天气数据，格式为[日期、天气、温度、风力风向]</span></span><br><span class="line"><span class="string">    使用方式：lists = analysis_href(href_list)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 设置head</span></span><br><span class="line">    head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">    lists = []</span><br><span class="line">    <span class="comment"># 遍历所有链接</span></span><br><span class="line">    <span class="keyword">for</span> href <span class="keyword">in</span> href_list:</span><br><span class="line">        <span class="comment"># 获取网页文件并分析</span></span><br><span class="line">        html = requests.get(href, headers=head)</span><br><span class="line">        bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">        <span class="comment"># 找到天气数据所在的表格</span></span><br><span class="line">        table = bsObj.find(<span class="string">"table"</span>).find_all(<span class="string">"tr"</span>)</span><br><span class="line">        <span class="comment"># 从表格第二行开始提取数据（第一行是表格的head）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> table[<span class="number">1</span>:]:</span><br><span class="line">            content = i.find_all(<span class="string">"td"</span>)</span><br><span class="line">            <span class="comment"># 提取日期并去除多余的空格和换行符等</span></span><br><span class="line">            date = content[<span class="number">0</span>].text.replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 提取天气并去除多余的空格和换行符等</span></span><br><span class="line">            weather = content[<span class="number">1</span>].text.replace(<span class="string">" "</span>, <span class="string">""</span>).replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 提取温度并去除多余的空格和换行符等</span></span><br><span class="line">            temperature = content[<span class="number">2</span>].text.strip().replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 提取风力风向并去除多余的空格和换行符等</span></span><br><span class="line">            wind = content[<span class="number">3</span>].text.strip().replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 将提取的数据存入列表</span></span><br><span class="line">            lists.append([date, weather, temperature, wind])</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
</li>
<li><p>在得到天气数据的列表后，需要将该列表数据写入excel文件，我先将列表转为<code>numpy</code>数组，再将该数组转为<code>DataFrame</code>，并把索引设置为<code>日期</code>列，这时就可以用<code>pandas</code>的库函数将所有内容写入<code>excel</code>文件了，函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_excel</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：将数据写入excel文件</span></span><br><span class="line"><span class="string">    参数：filename 文件名</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：write_excel("weather.xlsx")</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 调用分析网页的函数获取所有天气数据所在列表</span></span><br><span class="line">    a = np.array(analysis_href(get_href()))</span><br><span class="line">    <span class="comment"># 将天气数据列表转为DateFrame</span></span><br><span class="line">    DF = pd.DataFrame(a, columns=[<span class="string">'日期'</span>, <span class="string">'天气'</span>, <span class="string">'温度'</span>, <span class="string">'风力风向'</span>])</span><br><span class="line">    <span class="comment"># 将索引设置为日期列，去除原本的索引序号</span></span><br><span class="line">    DF.set_index(<span class="string">'日期'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 将数据写入excel文件</span></span><br><span class="line">    DF.to_excel(filename)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主函数中通过调用<code>write_excel()</code>即可得到天气数据文件，完成第一题。</p>
</li>
</ol>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><ol>
<li><p>首先读取天气数据和空气质量数据，并将<code>日期</code>列设置为<code>datetime</code>格式的索引，以便后续分析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">df_weather = pd.read_excel(<span class="string">'weather.xlsx'</span>, <span class="string">'Sheet1'</span>, header=<span class="number">0</span>)</span><br><span class="line">df_air = pd.read_excel(<span class="string">'北京空气质量.xlsx'</span>, <span class="string">'Sheet1'</span>, header=<span class="number">0</span>)</span><br><span class="line">df_weather[<span class="string">'日期'</span>] = pd.to_datetime(df_weather[<span class="string">'日期'</span>], format=<span class="string">"%Y年%m月%d日"</span>)</span><br><span class="line">df_weather.set_index(<span class="string">'日期'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df_air[<span class="string">'日期'</span>] = pd.to_datetime(df_air[<span class="string">'日期'</span>], format=<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">df_air.set_index(<span class="string">'日期'</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来通过<code>pandas</code>的库函数即可将两个<code>DataFrame</code>按日期融合起来，因为两个表格中的日期并没有完全一致，所以去除了不一致的日期。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_merge = pd.merge(df_weather, df_air, on=<span class="string">'日期'</span>)</span><br><span class="line">df_merge.index = df_merge.index.date</span><br></pre></td></tr></table></figure>
</li>
<li><p>将该<code>DataFrame</code>写入<code>excel</code>文件，完成第二题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_merge.to_excel(<span class="string">'merge.xlsx'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><ol>
<li><p>分析天气数据，可以看出白天天气和夜晚天气通过<code>/</code>分隔，因此首先通过<code>split()</code>函数得到白天天气。</p>
</li>
<li><p>由于数据源本身的问题，有个别天气是无效的（是<code>-</code>符号），因此要删去这些数据。</p>
</li>
<li><p>得到白天天气后，还需要将该天气转换为题目中提到的几个类别中的一个，例如“小雨”要转换为“雨”。值得注意的是，”雨夹雪“天气我算作雨天而不是雪天。</p>
</li>
<li><p>上述处理天气数据的函数如下，该函数返回处理好的天气数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_weather_data</span><span class="params">(df_weather)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：处理天气数据以便后续绘图</span></span><br><span class="line"><span class="string">    参数：df_weather 初始天气数据</span></span><br><span class="line"><span class="string">    返回值：df_weather 处理好的天气数据</span></span><br><span class="line"><span class="string">    使用方式：df_weather = process_weather_data(df_weather)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 分离出白天天气</span></span><br><span class="line">    df_weather[<span class="string">'白天天气'</span>] = df_weather[<span class="string">'天气'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 删去无效数据</span></span><br><span class="line">    df_weather = df_weather.drop(df_weather[df_weather[<span class="string">'白天天气'</span>] == <span class="string">'-'</span>].index)</span><br><span class="line">    <span class="comment"># 统一雨天数据</span></span><br><span class="line">    df_weather.loc[(df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'大雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'暴雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'阵雨'</span>) | ( df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小到中雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中到大雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'雷阵雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'雨夹雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雨'</span></span><br><span class="line">    <span class="comment"># 统一雪天数据</span></span><br><span class="line">    df_weather.loc[(df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小雪'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中雪'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'大雪'</span>) | ( df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小到中雪'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中到大雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雪'</span></span><br><span class="line">    <span class="comment"># 统一扬沙天气</span></span><br><span class="line">    df_weather.loc[df_weather[<span class="string">'白天天气'</span>] == <span class="string">'浮尘'</span>, <span class="string">'白天天气'</span>] = <span class="string">'扬沙'</span></span><br><span class="line">    <span class="comment"># 统一雾霾天气</span></span><br><span class="line">    df_weather.loc[(df_weather[<span class="string">'白天天气'</span>] == <span class="string">'雾'</span>) | ( df_weather[<span class="string">'白天天气'</span>] == <span class="string">'霾'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雾霾'</span></span><br><span class="line">    <span class="keyword">return</span> df_weather</span><br></pre></td></tr></table></figure>
</li>
<li><p>对处理好的数据按年分组，再遍历分组结果，可以得到每一年的数据，由于题目要求2011年至2019年，因此当遍历到2020年时终止循环。</p>
</li>
<li><p>对每一年的数据按白天天气这一列分组，统计分组的<code>size</code>，即可得到每种天气的天数，在此基础上可以绘制图像。上述分组并统计绘图的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weather_pie</span><span class="params">(df_weather)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：根据处理好的天气数据画饼状图</span></span><br><span class="line"><span class="string">    参数：df_weather 处理好的天气数据</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：weather_pie(df_weather)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 按年份分组</span></span><br><span class="line">    weather_group_y = df_weather.groupby(df_weather.index.year)</span><br><span class="line">    <span class="comment"># 对每年进行循环</span></span><br><span class="line">    <span class="keyword">for</span> n, g <span class="keyword">in</span> weather_group_y:</span><br><span class="line">        <span class="comment"># 不需要2020的数据</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2020</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 按白天天气分组</span></span><br><span class="line">        weather_group = g.groupby(g[<span class="string">'白天天气'</span>]).size()</span><br><span class="line">        <span class="comment"># 输出分组结果</span></span><br><span class="line">        print(str(n)+<span class="string">'年天气天数统计如下：'</span>)</span><br><span class="line">        print(weather_group)</span><br><span class="line">        <span class="comment"># 画饼图并保存</span></span><br><span class="line">        weather_group.name = <span class="string">''</span></span><br><span class="line">        weather_group.plot.pie(startangle=<span class="number">90</span>)</span><br><span class="line">        plt.title(<span class="string">''</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">        plt.savefig(<span class="string">'weather-pie-of-'</span>+str(n), dpi=<span class="number">300</span>)</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主函数中调用<code>weather_pie()</code>，参数为第二题中读取的天气数据，完成第三题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weather_pie(process_weather_data(df_weather))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><ol>
<li><p>针对每一年的数据，首先根据空气质量等级区分开有污染和无污染，为了方便，我新增一列存储污染情况，将所有无污染的数据设置为0，有污染的设置为1。</p>
</li>
<li><p>同样是数据源的问题，个别数据的空气质量等级是无，属于无效数据，因此我删去这些数据。</p>
</li>
<li><p>接下来统计持续污染天数，这里参考了<a href="https://www.zhihu.com/question/41265794" target="_blank" rel="noopener">知乎</a>。具体方法是首先找到污染情况不同的坐标，该坐标就是持续同一污染状态的终点，而上一次持续的终点也是下一次持续的起点，因此可以得到一个存储了持续污染情况天数的表格，再从该表格中取出污染情况为1的部分，并进行分组统计，即可得到这一年持续<code>n</code>天污染的统计结果。需要注意的是，因为题目要求最高统计5天及以上，这里要把持续天数超过5天的也改为5。</p>
</li>
<li><p>由于这一题并不是每一年画一个图，而是所有数据一起画图，因此这里最后要把得到的统计结果转置，存储为行名是年份、列名是污染持续天数的新<code>DataFrame</code>，并返回。上述处理过程的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_air_data</span><span class="params">(df, year)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：处理空气污染数据</span></span><br><span class="line"><span class="string">    参数：df 初始空气污染数据</span></span><br><span class="line"><span class="string">    返回值：df3 处理好的空气污染数据</span></span><br><span class="line"><span class="string">    使用方式：df_air = process_air_data(df_air)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 统一污染</span></span><br><span class="line">    df.loc[(df[<span class="string">'质量等级'</span>] == <span class="string">'轻度污染'</span>) | (df[<span class="string">'质量等级'</span>] == <span class="string">'中度污染'</span>) | (</span><br><span class="line">        df[<span class="string">'质量等级'</span>] == <span class="string">'重度污染'</span>) | (df[<span class="string">'质量等级'</span>] == <span class="string">'严重污染'</span>), <span class="string">'污染'</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 统一无污染</span></span><br><span class="line">    df.loc[(df[<span class="string">'质量等级'</span>] == <span class="string">'优'</span>) | (df[<span class="string">'质量等级'</span>] == <span class="string">'良'</span>), <span class="string">'污染'</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 删去无效数据</span></span><br><span class="line">    df = df.drop(df[df[<span class="string">'质量等级'</span>] == <span class="string">'无'</span>].index)</span><br><span class="line">    <span class="comment"># 找污染数字相同的位置</span></span><br><span class="line">    pos, = np.where(np.diff(df[<span class="string">'污染'</span>]))</span><br><span class="line">    <span class="comment"># 定位连续污染和连续无污染的起止点</span></span><br><span class="line">    start, end = np.insert(pos+<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), np.append(pos, len(df)<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 计算污染状态的持续天数</span></span><br><span class="line">    df2 = pd.DataFrame(&#123;<span class="string">'污染'</span>: df[<span class="string">'污染'</span>][start], <span class="string">'持续天数'</span>: end-start+<span class="number">1</span>&#125;)</span><br><span class="line">    <span class="comment"># 从连续天数的表格中提取是污染的</span></span><br><span class="line">    df3 = df2.loc[df2[<span class="string">'污染'</span>] == <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 连续天数大于5的统一变成5，方便下一步分组统计画图</span></span><br><span class="line">    df3.loc[df3[<span class="string">'持续天数'</span>] &gt; <span class="number">5</span>, <span class="string">'持续天数'</span>] = <span class="number">5</span></span><br><span class="line">    <span class="comment"># 按持续天数分组计数，并将计数结果存为DateFrame</span></span><br><span class="line">    df3 = df3.groupby(df3[<span class="string">'持续天数'</span>]).size().reset_index(name=str(year))</span><br><span class="line">    <span class="comment"># 重置index</span></span><br><span class="line">    df3.set_index(<span class="string">'持续天数'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 转置行列，方便后续合并分组结果和画图</span></span><br><span class="line">    df3 = pd.DataFrame(df3.values.T, index=df3.columns, columns=[<span class="string">'1天'</span>, <span class="string">'2天'</span>, <span class="string">'3天'</span>, <span class="string">'4天'</span>, <span class="string">'5天及以上'</span>])</span><br><span class="line">    <span class="keyword">return</span> df3</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来是画图函数，该函数将合并了所有年份的数据绘制为条形图，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollution_bar</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：按处理好的空气污染数据画柱状图</span></span><br><span class="line"><span class="string">    参数：df 处理好的空气污染数据</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：pollution_bar(df_air)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    df.plot.bar()</span><br><span class="line">    plt.title(<span class="string">'2014年至2019年持续污染天数柱状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'天数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'出现次数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">    plt.savefig(<span class="string">'pollution-bar'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后要在主函数中将原始的空气污染数据按年分组，并对分组结果逐一调用<code>process_air_data()</code>，再将得到的持续污染天数的数据合并起来，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">air_group_y = df_air.groupby(df_air.index.year)</span><br><span class="line">df_air_processed = process_air_data(air_group_y.get_group(<span class="number">2014</span>), <span class="number">2014</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2015</span>, <span class="number">2020</span>):</span><br><span class="line">    df_air_processed = pd.concat([df_air_processed, process_air_data(air_group_y.get_group(i), i)])</span><br></pre></td></tr></table></figure>
</li>
<li><p>对处理好的数据调用<code>pollution_bar()</code>绘制条形图，参数是第二题中读取的空气污染数据，完成第四题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pollution_bar(df_air_processed)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><ol>
<li><p>分析题目要求，”<strong>根据当天的天气情况以及前两天的天气及空气质量情况，预测当天的空气质量等级</strong>“，而天气情况包括天气、温度和风力风向，因此需要进行以下处理。</p>
</li>
<li><p>首先将白天和晚上的天气、风力风向和最高最低温度分离出来，这三个数据都是以<code>/</code>为分隔，因此可以用<code>split()</code>来完成。这里要注意，温度数据的最后一位是摄氏度的标记，因此要去掉，只保留前面的数字。</p>
</li>
<li><p>接下来分离风力和风向，这里的规律并不明显，但总体而言可以用<code>风</code>字作为分隔符来提取，并在之后的处理中将相同含义但不同表示的字符串合并起来。</p>
</li>
<li><p>天气、风力和风向的数据都是字符串，而其它数据则是数字，由于<code>scikit</code>处理的数据都是数字，因此这里需要对字符串进行特征提取和编码，最初我尝试用<code>DictVectorizer</code>来做，但是这样出来的矩阵略大，而结果准确率也略低，因此决定在这里直接用字典和<code>mapping()</code>将字符串转数字。需要注意的是，在这里我把<code>西南偏南</code>和<code>西南</code>算作同一类，用相同的数字表示。另一方面，上一步中分离出的风力数据，如<code>向≤3级</code>、<code>&lt;3级</code>、<code>1-2级</code>等这些显然是同一个含义的也算作一类，用相同的数字表示。</p>
</li>
<li><p>由于天气种类很多，而其中有一些属于同一类，如果不合并相同类别的数据，会对之后的模型训练造成影响，因此按第三题的方法将所有天气统一，并转为数字表示。</p>
</li>
<li><p>质量等级也是字符串，因此采用同样的方法进行转换。转换结束后，原本的天气、风力风向等等数据就可以删除了。</p>
</li>
<li><p>由于预测还用到了前两天的天气和空气质量情况，因此要把前两天的数据逐一增加到当天数据中，作为新的一列保存，之后要删除无效数据。</p>
</li>
<li><p>由于预测时并没有用到当天的空气质量情况，因此要把当天的空气质量数据都删除，只保留空气质量等级这一列作为训练模型的<code>target</code>。</p>
</li>
<li><p>至此，所有数据已经转为数字类型，并剔除不需要的数据，接下来需要进行标准化，并返回标准化之后的数组，该数组第一列是<code>target</code>，剩下数据是训练用数据。上述数据处理过程为如下函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_predict_data</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：处理天气和空气数据，方便后续训练</span></span><br><span class="line"><span class="string">    参数：df 初始合并好的天气+空气数据</span></span><br><span class="line"><span class="string">    返回值：df 处理好的数据</span></span><br><span class="line"><span class="string">    使用方式：predict_array = process_predict_data(df)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 划分天气、风力、风向和温度</span></span><br><span class="line">    df[<span class="string">'白天天气'</span>] = df[<span class="string">'天气'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'夜晚天气'</span>] = df[<span class="string">'天气'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">1</span>])</span><br><span class="line">    df[<span class="string">'白天风力风向'</span>] = df[<span class="string">'风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'夜晚风力风向'</span>] = df[<span class="string">'风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">1</span>])</span><br><span class="line">    df[<span class="string">'最高温度'</span>] = df[<span class="string">'温度'</span>].map(<span class="keyword">lambda</span> x: int(x.split(<span class="string">'/'</span>)[<span class="number">0</span>][:<span class="number">-1</span>]))</span><br><span class="line">    df[<span class="string">'最低温度'</span>] = df[<span class="string">'温度'</span>].map(<span class="keyword">lambda</span> x: int(x.split(<span class="string">'/'</span>)[<span class="number">1</span>][:<span class="number">-1</span>]))</span><br><span class="line">    df[<span class="string">'白天风力'</span>] = df[<span class="string">'白天风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'白天风向'</span>] = df[<span class="string">'白天风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">1</span>])</span><br><span class="line">    df[<span class="string">'夜晚风力'</span>] = df[<span class="string">'夜晚风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'夜晚风向'</span>] = df[<span class="string">'夜晚风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 风向转数字</span></span><br><span class="line">    wind_map_1 = &#123;<span class="string">'无持续'</span>: <span class="number">0</span>, <span class="string">'东'</span>: <span class="number">1</span>, <span class="string">'南'</span>: <span class="number">2</span>, <span class="string">'西'</span>: <span class="number">3</span>, <span class="string">'北'</span>: <span class="number">4</span>, <span class="string">'东北'</span>: <span class="number">5</span>, <span class="string">'东南'</span>: <span class="number">6</span>, <span class="string">'西北'</span>: <span class="number">7</span>, <span class="string">'西南'</span>: <span class="number">8</span>, <span class="string">'西南偏南'</span>: <span class="number">8</span>&#125;</span><br><span class="line">    df[<span class="string">'白天风力'</span>] = df[<span class="string">'白天风力'</span>].map(wind_map_1)</span><br><span class="line">    df[<span class="string">'夜晚风力'</span>] = df[<span class="string">'夜晚风力'</span>].map(wind_map_1)</span><br><span class="line">    <span class="comment"># 风力转数字</span></span><br><span class="line">    wind_map_2 = &#123;<span class="string">'向≤3级'</span>: <span class="number">0</span>, <span class="string">'&lt;3级'</span>: <span class="number">0</span>, <span class="string">'1-2级'</span>: <span class="number">0</span>, <span class="string">'≤3级'</span>: <span class="number">0</span>, <span class="string">'向&lt;3级'</span>: <span class="number">0</span>, <span class="string">'向3-4级'</span>: <span class="number">1</span>, <span class="string">'3-4级'</span>: <span class="number">1</span>, <span class="string">'3～4级'</span>: <span class="number">1</span>, <span class="string">'3～4级'</span>: <span class="number">1</span>, <span class="string">'4'</span>: <span class="number">1</span>, <span class="string">'4-5级'</span>: <span class="number">1</span>, <span class="string">'4～5级'</span>: <span class="number">1</span>, <span class="string">'5～6级'</span>: <span class="number">2</span>, <span class="string">'5-6级'</span>: <span class="number">2</span>, <span class="string">'6-7级'</span>: <span class="number">2</span>&#125;</span><br><span class="line">    df[<span class="string">'白天风向'</span>] = df[<span class="string">'白天风向'</span>].map(wind_map_2)</span><br><span class="line">    df[<span class="string">'夜晚风向'</span>] = df[<span class="string">'夜晚风向'</span>].map(wind_map_2)</span><br><span class="line">    <span class="comment"># 删去不需要的列</span></span><br><span class="line">    df = df.drop(<span class="string">'天气'</span>, axis=<span class="number">1</span>).drop(<span class="string">'温度'</span>, axis=<span class="number">1</span>).drop(<span class="string">'风力风向'</span>, axis=<span class="number">1</span>).drop(<span class="string">'白天风力风向'</span>, axis=<span class="number">1</span>).drop(<span class="string">'夜晚风力风向'</span>, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 删去无效数据</span></span><br><span class="line">    df = df.drop(df[df[<span class="string">'质量等级'</span>] == <span class="string">'无'</span>].index)</span><br><span class="line">    <span class="comment"># 统一雨天数据</span></span><br><span class="line">    df.loc[(df[<span class="string">'白天天气'</span>] == <span class="string">'小雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'大雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'暴雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'阵雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'小到中雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中到大雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'雷阵雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'雨夹雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雨'</span></span><br><span class="line">    df.loc[(df[<span class="string">'夜晚天气'</span>] == <span class="string">'小雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'大雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'暴雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'阵雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'小到中雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中到大雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'大到暴雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'雷阵雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'雨夹雪'</span>), <span class="string">'夜晚天气'</span>] = <span class="string">'雨'</span></span><br><span class="line">    <span class="comment"># 统一雪天数据</span></span><br><span class="line">    df.loc[(df[<span class="string">'白天天气'</span>] == <span class="string">'小雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'大雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'小到中雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中到大雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雪'</span></span><br><span class="line">    df.loc[(df[<span class="string">'夜晚天气'</span>] == <span class="string">'小雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'大雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'小到中雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中到大雪'</span>), <span class="string">'夜晚天气'</span>] = <span class="string">'雪'</span></span><br><span class="line">    <span class="comment"># 统一扬沙天气</span></span><br><span class="line">    df.loc[df[<span class="string">'白天天气'</span>] == <span class="string">'浮尘'</span>, <span class="string">'白天天气'</span>] = <span class="string">'扬沙'</span></span><br><span class="line">    df.loc[df[<span class="string">'夜晚天气'</span>] == <span class="string">'浮尘'</span>, <span class="string">'夜晚天气'</span>] = <span class="string">'扬沙'</span></span><br><span class="line">    <span class="comment"># 统一雾霾天气</span></span><br><span class="line">    df.loc[(df[<span class="string">'白天天气'</span>] == <span class="string">'雾'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'霾'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雾霾'</span></span><br><span class="line">    df.loc[(df[<span class="string">'夜晚天气'</span>] == <span class="string">'雾'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'霾'</span>), <span class="string">'夜晚天气'</span>] = <span class="string">'雾霾'</span></span><br><span class="line">    <span class="comment"># 质量等级转数字</span></span><br><span class="line">    quality_mapping = &#123;<span class="string">'优'</span>: <span class="number">0</span>, <span class="string">'良'</span>: <span class="number">1</span>, <span class="string">'轻度污染'</span>: <span class="number">2</span>, <span class="string">'中度污染'</span>: <span class="number">3</span>, <span class="string">'重度污染'</span>: <span class="number">4</span>, <span class="string">'严重污染'</span>: <span class="number">5</span>&#125;</span><br><span class="line">    df[<span class="string">'质量等级'</span>] = df[<span class="string">'质量等级'</span>].map(quality_mapping)</span><br><span class="line">    <span class="comment"># 天气转数字</span></span><br><span class="line">    weather_mapping = &#123;<span class="string">'晴'</span>: <span class="number">0</span>, <span class="string">'雨'</span>: <span class="number">1</span>, <span class="string">'阴'</span>: <span class="number">2</span>, <span class="string">'雪'</span>: <span class="number">3</span>, <span class="string">'多云'</span>: <span class="number">4</span>, <span class="string">'雾霾'</span>: <span class="number">5</span>, <span class="string">'扬沙'</span>: <span class="number">6</span>&#125;</span><br><span class="line">    df[<span class="string">'白天天气'</span>] = df[<span class="string">'白天天气'</span>].map(weather_mapping)</span><br><span class="line">    df[<span class="string">'夜晚天气'</span>] = df[<span class="string">'夜晚天气'</span>].map(weather_mapping)</span><br><span class="line">    <span class="comment"># 增加昨天和前天的数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(df)<span class="number">-2</span>):</span><br><span class="line">        df.ix[i+<span class="number">2</span>, <span class="string">'昨天AQI'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天质量等级'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天PM2.5'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天PM10'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天SO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天CO'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天NO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天O3_8h'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天白天天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天夜晚天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天白天风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天夜晚风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天白天风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天夜晚风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天最高温度'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天最低温度'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天AQI'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天质量等级'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天PM2.5'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天PM10'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天SO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天CO'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天NO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天O3_8h'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天白天天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天夜晚天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天白天风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天夜晚风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天白天风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天夜晚风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天最高温度'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天最低温度'</span>] = df.ix[i+<span class="number">1</span>, <span class="string">'AQI'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'质量等级'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'PM2.5'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'PM10'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'SO2'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'CO'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'NO2'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'O3_8h'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'白天天气'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'夜晚天气'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'白天风力'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'夜晚风力'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'白天风向'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'夜晚风向'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'最高温度'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'最低温度'</span>], df.ix[i, <span class="string">'AQI'</span>], df.ix[i, <span class="string">'质量等级'</span>], df.ix[i, <span class="string">'PM2.5'</span>], df.ix[i, <span class="string">'PM10'</span>], df.ix[i, <span class="string">'SO2'</span>], df.ix[i, <span class="string">'CO'</span>], df.ix[i, <span class="string">'NO2'</span>], df.ix[i, <span class="string">'O3_8h'</span>], df.ix[i, <span class="string">'白天天气'</span>], df.ix[i, <span class="string">'夜晚天气'</span>], df.ix[i, <span class="string">'白天风力'</span>], df.ix[i, <span class="string">'夜晚风力'</span>], df.ix[i, <span class="string">'白天风向'</span>], df.ix[i, <span class="string">'夜晚风向'</span>], df.ix[i, <span class="string">'最高温度'</span>], df.ix[i, <span class="string">'最低温度'</span>]</span><br><span class="line">    <span class="comment"># 删除无效数据</span></span><br><span class="line">    df = df.dropna(how=<span class="string">'any'</span>)</span><br><span class="line">    <span class="comment"># 删除今天空气数据</span></span><br><span class="line">    df = df.drop(<span class="string">'AQI'</span>, axis=<span class="number">1</span>).drop(<span class="string">'PM2.5'</span>, axis=<span class="number">1</span>).drop(<span class="string">'PM10'</span>, axis=<span class="number">1</span>).drop(</span><br><span class="line">        <span class="string">'SO2'</span>, axis=<span class="number">1</span>).drop(<span class="string">'CO'</span>, axis=<span class="number">1</span>).drop(<span class="string">'NO2'</span>, axis=<span class="number">1</span>).drop(<span class="string">'O3_8h'</span>, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 数据标准化</span></span><br><span class="line">    ss = StandardScaler()</span><br><span class="line">    predict_array = ss.fit_transform(df)</span><br><span class="line">    <span class="keyword">return</span> predict_array</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理好数据后，就可以开始训练模型。首先用<code>train_test_split()</code>划分训练集和测试集。</p>
</li>
<li><p>接下来建立一个算法列表，该列表包含了几个不同的分类器。</p>
</li>
<li><p>对每一个分类器，用K折交叉判断其在训练集的准确率并输出。</p>
</li>
<li><p>根据输出结果选择最优分类器，测试其在测试集上的性能并输出。</p>
</li>
<li><p>在这里经过对比，选择了LDA分类器。整体训练过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_air</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：训练和测试模型</span></span><br><span class="line"><span class="string">    参数：array 处理好的数据集</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：predict_air(array)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 划分训练集和测试集</span></span><br><span class="line">    x = array[:, <span class="number">1</span>:]</span><br><span class="line">    y = array[:, <span class="number">0</span>]</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(</span><br><span class="line">        x, y, test_size=<span class="number">0.7</span>, random_state=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 把备选算法放入列表</span></span><br><span class="line">    models = []</span><br><span class="line">    models.append((<span class="string">'LR'</span>, LogisticRegression(</span><br><span class="line">        solver=<span class="string">'liblinear'</span>, multi_class=<span class="string">'ovr'</span>)))</span><br><span class="line">    models.append((<span class="string">'LDA'</span>, LinearDiscriminantAnalysis()))</span><br><span class="line">    models.append((<span class="string">'KNN'</span>, KNeighborsClassifier()))</span><br><span class="line">    models.append((<span class="string">'CART'</span>, DecisionTreeClassifier()))</span><br><span class="line">    models.append((<span class="string">'NB'</span>, GaussianNB()))</span><br><span class="line">    models.append((<span class="string">'SVM'</span>, SVC(gamma=<span class="string">'auto'</span>)))</span><br><span class="line">    <span class="comment"># 用训练集训练每个模型并评价</span></span><br><span class="line">    results = []</span><br><span class="line">    names = []</span><br><span class="line">    <span class="keyword">for</span> name, model <span class="keyword">in</span> models:</span><br><span class="line">        kfold = StratifiedKFold(n_splits=<span class="number">10</span>, random_state=<span class="number">1</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">        cv_results = cross_val_score(model, x_train, y_train.astype(</span><br><span class="line">            <span class="string">'int'</span>), cv=kfold, scoring=<span class="string">'accuracy'</span>)</span><br><span class="line">        results.append(cv_results)</span><br><span class="line">        names.append(name)</span><br><span class="line">        print(<span class="string">'%s: %f (%f)'</span> % (name, cv_results.mean(), cv_results.std()))</span><br><span class="line">    <span class="comment"># 从上面的输出可知lda准确率最高，因此训练lad模型并输出测试集的准确率</span></span><br><span class="line">    lda = LinearDiscriminantAnalysis()</span><br><span class="line">    lda.fit(x_train, y_train.astype(<span class="string">'int'</span>))</span><br><span class="line">    print(lda.score(x_test, y_test.astype(<span class="string">'int'</span>)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主函数中先后调用<code>process_predict_data()</code>和<code>predict_air()</code>，在已知某天天气情况和前两天的天气及空气情况时，也可以调用该模型来预测当天空气质量。完成第五题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predict = process_predict_data(df_merge)</span><br><span class="line">predict_air(predict)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>好了我终于写完了，这个空气质量预测根本就靠不住，一开始只有准确率只有0.3，用很麻烦的方法处理数据之后才达到现在的0.7。啊写实验报告好累，我总算不用再上课了。希望分数能好点。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode的一系列配置</title>
    <url>/2020/06/06/vscode%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>前段时间忽然开始用vscode，今天配置好了C和C++，现在决定整理一下配置过程。</p>
<a id="more"></a>
<h2 id="安装和外观"><a href="#安装和外观" class="headerlink" title="安装和外观"></a>安装和外观</h2><ol>
<li><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode官网</a>下载和安装，这部分应该不会有问题，注意最后添加到path的选项要勾选，不然就要自己去配置环境变量；</p>
</li>
<li><p>中文设置：打开扩展（左边那一列按钮最下面的，默认快捷键是<code>ctrl+shift+x</code>，找一个叫Chinese (Simplified) Language Pack for Visual Studio Code的扩展，安装完成以后重启vscode，界面就变成中文了。如果没变，就按<code>ctrl+shift+p</code>，在出现的框里输入configure display language，然后下拉菜单里选zh-cn就可以了。</p>
</li>
<li><p>主题和图标：在扩展里找喜欢的就可以，据推荐vscode-icons比较好看，我也没研究其他图标。</p>
</li>
<li><p>背景：扩展里找background这个插件（名字就是这个单词），安装以后需要设置一下</p>
<ol>
<li><p><code>文件—&gt;首选项—&gt;设置—&gt;扩展—&gt;Plugin background config.background插件配置</code></p>
</li>
<li><p>打开这个界面以后，有一行字<code>在settings.json中编辑</code>，点一下可以打开settings.json（实际上在其他扩展里也能找到这行字，总之打开settings.json就行）</p>
</li>
<li><p>如果之前什么扩展也没装，也没搞别的配置，那这个文件打开以后应该是只有两行花括号(<code>{}</code>)的，如果之前装了别的，那花括号中间可能会有几行内容，接下来在花括号里面输入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;background.enabled&quot;: true,</span><br><span class="line">   &quot;background.useDefault&quot;: false,</span><br><span class="line">   &quot;background.customImages&quot;:[&quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;LiKun&#x2F;Pictures&#x2F;background.png&quot;],</span><br><span class="line">   &quot;background.style&quot;:&#123;</span><br><span class="line">       &quot;content&quot;:&quot;&#39;&#39;&quot;,</span><br><span class="line">       &quot;pointer-events&quot;:&quot;none&quot;,</span><br><span class="line">       &quot;position&quot;:&quot;absolute&quot;,&#x2F;&#x2F;图片位置</span><br><span class="line">       &quot;width&quot;:&quot;99%&quot;,</span><br><span class="line">       &quot;height&quot;:&quot;99%&quot;,</span><br><span class="line">       &quot;z-index&quot;:&quot;99999&quot;,</span><br><span class="line">       &quot;background.repeat&quot;:&quot;no-repeat&quot;,</span><br><span class="line">       &quot;background-size&quot;:&quot;25%,25%&quot;,&#x2F;&#x2F;图片大小</span><br><span class="line">       &quot;opacity&quot;:0.3 &#x2F;&#x2F;透明度</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
<p>注意：每一行最后的逗号不要忘了，背景图的路径改成自己的图，我这个设置是背景图出现在右下角的位置，如果有其他需求自己改就行。</p>
</li>
</ol>
</li>
</ol>
<h2 id="latex"><a href="#latex" class="headerlink" title="latex"></a>latex</h2><ol>
<li><p>安装texlive，因为我之前安装过texstudio所以就没再装了，这里要记得环境变量的问题，正常来说安装的时候会自动添加，如果没勾选那就要自己配置；</p>
</li>
<li><p>vscode的扩展里找latex workshop安装，据说安装好就能编译tex文件并生成pdf，不过我还搞了乱七八糟的设置才可以；</p>
</li>
<li><p>设置过程还是打开setting.json，直接输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;latex-workshop.latex.recipes&quot;: [</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;,</span><br><span class="line">       &quot;tools&quot;: [</span><br><span class="line">         &quot;xelatex&quot;,</span><br><span class="line">         &quot;bibtex&quot;,</span><br><span class="line">         &quot;xelatex&quot;,</span><br><span class="line">         &quot;xelatex&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;</span><br><span class="line">   ],</span><br><span class="line">   &quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;xelatex&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">         &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">         &quot;-file-line-error&quot;,</span><br><span class="line">         &quot;%DOC%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;latexmk&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">         &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">         &quot;-file-line-error&quot;,</span><br><span class="line">         &quot;%DOC%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;pdflatex&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">         &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">         &quot;-file-line-error&quot;,</span><br><span class="line">         &quot;%DOC%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;bibtex&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;bibtex&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;%DOCFILE%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;</span><br><span class="line">   ],</span><br><span class="line">   &quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;,</span><br><span class="line">   &quot;editor.wordWrap&quot;: &quot;on&quot;,</span><br><span class="line">   &quot;latex-workshop.synctex.afterBuild.enabled&quot;: true,</span><br><span class="line">   &quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;: &quot;double-click&quot;,</span><br><span class="line">   &quot;[latex]&quot;: &#123;</span><br><span class="line">     &quot;editor.defaultFormatter&quot;: &quot;nickfode.latex-formatter&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;latex-workshop.latex.autoClean.run&quot;: &quot;onBuilt&quot;,</span><br></pre></td></tr></table></figure>
<p>注意：这个文件最外层就一组花括号，不管有多少要设置的东西都在里面加；latex的内容里有一些是在那个设置里可以直接选的，而不是通过这种让人看不懂的代码来设置，例如<code>&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;: &quot;double-click&quot;</code>这一句的作用是在pdf里双击可以跳转到latex源文件对应的位置，本来默认的是ctrl点击，但是我习惯双击，可以在设置里搜synctex:keybinding然后修改，改了会自动在settings.json 里出现那句话；<code>&quot;editor.wordWrap&quot;: &quot;on&quot;</code>是和latex本身无关的设置，是让编辑器可以自动换行；其他各种设置可以自行百度。</p>
</li>
</ol>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ol>
<li>扩展里搜python，安装跳出来的第一个就行；</li>
<li>可能和我之前已经安装过python、pycharm等等东西有关，安装插件之后就能编译运行python了。</li>
</ol>
<h2 id="C和C"><a href="#C和C" class="headerlink" title="C和C++"></a>C和C++</h2><ol>
<li>安装mingw，如果之前装过就不必重装了，这里要自己添加环境变量，然后检查有没有装好；</li>
<li>vscode里安装C/C++扩展，可能装好要重启；</li>
<li>打开要写代码的那个文件夹，比如C++文件夹，里面新建一个cpp文件随便写几行；</li>
<li><code>Ctrl+Shift+P</code>输入C/C++，选择“Edit Configurations(UI)”进入配置，这里要选编译器：<code>C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/bin/g++.exe</code>，路径改成自己的，还要选IntelliSense 模式，要用gcc-x64；</li>
<li>上一步做好以后，可以看到C++文件夹里多出一个.vscode文件夹，里面有c_cpp_properties.json文件，文件内容是写好的，可以看看，不过不需要修改；</li>
<li>再按<code>Ctrl+Shift+P</code>输入tasks，选择“Tasks:Configure Default Build Task”，再选择“C/C++: g++.exe build active file”，然后.vscode文件夹里就会出现tasks.json，也是写好的，不需要改；</li>
<li>接下来点运行—&gt;启动调试，或者直接按F5，选择C++(GDB/LLDB)，会出现一个launch.json，或者左边那列扩展按钮上面的那个按钮里有个创建launch.json也可以；</li>
<li>上一步的launch.json里可以自己根据需求添加一些配置，或者去网上复制别人的配置，总之我这里是什么也没改就能直接运行；</li>
<li>然后再按F5，就可以运行文件了；</li>
<li>在第4步之后，就可以在vscode里找到终端然后gcc编译运行文件；</li>
<li>默认运行输出信息是在下面的终端，在launch.json里找到”externalConsole”然后把它的false改成true,就可以出现独立的命令行界面来显示信息了。</li>
</ol>
<h2 id="KanBan"><a href="#KanBan" class="headerlink" title="KanBan"></a>KanBan</h2><ol>
<li><p>是最近发现的很好用的一个项目管理方式；</p>
</li>
<li><p>在扩展里搜KanBan，出来的第一个就是它，然后安装；</p>
</li>
<li><p>在扩展说明那里能看到很多可以配置的，我的配置如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">"kanban": </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">&lt;!--配置四个列的名称，因为原本的名称不符合我的需求，所以这么改了--&gt;</span></span><br><span class="line">        "columns": &#123;</span><br><span class="line">          "done": "Others",</span><br><span class="line">          "inProgress": "In Progress",</span><br><span class="line">          "testing": "Done",</span><br><span class="line">          "todo": "TODOs"</span><br><span class="line">        &#125;,</span><br><span class="line">        "openOnStartup": true,   <span class="comment">&lt;!--每次打开vscode的时候，自动打开KanBan标签页--&gt;</span></span><br><span class="line">        "trackTime": true    <span class="comment">&lt;!--打开计时功能，如果在干活前后各点一下，就会记录干了多久--&gt;</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>在搞好以后发现，KanBan文件是存放在项目文件夹的<code>.vscode</code>中，名称是<code>vscode-kanban.json</code>，打开可以看到具体内容。打开不同文件夹时，KanBan文件都是新的，如果想保持同步，就得把最新的文件复制到其他文件夹里，这有点麻烦，所以对着说明文档分析了一下，猜测可以改扩展的源代码里的文件。</p>
</li>
<li><p>具体来说，是找到用户目录里的vscode文件夹中的KanBan文件夹，文件夹名字可能和版本号等有关，比如我的是<code>C:\Users\LiKun\.vscode\extensions\mkloubert.vscode-kanban-1.28.0\</code>，里面有一个<code>out</code>文件夹，打开会发现一些<code>js</code>文件，这些文件都可以按需求改，我需要改的是<code>workspace.js</code>。</p>
</li>
<li><p>打开<code>workspace.js</code>，在一开始定义常量的地方有一个<code>const BOARD_FILENAME</code>，把它的值改成我打算固定存KanBan的绝对路径，例如：<code>const BOARD_FILENAME = &#39;C:/code/.vscode/vscode-kanban.json&#39;;</code></p>
</li>
<li><p>改了之后如果直接保存并在vscode里运行，会提示路径不对，看报错信息是因为程序把上面那个路径和项目文件夹的路径直接拼起来了，显然有问题。回到<code>workspace.js</code>，往下没几行就能看到一个<code>get boardFile()</code>函数，函数内容就是把路径拼起来并作为新路径返回，那么在这里，把拼路径的去掉，直接返回<code>BOARD_FILENAME</code>就可以了，修改之后这个函数如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> boardFile() &#123;</span><br><span class="line">        <span class="keyword">return</span> vscode.Uri.file(Path.resolve(BOARD_FILENAME));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意这个文件夹里其他东西不能乱改。</p>
</li>
<li><p>到此为止就可以实现所有项目文件共享同一个KanBan了，不过每次更新了以后需要重新改js文件。</p>
</li>
<li><p>用了一段时间发现因为css文件里已经写好了每个模块的功能和交互，所以像我那样改每一块的名字用起来效果不太好，想了想还是改回去了，以后研究一下css文件再改。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编辑器配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-13</title>
    <url>/2020/05/26/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-13/</url>
    <content><![CDATA[<p>这一课讲scipy库。</p>
<p><code>from scipy import some_module</code></p>
<p><code>from scipy.some_module import some_function</code></p>
<a id="more"></a>
<h2 id="linalg模块的使用"><a href="#linalg模块的使用" class="headerlink" title="linalg模块的使用"></a>linalg模块的使用</h2><ol>
<li><p>基本线性代数操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="comment"># 计算矩阵的行列式</span></span><br><span class="line">linalg.det(arr)				</span><br><span class="line"><span class="comment"># output: -2.0</span></span><br><span class="line"><span class="comment"># 计算特征值和特征向量</span></span><br><span class="line">linalg.eig(arr)</span><br><span class="line"><span class="comment"># output: (array([-0.37228132+0.j,  5.37228132+0.j]), array([[-0.82456484, -0.41597356], [ 0.56576746, -0.90937671]]))</span></span><br><span class="line"><span class="comment"># 矩阵求逆</span></span><br><span class="line">linalg.inv(arr)</span><br><span class="line"><span class="comment"># output: array([[-2. ,  1. ], [ 1.5, -0.5]])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解线性方程组：$Ax=b$，其中A是方阵：<code>solve(A, b)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line">m = <span class="number">500</span></span><br><span class="line">A=np.random.rand(m,m)</span><br><span class="line">b=np.random.rand(m)</span><br><span class="line">x1=linalg.solve(A,b)</span><br><span class="line">x2=np.dot(linalg.inv(A),b)</span><br><span class="line">print(np.allclose(x1,x2))</span><br></pre></td></tr></table></figure>
</li>
<li><p>更一般的线性方程组：$Ax=b$，其中A不是方阵：<code>lstsq(A,q)</code>找最小二乘解</p>
<p>例如：给定四个点<code>(1,6) (2,5) (3,7) (4,10)</code>，找拟合直线<code>y=ax+b</code> 这样的问题可以转化为：矩阵<code>A=[[1,2],[2,1],[3,1],[4,1]]</code> ，<code>b=[6, 5, 7, 10]^T</code>，<code>x=[a,b]^T</code>，求解<code>Ax=b</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>]])</span><br><span class="line">y = np.array([<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>])</span><br><span class="line">c,resid,rank,sigma=linalg.lstsq(A,y)</span><br><span class="line">print(c, resid, rank, sigma)</span><br><span class="line"><span class="comment"># [1.4 3.5] 4.200000000000003 2 [5.77937881 0.77380911]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他功能：</p>
<ol>
<li>范数求解: <code>linalg.norm</code></li>
<li>广义逆求解: <code>linalg.pinv, linalg.pinv2</code></li>
<li>矩阵分解：<code>linalg.sva, linalg.lu, linalg.qr</code></li>
</ol>
</li>
</ol>
<h2 id="optimize模块的使用"><a href="#optimize模块的使用" class="headerlink" title="optimize模块的使用"></a>optimize模块的使用</h2><ol>
<li><p>求解带约束条件的函数最小值：<code>minimize(fun, x0[,args, method, jac, hess, bounds, constrains])</code></p>
<ol>
<li><p>fun是目标函数 </p>
</li>
<li><p>x0是初始解 </p>
</li>
<li><p>args：需要传递给fun, jac, hess函数的额外的参数 </p>
</li>
<li><p>method是所选方法：Newton-CG、CG、SLSQP、Nelder-Mead…… </p>
</li>
<li><p>jac: Jacobian矩阵，有些方法需要给出 </p>
</li>
<li><p>hess: Hessian矩阵，有些方法需要给出 </p>
</li>
<li><p>bounds是解的约束范围， L-BFGS-B,TNC,SLSQP,trust-constr支持 </p>
</li>
<li><p>constrains是约束条件，COBYLA, SLSQP, trust-constr支持</p>
<p>例如：$min x1+x2+x3$</p>
<p>$s.t. x_1x_2x_3&gt;25$</p>
<p>​      $x_1^2+x_2^2+x_3^2=40$</p>
<p>​     $1&lt;=x_1, x_2&lt;=5$     $x_3&gt;=4$</p>
<p>$x_0=(3,3,4)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">objective</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constr1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]*x[<span class="number">1</span>]*x[<span class="number">2</span>]<span class="number">-25</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constr2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(x**<span class="number">2</span>)<span class="number">-40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jac</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">bnds=((<span class="number">1</span>,<span class="number">5</span>),(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="literal">None</span>))</span><br><span class="line">cons1=&#123;<span class="string">'type'</span>:<span class="string">'ineq'</span>,<span class="string">'fun'</span>:constr1&#125;</span><br><span class="line">cons2=&#123;<span class="string">'type'</span>:<span class="string">'eq'</span>,<span class="string">'fun'</span>:constr2&#125;</span><br><span class="line">cons=[cons1, cons2]</span><br><span class="line">result=minimize(objective,[<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],method=<span class="string">'SLSQP'</span>,jac=jac,bounds=bnds,constraints=cons)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#     fun: 9.807034491627501</span></span><br><span class="line"><span class="comment">#     jac: array([1., 1., 1.])</span></span><br><span class="line"><span class="comment"># message: 'Optimization terminated successfully.'</span></span><br><span class="line"><span class="comment">#    nfev: 7</span></span><br><span class="line"><span class="comment">#     nit: 7</span></span><br><span class="line"><span class="comment">#    njev: 7</span></span><br><span class="line"><span class="comment">#  status: 0</span></span><br><span class="line"><span class="comment"># success: True</span></span><br><span class="line"><span class="comment">#       x: array([2.11859914, 2.11859914, 5.5698362 ])</span></span><br><span class="line"><span class="comment"># result.fun可输出最小值，result.x可输出对应的x解</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>minimize是局部最优，basinhopping、shgo等可以求解全局最优</p>
</li>
<li><p>求解非线性方程：<code>root(fun, x0[, args, method, jac])</code></p>
<ol>
<li><p>fun是要求根的方程（组） </p>
</li>
<li><p>x0是初始猜测解 </p>
</li>
<li><p>args是fun以及jac中额外的参数 </p>
</li>
<li><p>method是所选方法： hybr, lm, broyden1/2, anderson, linearmixing, krylov, df-sane 等 </p>
</li>
<li><p>jac: Jacobian矩阵</p>
<p>例如：求解 $f(x)=2x^2+3x-10$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x**<span class="number">2</span>+<span class="number">3</span>*x<span class="number">-10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jac</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*x+<span class="number">3</span></span><br><span class="line"></span><br><span class="line">x=np.linspace(<span class="number">-5</span>,<span class="number">3</span>)</span><br><span class="line">plt.plot(x,func(x))</span><br><span class="line">plt.plot(x,np.zeros(len(x)))</span><br><span class="line"></span><br><span class="line">result1=root(func,<span class="number">-3</span>,method=<span class="string">'hybr'</span>,jac=jac)</span><br><span class="line">result2=root(func,<span class="number">1</span>,method=<span class="string">'lm'</span>,jac=jac)</span><br><span class="line"></span><br><span class="line">print(result1.fun,result2.fun)</span><br><span class="line">print(result1.x, result2.x)</span><br><span class="line"><span class="comment"># [-1.77635684e-15] [0.]</span></span><br><span class="line"><span class="comment"># [-3.10849528] [1.60849528]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>求解非线性方程组：和前面一样，把给定的目标函数和雅可比矩阵写成函数然后运算。</p>
</li>
</ol>
<h2 id="integrate模块的使用"><a href="#integrate模块的使用" class="headerlink" title="integrate模块的使用"></a>integrate模块的使用</h2><ol>
<li><p>根据函数求解积分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> integrate</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">half_circle</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>-x**<span class="number">2</span>)**<span class="number">0.5</span></span><br><span class="line">result = integrate.quad(half_circle, <span class="number">-1</span>, <span class="number">1</span>)	<span class="comment">#积分函数和积分上下限</span></span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># quad是一重积分，dblquad()和tplquad()分别是二重和三重积分</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据样本求解积分：分布均匀用<code>romb</code>，不均匀用<code>trapz(order 1), simple(order 2)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> simps</span><br><span class="line">x=np.array([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">y=np.array([<span class="number">1</span>,<span class="number">9</span>,<span class="number">16</span>])</span><br><span class="line">result=simps(y1,x)</span><br><span class="line">print(result)	<span class="comment"># 21.0</span></span><br><span class="line"><span class="comment"># 相当于计算x的2次方在1到4的定积分</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>求解常微分方程：<code>odeint(func, y0, t, args=())</code></p>
<ol>
<li><p>func: 计算微分方程组中每个未知函数的一阶导数值</p>
</li>
<li><p>y0：微分方程组中每个未知函数的初始值</p>
</li>
<li><p>t：需要进行数值求解的时间点 （数值解）</p>
</li>
<li><p>args：计算导数时的其他参数</p>
<p>求解方程以后还可以画好看的函数图像。</p>
<p>这个涉及的数学知识略多，暂时也不用，就先不看例子了</p>
</li>
</ol>
</li>
</ol>
<h2 id="interpolate模块的使用"><a href="#interpolate模块的使用" class="headerlink" title="interpolate模块的使用"></a>interpolate模块的使用</h2><ol>
<li><p>插值：</p>
<ol>
<li>一/二维插值：interp1d/interp2d </li>
<li>多维插值：griddata </li>
<li>其他常用插值：Spline样条插值(spl（曲线）, bispl（曲面）等)、Rbf插值</li>
</ol>
</li>
<li><p><code>interp1d(x, y, kind=&#39;linear‘,……)</code></p>
<ol>
<li>x,y：要插值的数据点，注意x是一个递增序列 </li>
<li>kind：插值的方法：‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’, ‘previous’,  ‘next’等</li>
<li>返回值：一个用于插值的函数，调用这个函数时以新的x为参数 ，会得到对应的y值。</li>
</ol>
</li>
<li><p>一维B样条插值：</p>
<ol>
<li>splrep(x,y,k=3,s,……)：获得一维曲线的B样条表示 </li>
<li>splev(x, tck, der=0,……)：根据B样条表示得到对应数值 </li>
</ol>
<p>呜呜呜我不想看B样条了就这样把</p>
</li>
</ol>
<h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><ol>
<li><p>最小二乘拟合： least_squares(fun, x0, bounds=(-inf, inf), method=‘trf’, args,……) </p>
<ol>
<li><p>fun：计算残差向量(residuals)的函数 </p>
</li>
<li><p>x0：猜测的参数值𝑝0 </p>
</li>
<li><p>bounds：参数𝑝的约束范围，2-tuple：((𝑝i的下限),(𝑝i的上限)) </p>
</li>
<li><p>method： ‘trf’, ‘dogbox’, ‘lm’，其中‘lm’不支持bounds </p>
</li>
<li><p>args：计算fun需要的其他参数，例如样本数据x，y</p>
<p>返回值： </p>
</li>
<li><p>x：求解出来使得S最小的参数𝑝 </p>
</li>
<li><p>fun：对应的残差向量</p>
</li>
</ol>
<p>一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x,p)</span>:</span></span><br><span class="line">    A,k,theta = p</span><br><span class="line">    <span class="keyword">return</span> A*np.sin(<span class="number">2</span>*np.pi*k*x+theta)</span><br><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi,<span class="number">100</span>)</span><br><span class="line">A,k,theta=<span class="number">10</span>,<span class="number">0.34</span>,np.pi/<span class="number">6</span>	<span class="comment"># 真实数据的函数参数</span></span><br><span class="line">y0=func(x,[A,k,theta])		<span class="comment"># 真实数据</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)			<span class="comment"># 噪声种子</span></span><br><span class="line">y=y0+<span class="number">2</span>*np.random.randn(len(x))	<span class="comment"># 添加噪声后的数据</span></span><br><span class="line"></span><br><span class="line">plt.plot(x,y,<span class="string">"o"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">residuals</span><span class="params">(p,y,x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> y-func(x,p)</span><br><span class="line">p0=[<span class="number">7</span>,<span class="number">0.4</span>,<span class="number">0</span>]</span><br><span class="line">plsq=optimize.least_squares(residuals,p0,args=(y,x))</span><br><span class="line">print(<span class="string">"真实参数："</span>,[A,k,theta])</span><br><span class="line">print(<span class="string">"拟合参数："</span>,plsq.x)</span><br><span class="line">plt.plot(x,func(x,plsq.x))</span><br><span class="line"><span class="comment"># 真实参数： [10, 0.34, 0.5235987755982988]</span></span><br><span class="line"><span class="comment"># 拟合参数： [10.25218748  0.3423992   0.50817423]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>scipy.optimize.curve_fit</code>：实质和最小二乘一样</p>
<p>用法上和least_squares稍有点不同：不用定义误差函数，直接 使用目标函数，且目标函数的各个待优化参数𝑝直接作为函数的参 数传入。</p>
</li>
<li><p>多项式拟合polyfit：</p>
<ol>
<li><p>numpy/scipy.polyfit(x, y, deg,……)： </p>
<ol>
<li>x,y：待拟合的数据 </li>
<li>deg：多项式的次数<br>返回值：<br>p：拟合后的多项式的系数，从<strong>高</strong>位到<strong>低</strong>位</li>
</ol>
</li>
<li>numpy/scipy.polyval(p, x)：计算多项式p在x处的值</li>
</ol>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = np.polyfit(x,y,<span class="number">10</span>)</span><br><span class="line">plt.plot(x,np.polyval(p,x),<span class="string">'k-'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>polynomial模块：</p>
<ol>
<li>拟合：和上面的区别在于，返回的多项式系数是从<strong>低</strong>到<strong>高</strong>的</li>
</ol>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.polynomial <span class="keyword">import</span> polymial <span class="keyword">as</span> P</span><br><span class="line">p2=P.polyfit(x,y,<span class="number">10</span>)</span><br><span class="line">plt.plot(x,P.polyfit(x,p2),<span class="string">'m-'</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>四则运算：<code>P.polyadd(), P.polysub(), P.polymul(), P.polydiv()</code></p>
</li>
<li><p>微分：<code>P.polyder()</code>用来求微分以后的多项式参数，默认是一阶导，加参数就是参数对应的导数</p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)	<span class="comment"># 1+2x+3x**2+4x**3</span></span><br><span class="line">P.polyder(a)	<span class="comment"># (d/dx)(c)=2+6x+12x**2	</span></span><br><span class="line"><span class="comment"># array([ 2., 6., 12.])</span></span><br><span class="line">P.polyder(a,<span class="number">3</span>)	<span class="comment"># (d**3/dx**3)(c)=24</span></span><br><span class="line"><span class="comment"># array([ 24.])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>积分：<code>P.polyint(c)</code>  和微分类似的用法</p>
</li>
<li><p>求根：<code>P.polyroots(a)</code> 和微分类似，对多项式求根，返回运算之后的参数</p>
</li>
</ol>
<h2 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h2><p>IBM.csv中保存了2014年以来的IBM股票信息，请读入IBM的收盘价，然后选取其中2019年的数据，之后： （1）假设每天的收盘价可以用之前5天的收盘价的线性组合表示出来，由此建立一个线性模型进行收盘价的预测，求解最佳的线性组合系数，并绘制收盘价以及预测的收盘价的曲线图。 </p>
<p>（2）采用多项式对收盘价进行拟合，尝试不同的多项式次数， 选取其中较优的结果，打印该多项式的各项系数，并绘制多项式曲线以及收盘价散点图。进一步，求解该多项式的转折点， 即一阶导数为0的点（只要实数解），并在多项式曲线上以上三角的标记绘制出来。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>首先是读取csv文件并提取2019年收盘价：</li>
<li>接下来，第一问可以看作是求解线性方程组的系数，<code>y=a*x1+b*x2+c*x3+d*x4+e*x5+f</code>，其中<code>abcdef</code>是待求解参数，<code>x1,x2,x3,x4,x5</code>分别是连续5天的收盘价，而<code>y</code>是第六天收盘价。<ol>
<li>建立存放<code>x</code>的列表；</li>
<li>遍历收盘价列表，把每一组收盘价（连续5个）作为一个列表加到x中，注意这里遍历的终点是倒数第5个，因为再往后就无法凑成连续5个了；</li>
<li>每一行<code>x</code>对应的<code>y</code>都是连续5个收盘价的下一个，也就是第6个收盘价开始，即<code>ibm_2019[5:]</code></li>
<li><code>x</code>和<code>y</code>都要转为<code>np.array</code>，然后用<code>lstsq</code>求解系数并绘制图像即可；</li>
</ol>
</li>
<li>第二问则是多项式拟合，这里我把自变量<code>x</code>设置为<code>1,2,3,...</code>，因变量<code>y</code>就是所有收盘价，然后使用<code>polyfit</code>求解并输出和绘图即可。经过尝试和比较，选择了<code>deg=17</code>。</li>
<li>求解一阶导数为0的点，也就是先对之前的多项式求导得到新多项式，再求解新多项式的根，最后在图像中标注即可。</li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line"><span class="keyword">from</span> numpy.polynomial <span class="keyword">import</span> polynomial <span class="keyword">as</span> P</span><br><span class="line">ibm = pd.read_csv(<span class="string">'IBM.csv'</span>, header=<span class="number">0</span>, index_col=<span class="number">0</span>, parse_dates=<span class="literal">True</span>)</span><br><span class="line">ibm_group = ibm.groupby(ibm.index.year)</span><br><span class="line">ibm_2019 = ibm_group.get_group(<span class="number">2019</span>)[<span class="string">'Close'</span>]</span><br><span class="line">x = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(ibm_2019)<span class="number">-5</span>):</span><br><span class="line">    tmp=[ibm_2019[i],ibm_2019[i+<span class="number">1</span>],ibm_2019[i+<span class="number">2</span>],ibm_2019[i+<span class="number">3</span>],ibm_2019[i+<span class="number">4</span>],<span class="number">1</span>]</span><br><span class="line">    x.append(tmp)</span><br><span class="line">x = np.array(x)</span><br><span class="line">y = np.array(ibm_2019[<span class="number">5</span>:])</span><br><span class="line">c,resid,rank,sigma=linalg.lstsq(x,y)</span><br><span class="line">x_1=np.linspace(<span class="number">1</span>,y.size,y.size)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x_1,y,<span class="string">'x'</span>, x_1,x.dot(c))</span><br><span class="line">x_2=np.linspace(<span class="number">1</span>,len(ibm_2019),len(ibm_2019))</span><br><span class="line">p=P.polyfit(x_2,ibm_2019,<span class="number">17</span>)</span><br><span class="line">print(<span class="string">"多项式系数为："</span>,p)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x_2,ibm_2019,<span class="string">'x'</span>,x_2,P.polyval(x_2,p),<span class="string">'k-'</span>)</span><br><span class="line">p2=P.polyder(p)</span><br><span class="line">root=P.polyroots(p2)</span><br><span class="line">plt.plot(root, P.polyval(root,p),<span class="string">'r^'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-FractalNet的ODE建模</title>
    <url>/2020/05/23/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-BEYOND%20FINITE%20LAYER%20NEURAL%20NETWORKS%20BRIDGING%20DEEP%20ARCHITECTURES%20AND%20NUMERICAL%20DIFFERENTIAL%20EQUATIONS/</url>
    <content><![CDATA[<h1 id="FractalNet的ODE建模"><a href="#FractalNet的ODE建模" class="headerlink" title="FractalNet的ODE建模"></a>FractalNet的ODE建模</h1><p>论文1：BEYOND FINITE LAYER NEURAL NETWORKS: BRIDGING DEEP ARCHITECTURES AND NUMERICAL DIFFERENTIAL EQUATIONS</p>
<p>论文2：FRACTALNET: ULTRA-DEEP NEURAL NETWORKS WITHOUT RESIDUALS</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>OED</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-12</title>
    <url>/2020/05/19/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-12/</url>
    <content><![CDATA[<p>这一课讲Pandas库。</p>
<p><code>import pandas as pd</code></p>
<a id="more"></a>
<h2 id="Pandas初探"><a href="#Pandas初探" class="headerlink" title="Pandas初探"></a>Pandas初探</h2><ol>
<li>读取文件：<code>data = pd.read_excel(filename, index_col=0)</code></li>
<li>取出数据中的一列或一行：<code>data[&#39;学号&#39;], data.loc[1]</code></li>
</ol>
<h2 id="Pandas数据类型"><a href="#Pandas数据类型" class="headerlink" title="Pandas数据类型"></a>Pandas数据类型</h2><h3 id="Series-一维序列"><a href="#Series-一维序列" class="headerlink" title="Series(一维序列)"></a>Series(一维序列)</h3><ol>
<li><p>由index+value组成</p>
</li>
<li><p>通过列表创建Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = pd.Series([<span class="string">'apple'</span>,<span class="string">'peach'</span>])</span><br><span class="line"><span class="comment"># 0	apple</span></span><br><span class="line"><span class="comment"># 1	peach</span></span><br><span class="line">a.index</span><br><span class="line"><span class="comment"># RangeIndex(start=0,stop=2,step=1)</span></span><br><span class="line">a.values</span><br><span class="line"><span class="comment"># array(['apple','peach'],dtype=object)</span></span><br><span class="line">a[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 'peach'</span></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">100</span></span><br><span class="line"><span class="comment"># 原来是peach的地方改成了100</span></span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line"><span class="comment"># 整个输出</span></span><br><span class="line">a[[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 输出0和1</span></span><br><span class="line">a = pd.Series([<span class="string">'apple'</span>,<span class="string">'peach'</span>],index=[<span class="string">'a'</span>,<span class="string">'p'</span>])</span><br><span class="line"><span class="comment"># a    apple</span></span><br><span class="line"><span class="comment"># p    peach</span></span><br><span class="line">a[<span class="string">'a'</span>]</span><br><span class="line"><span class="comment"># 输出索引a对应的value</span></span><br><span class="line">a[<span class="string">'a'</span>]=<span class="string">'lemon'</span></span><br><span class="line"><span class="comment"># 原来的apple改成lemon</span></span><br><span class="line">a[<span class="string">'a'</span>:]</span><br><span class="line"><span class="comment"># 整个输出</span></span><br><span class="line">a[[<span class="string">'a'</span>,<span class="string">'p'</span>]]</span><br><span class="line"><span class="comment"># 输出a和p对应的value</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过字典创建Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'Japan'</span>:<span class="string">'Tokyo'</span>,<span class="string">'S.Korea'</span>:<span class="string">'Seoul'</span>,<span class="string">'China'</span>:<span class="string">'Beijing'</span>&#125;</span><br><span class="line">a = pd.Series(d)</span><br><span class="line"><span class="comment"># Japan        Tokyo</span></span><br><span class="line"><span class="comment"># S.Korea      Seoul</span></span><br><span class="line"><span class="comment"># China      Beijing</span></span><br><span class="line"></span><br><span class="line">indexL=[<span class="string">'China'</span>,<span class="string">'Japan'</span>,<span class="string">'ingapore'</span>,<span class="string">'S.Korea'</span>]</span><br><span class="line">a = pd.Series(d, index=indexL)</span><br><span class="line"><span class="comment"># China       Beijing</span></span><br><span class="line"><span class="comment"># Japan         Tokyo</span></span><br><span class="line"><span class="comment"># ingapore        NaN</span></span><br><span class="line"><span class="comment"># S.Korea       Seoul</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过标量创建Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = pd.Series(<span class="string">'无'</span>)</span><br><span class="line"><span class="comment"># 0    无</span></span><br><span class="line">a = pd.Series(<span class="string">'无'</span>,index=np.arange(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># 1    无</span></span><br><span class="line"><span class="comment"># 2    无</span></span><br><span class="line"><span class="comment"># 3    无</span></span><br><span class="line"><span class="comment"># 4    无</span></span><br><span class="line"><span class="comment"># 5    无</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Series的基本运算：</p>
<ol>
<li>和numpy一样，过滤、广播、ufunc等</li>
<li>对齐：对应索引进行运算</li>
<li>频数统计：value_counts()</li>
</ol>
</li>
</ol>
<h3 id="DataFrame-二维表"><a href="#DataFrame-二维表" class="headerlink" title="DataFrame(二维表)"></a>DataFrame(二维表)</h3><ol>
<li><p>共用index的Series的有序集合</p>
</li>
<li><p>从二维数组创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = np.array([(<span class="string">'Japan'</span>,<span class="string">'Tokyo'</span>,<span class="number">4000</span>),(<span class="string">'S.Korea'</span>,<span class="string">'Seoul'</span>,<span class="number">1300</span>),(<span class="string">'China'</span>,<span class="string">'Beijing'</span>,<span class="number">9100</span>)])</span><br><span class="line">DF1 = pd.DataFrame(data, columns=[<span class="string">'nation'</span>,<span class="string">'capital'</span>,<span class="string">'GDP'</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引和数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DF1.index</span><br><span class="line">DF1.columns</span><br><span class="line">DF1.values</span><br></pre></td></tr></table></figure>
</li>
<li><p>从字典创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dct = &#123;<span class="string">'nation'</span>:[<span class="string">'Japan'</span>,<span class="string">'S.Korea'</span>,<span class="string">'Japan'</span>],<span class="string">'capital'</span>:pd.Series([<span class="string">'Tokyo'</span>,<span class="string">'Seoul'</span>,<span class="string">'Beijing'</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]),<span class="string">'GDP'</span>:np.array([<span class="number">4900.1300</span><span class="number">.9100</span>],dtype=int)&#125;</span><br><span class="line">DF2=pd.DataFrame(dct)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把某列数据作为index：<code>DF2.set_index(&#39;nation&#39;)</code></p>
</li>
<li><p>修改index/columns：<code>DF2.reindex(index=[&#39;c&#39;,&#39;a&#39;,&#39;b&#39;,&#39;d&#39;])</code></p>
</li>
<li><p>数据选择：</p>
<ol>
<li>取头尾若干行：<code>df.head(行数), df.tail(行数)</code></li>
<li>选择一列：<code>DF2.nation, DF2[&#39;GDP&#39;]</code></li>
<li>选择一行或多行：<code>DF2[0:2], DF2[&#39;a&#39;:&#39;c&#39;]</code>    序号只能是切片，不能是下标</li>
<li><code>loc[index, columns]</code>根据索引对多个轴进行选取</li>
<li>取单个数据：<code>DF2.loc[&#39;c&#39;,&#39;GDP&#39;]</code>或<code>DF2.at[&#39;c&#39;,&#39;GDP&#39;]</code></li>
<li>布尔索引：<ol>
<li>用某列的值来选取数据：<code>DF2[DF2.GDP&gt;3000]</code></li>
<li><code>isin()</code>方法过滤数据：<code>DF2[DF2.nation.isin([&#39;China&#39;,&#39;S.Korea&#39;])]</code></li>
</ol>
</li>
</ol>
</li>
<li><p>增加一列：<code>DF2[&#39;population&#39;]=[130,55,1600]</code></p>
</li>
<li><p>增加行：<code>append(要添加的行)</code>，序号是添加行的name，如果加入参数ignore_index=True，则序号就是数字</p>
</li>
<li><p>删除行列：<code>drop(序号)</code>，根据索引删除行列，默认删行，axis=1是删列</p>
</li>
<li><p>多个DataFrame对象数据拼接：</p>
<ol>
<li><code>pd.concat([p1,p2])</code>，序号是p1和p2各自的序号直接拼起来，是前几行p1，后几行p2；增加参数ignore_index=True，则序号是0、1、2、3这样；增加参数axis=1，则是前几列p1，后几列p2。</li>
<li><code>pd.merge(p1,p3,on=&#39;name&#39;)</code>，把p1和p3中name列相同的部分融合起来，如果是要把所有name都留下，但是只要一列name，则增加参数<code>how=&#39;outer&#39;</code></li>
</ol>
</li>
<li><p>缺失值处理：</p>
<ol>
<li><code>isnull()</code>和<code>notnull()</code>：是否缺失</li>
<li><code>fillna()</code>：补充缺失值</li>
<li><code>dropna()</code>：删除包含缺失值的行或列</li>
</ol>
</li>
<li><p>基本运算：<code>sub,add,mul,div,sum,min,max,mean,std,describe</code>，默认是竖着运算，加axis=1变成横着运算</p>
</li>
<li><p>分组：<code>groupby()</code>、<code>get_group(列名)</code>，也可以进行上一条的基本运算</p>
</li>
<li><p>排序：<code>sort_value(by=&#39;&#39;, ascending=False)</code> 根据by的取值排序，可以是一个字符串<code>by=&#39;成绩&#39;</code>，也可以是多个字符串的列表，<code>by=[&#39;成绩&#39;,&#39;年级&#39;]</code></p>
</li>
</ol>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h3><ol>
<li><code>read_csv()/to_csv()</code>读写csv和txt</li>
<li>加入参数index_col=0可以没有序号</li>
</ol>
<h3 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h3><ol>
<li><p><code>read_excel()/to_excel()</code>读写excel</p>
</li>
<li><p>把几个dataframe写到一个excel文件里的不同sheet中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer=pd.ExcelWriter(<span class="string">'atest.xlsx'</span>)</span><br><span class="line">a.to_excel(writer, sheet_name=<span class="string">'Sheet1'</span>)</span><br><span class="line">b.to_excel(writer, sheet_name=<span class="string">'Sheet2'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">'atest.xlsx'</span>) <span class="keyword">as</span> writer:</span><br><span class="line">    a.to_excel(writer, sheet_name=<span class="string">'Sheet1'</span>)</span><br><span class="line">	b.to_excel(writer, sheet_name=<span class="string">'Sheet2'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取一个exce里的多个sheet</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reader = pd.ExcelWriter(<span class="string">'atest.xlsx'</span>)</span><br><span class="line">df1 = pd.read_excel(reader, <span class="string">'Sheet1'</span>)</span><br><span class="line">df2 = pd.read_excel(reader, <span class="string">'Sheet2'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">'atest.xlsx'</span>) <span class="keyword">as</span> reader:</span><br><span class="line">    df1 = pd.read_excel(reader, <span class="string">'Sheet1'</span>)</span><br><span class="line">	df2 = pd.read_excel(reader, <span class="string">'Sheet2'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><ol>
<li>matplotlib中的pyplot模块：<code>b.plot()</code>，表格中的一列代表一条线的数据，行名是横坐标，表格内容值是纵坐标，默认是折线图</li>
<li>柱状图：<code>b.plot(kind=&#39;bar&#39;)      b.plot.bar()</code></li>
</ol>
<h2 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h2><p> 读入第三次作业第一部分爬虫得到的 csv文件，之后：</p>
<ol>
<li>绘制浏览次数曲线图；</li>
<li>根据浏览次数进行降序排序，并打印前10篇报道的日期、标题； </li>
<li>求浏览次数为1的报道的链接并打印结果；</li>
<li>统计每一年的报道数量，以及每一年的总的浏览次数，并分别以 柱状图的形式绘制出来；</li>
<li>统计2019年每个月的报道数量并以饼图的形式绘制出来。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>首先加载库文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来读取csv文件，考虑到后面的几项要求，把日期作为DatetimeIndex的索引比较好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports = pd.read_csv(<span class="string">'reportsInfo.csv'</span>, header=<span class="number">0</span>, index_col=<span class="number">0</span>, parse_dates=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个要求是绘制浏览次数的折线图，因为原本的csv文件时间是先2020年再2019年然后2018年这样倒着来的，所以先重新排序，再取浏览次数那一列的数值来画图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports.sort_index()[<span class="string">'浏览次数'</span>].plot(linestyle=<span class="string">'-'</span>, linewidth=<span class="number">2</span>, color=<span class="string">'steelblue'</span>)</span><br><span class="line">plt.title(<span class="string">'浏览次数折线图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'日期'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'浏览次数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">'reports_linechart'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据浏览次数降序排序的操作和上一步索引排序差不多，然后切片取前10，用loc定位到标题那一列，输出即可：</p>
<p><code>print(reports.sort_values(by=&#39;浏览次数&#39;, ascending=False)[0:10].loc[:, [&#39;标题&#39;]])</code></p>
</li>
<li><p>筛选浏览次数为1的链接，用下标的方式找即可：</p>
<p><code>print(reports[reports.浏览次数 == 1].链接)</code></p>
</li>
<li><p>统计每年的报道数量，需要先按年来分组，然后得到分组的size，对size画图即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports_group = reports.groupby(reports.index.year)</span><br><span class="line">reports_group.size().plot.bar()</span><br><span class="line">plt.title(<span class="string">'年报道数量柱状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'年份'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'报道数量'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">plt.savefig(<span class="string">'reports_bar_1'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计每年的总浏览次数，在上一条分组的基础上对浏览次数那一列求和，然后画图即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports_group[<span class="string">'浏览次数'</span>].sum().plot.bar()</span><br><span class="line">plt.title(<span class="string">'年浏览次数柱状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'年份'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'浏览次数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">plt.savefig(<span class="string">'reports_bar_2'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计2019年每月的报道数量，在之前的分组中可以得到2019的分组，然后对2019部分再按月来分组，得到size，对size画图即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports_2019 = reports_group.get_group(<span class="number">2019</span>)</span><br><span class="line">reports_2019_month = reports_2019.groupby(reports_2019.index.month).size()</span><br><span class="line">reports_2019_month.name = <span class="string">''</span></span><br><span class="line">reports_2019_month.plot.pie(startangle=<span class="number">90</span>)</span><br><span class="line">plt.title(<span class="string">'2019年每月报道数量饼状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.savefig(<span class="string">'reports_pie'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Dynamic Task Pricing in Multi-Requester Mobile Crowd Sensing with Markov Correlated Equilibrium</title>
    <url>/2020/05/14/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Dynamic-Task-Pricing-in-Multi-Requester-Mobile-Crowd-Sensing-with-Markov-Correlated-Equilibrium/</url>
    <content><![CDATA[<h1 id="基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价"><a href="#基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价" class="headerlink" title="基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价"></a>基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价</h1><a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li>场景：移动群智感知，多个发包方公开收集群体感知数据，公开定价来吸引workers</li>
<li>问题：<ol>
<li>requestor之间是不完整信息博弈</li>
<li>动态系统中未来的不确定性：未来会有多少workers</li>
</ol>
</li>
<li>解决方案：动态定价—&gt;Markov博弈，长期累积效用最大化，近似最小社会成本</li>
</ol>
<h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><ol>
<li>K个requestors，每个用$r_i$表示，集合是R</li>
<li>$r_i$发布$N_i$个任务，总共有W种类型，每种类型的任务只能由对应类型的worker来完成</li>
<li>$N_{i,w}$表示第i个requestor发布的w类型的任务数量</li>
<li>$R_w$表示发布了w类型任务的requestors</li>
<li>$N_i$表示所有同一个i的$N_{i,w}$，也就是一个requestor发布的所有任务数量</li>
<li>两种场景：<ol>
<li>所有workers同时到达</li>
<li>workers动态到达</li>
</ol>
</li>
</ol>
<p>这篇暂时先不往后看了，师弟组会讲过了</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>crowd sensing</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-11</title>
    <url>/2020/05/12/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-11/</url>
    <content><![CDATA[<p>这一课是matplotlib画图的介绍。</p>
<p><code>import matplotlib.pyplot as plt</code></p>
<a id="more"></a>
<h2 id="基础绘图"><a href="#基础绘图" class="headerlink" title="基础绘图"></a>基础绘图</h2><ol>
<li><p><code>plt.plot([x坐标],[y坐标])</code>设置图像坐标</p>
<p>x坐标如果是<code>[1,2,3,4]</code>这样连贯的，可以省略。</p>
</li>
<li><p><code>plt.show()</code>显示图像，<code>plt.sacefig(&#39;文件名&#39;, dpi=300)</code>保存图像为png文件。</p>
</li>
<li><p>多条曲线：<code>plt.plot(a,a,a,a*2,a,a**2)</code>，<code>a</code>是numpy数组。</p>
</li>
</ol>
<h2 id="设置图像属性"><a href="#设置图像属性" class="headerlink" title="设置图像属性"></a>设置图像属性</h2><ol>
<li>颜色和线宽：<code>plt.plot(x, y, format_string, **kwargs)</code>，其中<code>format_string</code>设定颜色、风格和标记。</li>
<li>坐标轴范围：<ol>
<li>获取坐标范围：<code>xlim(),ylim(),axis()</code></li>
<li>设置坐标范围：<code>xlim(xmin,xmax), ylim(ymin,ymax), axis([xmin,xmax,ymin,ymax])</code></li>
</ol>
</li>
<li>设置坐标轴刻度：<code>plt.xticks(),plt.yticks(0</code>)</li>
<li>设置坐标轴标签和图的题目：<code>xlabel(), ylabel(),title()</code></li>
<li>添加图例：<code>legend()</code></li>
<li>添加文字注释：<code>text()</code></li>
<li>标注：<code>ax.annotate()</code></li>
<li>网格：<code>plt.grid(True)</code>，可以设置颜色、线型等等</li>
</ol>
<h2 id="中文显示问题"><a href="#中文显示问题" class="headerlink" title="中文显示问题"></a>中文显示问题</h2><ol>
<li><code>rc_params()</code>指定字体：<code>matplotlib.rcParams[&#39;font.family&#39;]=&#39;STSong&#39;</code></li>
<li>在用到的地方指定字体：<code>fontproperties=&#39;Kaiti&#39;</code></li>
</ol>
<h2 id="绘制子图"><a href="#绘制子图" class="headerlink" title="绘制子图"></a>绘制子图</h2><ol>
<li><code>subplot(numRows, numCols, plotNum)</code></li>
<li><code>subplot2grid(shape, loc, rowspan=1, colspan=1)</code></li>
<li><code>gridspec.GridSpec()</code>和<code>subplot()</code>结合</li>
</ol>
<h2 id="绘制多个图"><a href="#绘制多个图" class="headerlink" title="绘制多个图"></a>绘制多个图</h2><p><code>figure()</code></p>
<h2 id="常用图标函数"><a href="#常用图标函数" class="headerlink" title="常用图标函数"></a>常用图标函数</h2><ol>
<li>散点图：<code>plt.scatter()</code></li>
<li>柱状图：<code>plt.bar()</code></li>
<li>直方图：<code>plt.hist()</code></li>
<li>饼图：<code>plt.pie()</code></li>
<li>等值线图：<code>plt.contour()</code></li>
<li>极坐标图：<code>plt.plot()</code></li>
<li>矢量场流线图：<code>plt.streamplot()</code></li>
<li>三维绘图：<code>Axes3D(fig)</code>或者<code>fig.add_subplot()</code></li>
</ol>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p> IBM.csv和BABA.csv分别保存了IBM和阿里巴巴股票信息，请读入它们的日期和收盘价，绘制收盘价曲线图，要求：</p>
<ol>
<li>设置横坐标和纵坐标轴标签、图的题目，另外横坐标轴刻度标签为日期；</li>
<li>对每一支股票求最高收盘价和最低收盘价，并在曲线上对这两个点进行标注。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>导入所需库文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.ticker <span class="keyword">as</span> ticker</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先是读入csv文件，因为日期是字符串，所以这里先统一用字符串的格式读入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ibm = np.loadtxt(<span class="string">"IBM.csv"</span>, dtype=np.str, delimiter=<span class="string">','</span>)</span><br><span class="line">baba = np.loadtxt(<span class="string">"BABA.csv"</span>, dtype=np.str, delimiter=<span class="string">','</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来提取所需数据：日期、收盘价、最高和最低收盘价，这里使用<code>astype()</code>把收盘价从numpy字符串转为numpy浮点数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># IBM</span></span><br><span class="line">date_ibm = ibm[<span class="number">1</span>:, <span class="number">0</span>]</span><br><span class="line">close_ibm = ibm[<span class="number">1</span>:, <span class="number">4</span>].astype(np.float)</span><br><span class="line">close_ibm_u = close_ibm.max()</span><br><span class="line">date_ibm_u = date_ibm[np.where(close_ibm == close_ibm_u)]</span><br><span class="line">close_ibm_l = close_ibm.min()</span><br><span class="line">date_ibm_l = date_ibm[np.where(close_ibm == close_ibm_l)]</span><br><span class="line"><span class="comment"># BABA</span></span><br><span class="line">date_baba = baba[<span class="number">1</span>:, <span class="number">0</span>]</span><br><span class="line">close_baba = baba[<span class="number">1</span>:, <span class="number">4</span>].astype(np.float)</span><br><span class="line">close_baba_u = close_baba.max()</span><br><span class="line">date_baba_u = date_baba[np.where(close_baba == close_baba_u)]</span><br><span class="line">close_baba_l = close_baba.min()</span><br><span class="line">date_baba_l = date_baba[np.where(close_baba == close_baba_l)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到数据以后就开始画图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画曲线</span></span><br><span class="line">plt.plot(date_ibm, close_ibm, color=<span class="string">"green"</span>, linewidth=<span class="number">0.5</span>, label=<span class="string">'IBM'</span>)</span><br><span class="line">plt.plot(date_baba, close_baba, color=<span class="string">"blue"</span>, linewidth=<span class="number">0.5</span>, label=<span class="string">'BABA'</span>)</span><br><span class="line"><span class="comment"># 设置x轴密度和刻度大小方向</span></span><br><span class="line">plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(<span class="number">80</span>))</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>, size=<span class="number">6</span>)</span><br><span class="line"><span class="comment"># 设置标题和轴标签内容及字体</span></span><br><span class="line">plt.title(<span class="string">'2014年以来IBM和BABA股票收盘价随日期的变换'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'日期'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'收盘价'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line"><span class="comment"># 设置图例位置</span></span><br><span class="line">plt.legend(loc=<span class="string">'upper center'</span>)</span><br><span class="line"><span class="comment"># 在四个最高最低点加圆圈标记</span></span><br><span class="line">plt.plot(date_ibm_u,close_ibm_u,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line">plt.plot(date_ibm_l,close_ibm_l,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line">plt.plot(date_baba_u,close_baba_u,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line">plt.plot(date_baba_l,close_baba_l,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 给四个最高最低点加文字说明</span></span><br><span class="line">plt.annotate(<span class="string">r'最高'</span>+str(close_ibm_u),color=<span class="string">'r'</span>,xy=(date_ibm_u,close_ibm_u),xytext=(<span class="number">-17</span>,<span class="number">15</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br><span class="line">plt.annotate(<span class="string">r'最低'</span>+str(close_ibm_l),color=<span class="string">'r'</span>,xy=(date_ibm_l,close_ibm_l),xytext=(<span class="number">-17</span>,<span class="number">-15</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br><span class="line">plt.annotate(<span class="string">r'最高'</span>+str(close_baba_u),color=<span class="string">'r'</span>,xy=(date_baba_u,close_baba_u),xytext=(<span class="number">-50</span>,<span class="number">6</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br><span class="line">plt.annotate(<span class="string">r'最低'</span>+str(close_baba_l),color=<span class="string">'r'</span>,xy=(date_baba_l,close_baba_l),xytext=(<span class="number">-50</span>,<span class="number">-6</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后显示和保存图像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">'homework'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>注意：在一开始的时候可以设置图像尺寸：<code>plt.figure(figsize=(1080/100,520/100),dpi=100)</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-10</title>
    <url>/2020/04/29/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-10/</url>
    <content><![CDATA[<p>这一课是numpy库。</p>
<p><code>import numpy as py</code></p>
<a id="more"></a>
<h2 id="创建数组基本方法："><a href="#创建数组基本方法：" class="headerlink" title="创建数组基本方法："></a>创建数组基本方法：</h2><ol>
<li><p><code>array()</code></p>
<p>python对象转换为数组</p>
</li>
<li><p><code>empty()</code></p>
<p>分配指定大小数组，不初始化</p>
</li>
<li><p><code>zeros()</code>,<code>ones()</code></p>
<p>建立全为0或1的数组</p>
</li>
<li><p><code>eye()</code>,<code>diag()</code></p>
<p>建立对角矩阵</p>
</li>
<li><p><code>arange()</code></p>
<p>初值、终值、步长建立一维数组</p>
</li>
<li><p><code>linspace()</code></p>
<p>初值、终值、元素个数建立一维数组</p>
</li>
<li><p><code>logspace</code></p>
<p>初值、终值、元素个数建立等比数列</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array((1,2,3,4))</span><br><span class="line">array([1, 2, 3, 4])</span><br><span class="line">b &#x3D; np.array([[1,2,3,4],[4,5,6,7],[7,8,9,10]])</span><br><span class="line">array([[ 1,  2,  3,  4],</span><br><span class="line">       [ 4,  5,  6,  7],</span><br><span class="line">       [ 7,  8,  9, 10]])		</span><br><span class="line">c &#x3D; a.tolist()</span><br><span class="line">[1,2,3,4]</span><br><span class="line">d &#x3D; np.empty((2,2))	#这里数组维数必须是是元组</span><br><span class="line">array([[9.90263869e+067, 9.38159477e-312],</span><br><span class="line">       [0.00000000e+000, 9.38983138e-312]])       </span><br><span class="line">e &#x3D; np.ones((2,2))</span><br><span class="line">array([[1., 1.],</span><br><span class="line">       [1., 1.]])       </span><br><span class="line">f &#x3D; np.diag((2,3,4))</span><br><span class="line">array([[2, 0, 0],</span><br><span class="line">       [0, 3, 0],</span><br><span class="line">       [0, 0, 4]])       </span><br><span class="line">g &#x3D; np.eye(3)</span><br><span class="line">array([[1., 0., 0.],</span><br><span class="line">       [0., 1., 0.],</span><br><span class="line">       [0., 0., 1.]])       </span><br><span class="line">h &#x3D; np.eye(2,3)</span><br><span class="line">array([[1., 0., 0.],</span><br><span class="line">       [0., 1., 0.]])</span><br><span class="line">i &#x3D; np.arange(5,10,1)</span><br><span class="line">array([5, 6, 7, 8, 9])</span><br><span class="line">j &#x3D; np.linspace(5,10,4)</span><br><span class="line">array([ 5.        ,  6.66666667,  8.33333333, 10.        ])</span><br><span class="line">k &#x3D; np.logspace(0,1,5)</span><br><span class="line">array([ 1.        ,  1.77827941,  3.16227766,  5.62341325, 10.        ])</span><br></pre></td></tr></table></figure>
<h2 id="数组的基本属性"><a href="#数组的基本属性" class="headerlink" title="数组的基本属性"></a>数组的基本属性</h2><ol>
<li><code>ndim</code>：数组的维度，也就是有几行</li>
<li><code>shape</code>：数组每维大小，元组形式</li>
<li><code>size</code>：数组里一共多少个元素</li>
<li><code>dtype</code>：数组数据类型</li>
<li><code>itemsize</code>：元素字节数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">d2 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">d3 = np.array([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]],[[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]])</span><br><span class="line">print(d1.ndim, d2.ndim, d3.ndim)		<span class="comment"># 1 2 3</span></span><br><span class="line">print(d1.shape, d2.shape, d3.shape)		<span class="comment"># (6,) (2, 3) (2, 2, 3)</span></span><br></pre></td></tr></table></figure>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><ol>
<li>改变数据类型：astype</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1.7</span>, <span class="number">1.2</span>, <span class="number">1.6</span>])</span><br><span class="line">b = a.astype(int)		<span class="comment"># b = array([1, 1, 1])</span></span><br></pre></td></tr></table></figure>
<h3 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h3><ol>
<li><p>reshape</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">b = a.reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># b = array([[1, 2, 3],</span></span><br><span class="line"><span class="comment">#            [4, 5, 6]])</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line"><span class="comment"># a = array([10,  2,  3,  4,  5,  6])</span></span><br><span class="line"><span class="comment"># b = array([[10, 2, 3],</span></span><br><span class="line"><span class="comment">#            [4, 5, 6]])</span></span><br><span class="line">b[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line"><span class="comment"># a = array([5,  2,  3,  4,  5,  6])</span></span><br><span class="line"><span class="comment"># b = array([[5, 2, 3],</span></span><br><span class="line"><span class="comment">#            [4, 5, 6]])</span></span><br><span class="line">c = b.reshape((<span class="number">-1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># array([[5, 2],</span></span><br><span class="line"><span class="comment">#       [3, 4],</span></span><br><span class="line"><span class="comment">#       [5, 6]])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shape：和reshape差不多的用法，<code>a.reshape((-1,2))</code>和<code>a.shape=(-1,2)</code>效果是一样的</p>
</li>
<li><p>resize：同上，<code>a.resize((-1,2))</code>，注意reshape和resize的参数是元组，而shape的参数则不是元组。此外，一般来说reshape有返回值，不对原始多维数组进行修改；resize无返回值，会对原始多维数组进行修改。但其实resize和reshape都可以有返回值，也都可以没有返回值，区别在于，reshape是改变形状而不改变数据量，或者说改变数组维度，如果reshape之后的元素数量和之前的不一致就会报错，但是resize不会，元素多了就去掉，少了就补零。</p>
</li>
<li><p>ravel：扁平化，多维变成一维数组，但是修改ravel之后的元素，<strong>会</strong>导致原始数组的元素跟着变。</p>
</li>
<li><p>flatten：扁平化，多维变成一维数组，修改flatten之后的元素，<strong>不会</strong>导致原始数组的元素跟着变。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">b = a.ravel()	<span class="comment"># b = ([1,2,3,4,5,6])</span></span><br><span class="line">b[<span class="number">0</span>]=<span class="number">99</span></span><br><span class="line"><span class="comment">#a = array([[99,  2,  3],</span></span><br><span class="line"><span class="comment">#           [ 4,  5,  6]])</span></span><br><span class="line">c = a.flatten()  <span class="comment"># c = ([99,  2,  3,  4,  5,  6])</span></span><br><span class="line">c[<span class="number">1</span>]=<span class="number">98</span></span><br><span class="line"><span class="comment">#a = array([[99,  2,  3],</span></span><br><span class="line"><span class="comment">#           [ 4,  5,  6]])</span></span><br></pre></td></tr></table></figure>
<ol>
<li>转置：<code>数组.T</code></li>
</ol>
<h3 id="数组组合"><a href="#数组组合" class="headerlink" title="数组组合"></a>数组组合</h3><ol>
<li><p>hstack：水平</p>
</li>
<li><p>vstack：垂直</p>
</li>
<li><p>concatenate</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">b = np.array([[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]])</span><br><span class="line">c = np.hstack((a,b))</span><br><span class="line"><span class="comment"># [[ 0  1  2  0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5  6  8 10]]</span></span><br><span class="line">d = np.vstack((a,b))</span><br><span class="line"><span class="comment"># [[ 0  1  2]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5]</span></span><br><span class="line"><span class="comment">#  [ 0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 6  8 10]]</span></span><br><span class="line">e = np.concatenate((a,b),axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># [[ 0  1  2  0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5  6  8 10]]</span></span><br><span class="line">f = np.concatenate((a,b),axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># [[ 0  1  2]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5]</span></span><br><span class="line"><span class="comment">#  [ 0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 6  8 10]]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数组分割"><a href="#数组分割" class="headerlink" title="数组分割"></a>数组分割</h3><ol>
<li>hsplit：水平</li>
<li>vsplit：垂直</li>
<li>split</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">a1, a2, a3 = np.hsplit(a,<span class="number">3</span>)</span><br><span class="line">b1, b2 = np.vsplit(a,<span class="number">2</span>)</span><br><span class="line">c1, c2 = np.split(a, <span class="number">2</span>, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># a1 = [[0]</span></span><br><span class="line"><span class="comment">#       [3]]</span></span><br><span class="line"><span class="comment"># a2 = [[1]</span></span><br><span class="line"><span class="comment">#       [4]]</span></span><br><span class="line"><span class="comment"># a3 = [[2]</span></span><br><span class="line"><span class="comment">#       [5]]</span></span><br><span class="line"><span class="comment"># b1 = [[0 1 2]]</span></span><br><span class="line"><span class="comment"># b2 = [[3 4 5]]</span></span><br><span class="line"><span class="comment"># c1 = [[0 1 2]]</span></span><br><span class="line"><span class="comment"># c2 = [[3 4 5]]</span></span><br></pre></td></tr></table></figure>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><ol>
<li><p>切片下标：和列表切片一样，修改切片后的元素会导致原始数组改变</p>
</li>
<li><p>高级下标：</p>
<ol>
<li><p>整数列表/元组作为下标</p>
</li>
<li><p>整数数组作为下标</p>
</li>
<li><p>布尔数组作为下标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">b = a[[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">7</span>]]	<span class="comment">#array([10,2,5,3])</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">c = a[np.array([<span class="number">3</span>,<span class="number">3</span>,<span class="number">-3</span>,<span class="number">8</span>])]	<span class="comment">#array([7,7,4,2])</span></span><br><span class="line">d = a[np.array([[<span class="number">3</span>,<span class="number">3</span>,<span class="number">-3</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])]	<span class="comment">#array([[7,7,4,2],[9,8,7,6]])</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">array([<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">b = a[np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">False</span>])]	<span class="comment">#array([5,3])</span></span><br><span class="line">a[np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">False</span>])] = <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span> </span><br><span class="line"><span class="comment">#array([-1, 4, -2, -3, 1])</span></span><br><span class="line">x = np.random.rand(<span class="number">4</span>)	</span><br><span class="line"><span class="comment"># [0.75217218 0.49197318 0.0754037  0.8145583 ]</span></span><br><span class="line">x &gt; <span class="number">0.5</span></span><br><span class="line"><span class="comment"># [ True False False  True]</span></span><br><span class="line">x[x&gt;<span class="number">0.5</span>]</span><br><span class="line"><span class="comment"># [0.75217218 0.8145583 ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多维数组：数组不同维数的坐标用<code>,</code>隔开，例如二维数组<code>a</code>，<code>a[0,1]</code>中，0是第一维（行），1是第二维（列），每个维度内可以用切片的方式访问，例如<code>a[0,3:5]</code>和<code>a[:,2]</code>等，也可以用列表或元组下标的方式访问。</p>
<p>下标长度小于数组维数时，剩余的轴对应的下标是<code>:</code> 。</p>
<p> 所有轴的下标形状相同时，得到的数组和下标形状相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="comment"># 0, 1, 2, 3, 4, 5</span></span><br><span class="line"><span class="comment"># 10,11,12,13,14,15</span></span><br><span class="line"><span class="comment"># 20,21,22,23,24,25</span></span><br><span class="line"><span class="comment"># 30,31,32,33,34,35</span></span><br><span class="line"><span class="comment"># 40,41,42,43,44,45</span></span><br><span class="line"><span class="comment"># 50,51,52,53,54,55</span></span><br><span class="line">a[<span class="number">0</span>, <span class="number">3</span>:<span class="number">5</span>]	<span class="comment"># 第0行第3列和第4列</span></span><br><span class="line"><span class="comment"># array([3,4])</span></span><br><span class="line">a[<span class="number">4</span>:,<span class="number">4</span>:]	<span class="comment"># 第4、5行和第4、5列</span></span><br><span class="line"><span class="comment"># array([[44,45],[54,55]])</span></span><br><span class="line">a[:,<span class="number">2</span>]		<span class="comment"># 第2列</span></span><br><span class="line"><span class="comment"># array([ 2, 12, 22, 32, 42, 52])</span></span><br><span class="line">a[<span class="number">2</span>,:]		<span class="comment"># 第2行</span></span><br><span class="line"><span class="comment"># array([20, 21, 22, 23, 24, 25])</span></span><br><span class="line">a[<span class="number">2</span>::<span class="number">2</span>, ::<span class="number">2</span>]	<span class="comment">#第2行到最后一行，步长2；所有列，步长2</span></span><br><span class="line"><span class="comment"># array([[20, 22, 24], [40, 42, 44]])</span></span><br><span class="line">a[(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)] <span class="comment">#坐标为(0,1)(1,2)(2,3)(3,4)(4,5)的元素</span></span><br><span class="line"><span class="comment"># array([1,12,23,34,45])</span></span><br><span class="line">a[<span class="number">3</span>:,[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>]]	<span class="comment">#第3行到最后一行，第0、2、5列</span></span><br><span class="line"><span class="comment"># array([[30, 32, 35], [40, 42, 45], [50, 52, 55]]) </span></span><br><span class="line">mask=np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], dtype=bool)</span><br><span class="line">a[mask,<span class="number">2</span>]</span><br><span class="line"><span class="comment"># array([2,22,52])</span></span><br><span class="line">a[[<span class="number">1</span>,<span class="number">2</span>]] 	<span class="comment">#相当于a[[1,2],:] </span></span><br><span class="line"><span class="comment"># array([[10, 11, 12, 13, 14, 15], [20, 21, 22, 23, 24, 25]])</span></span><br><span class="line">x=np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y=np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]]) </span><br><span class="line">a[x]	<span class="comment">#从2维数组变成3维数组</span></span><br><span class="line"><span class="comment"># [[[10 11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#   [20 21 22 23 24 25]]</span></span><br><span class="line"><span class="comment">#  [[30 31 32 33 34 35]</span></span><br><span class="line"><span class="comment">#   [40 41 42 43 44 45]]]</span></span><br><span class="line">a[x,y] 		<span class="comment"># x和y的元素分别作为两个维度的坐标</span></span><br><span class="line"><span class="comment"># x = 1 2</span></span><br><span class="line"><span class="comment">#     3 4</span></span><br><span class="line"><span class="comment"># y = 1 1</span></span><br><span class="line"><span class="comment">#     2 2</span></span><br><span class="line"><span class="comment">#a[x,y]=[a[1][1] a[2][1]</span></span><br><span class="line"><span class="comment">#        a[3][2] a[4][2]]</span></span><br><span class="line"><span class="comment"># = [[11 21]</span></span><br><span class="line"><span class="comment">#    [32 42]]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="ufunc"><a href="#ufunc" class="headerlink" title="ufunc"></a>ufunc</h2><pre><code>  1. 对数组中每个元素进行操作的函数，不需要写for循环
     2. 常用操作：加减乘除取余乘方、比较运算、布尔运算等等
     3. 自定义ufunc： frompyfunc(func, nin, nout)
</code></pre><h3 id="其他函数操作"><a href="#其他函数操作" class="headerlink" title="其他函数操作"></a>其他函数操作</h3><ol>
<li>求和sum</li>
<li>平均值mean/average</li>
<li>方差var</li>
<li>标准差std</li>
<li>中位数median</li>
<li>最值min、max、ptp、argmin、argmax</li>
<li>排序sort、argsort</li>
<li>查找nonzero(a)、where(condition[,x,y])</li>
</ol>
<h3 id="广播（这部分短期内应该用不到，就不写了）"><a href="#广播（这部分短期内应该用不到，就不写了）" class="headerlink" title="广播（这部分短期内应该用不到，就不写了）"></a>广播（这部分短期内应该用不到，就不写了）</h3><ol>
<li>让数组shape相同的操作</li>
<li>orrid对象</li>
<li>mgrid和meshgrid函数</li>
</ol>
<h2 id="文件存取"><a href="#文件存取" class="headerlink" title="文件存取"></a>文件存取</h2><ol>
<li>这部分短期内应该也就读个图像，不看了</li>
</ol>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>读入图像文件Cat.jpg，并通过numpy的数组操作对图像进行修改，得到下面一系列图像： </p>
<ol>
<li>反色图像：r、g、b为原始像素颜色，则反色后的颜色为255-r、255-g、 255-b </li>
<li>灰度图像： r、g、b为原始像素颜色，变成灰度的公式为： Gray = r<em>0.299 + g</em>0.587 + b*0.114</li>
<li>水平镜像图像：左右交换</li>
<li>垂直镜像图像：上下交换</li>
<li>行和列转置后的图像 </li>
<li>逆时针旋转90°后的图像 </li>
<li>红色/绿色/蓝色通道图像：其余两通道颜色为0, 0</li>
<li>红色通道的颜色替换成红色通道的最大值 </li>
<li>红色/绿色/蓝色通道重新组合，红色变成蓝色，绿色变成红色，蓝色变成绿色 </li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先读入图像：<code>im = np.array(Image.open(&quot;cat.jpg&quot;))</code></p>
<p>其次考虑保存图像，这里写了一个函数，把数组转为图像并按指定名称保存：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveimg</span><span class="params">(img, index)</span>:</span></span><br><span class="line">    img = Image.fromarray(img.astype(<span class="string">'uint8'</span>))</span><br><span class="line">    img.show()</span><br><span class="line">    img.save(<span class="string">'Cat'</span> + index + <span class="string">'.jpg'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>接下来就是图像处理部分了，考虑到有通道分离的要求，所以先把3个通道的数据提取出来，彩色图像变成数组时，是用三维数组存储的，前两个维度表示行列对应位置的像素值，第三个维度表示颜色通道，这里的通道顺序是rgb（而如果用opencv库的话，就是gbr），也就是说，<code>im[0,0,0]、im[0,0,1]、im[0,0,1]</code>就分别表示左上角那个像素的红色、绿色和蓝色值，这三个值叠加以后的结果就是彩色图像看上去的颜色，因此分离通道后，得到的是3个二维数组，如下：</p>
<p><code>r, g, b = im[:, :, 0], im[:, :, 1], im[:, :, 2]</code></p>
<ol>
<li><p>反色：这里构造一个和<code>im</code>尺寸一致且元素都是255的新数组，用这个新数组减去<code>im</code>即可。</p>
<p><code>im2 = np.ones_like(im) * 255 - im</code></p>
</li>
<li><p>灰度：按照公式对分离出来的r、g、b三个通道进行运算即可。</p>
<p><code>im3 = r * 0.299 + g * 0.587 + b * 0.114</code></p>
</li>
<li><p>水平镜像：每一行的元素逆序</p>
<p>这里是二维数组，也就是说要逆序的是列坐标，所以是第二维逆序</p>
<p><code>im4 = im[:, ::-1]</code></p>
</li>
<li><p>垂直镜像：每一列的元素逆序</p>
<p>同上，第一维逆序</p>
<p><code>im5 = im[::-1]</code></p>
</li>
<li><p>转置：这里的图像是三维数组，所以使用transpose函数来做，简单来说就是原本的第一、二维交换顺序，也就是<code>transpose(0,1,2)—&gt;transpose(1,0,2)</code></p>
<p><code>im6 = im.transpose(1, 0, 2)</code></p>
</li>
<li><p>逆时针90度：矩阵逆时针90度的操作是左乘一个负对角线上均是1、其余都是0的方阵，也就是说，转置矩阵逆序即可</p>
<p><code>im7 = im.transpose(1, 0, 2)[::-1]</code></p>
</li>
<li><p>三通道图像：把其他通道都变成0即可，最后把3个图拼起来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B_im = im.copy()</span><br><span class="line">B_im[:, :, [<span class="number">0</span>, <span class="number">1</span>]] = <span class="number">0</span></span><br><span class="line">G_im = im.copy()</span><br><span class="line">G_im[:, :, [<span class="number">0</span>, <span class="number">2</span>]] = <span class="number">0</span></span><br><span class="line">R_im = im.copy()</span><br><span class="line">R_im[:, :, [<span class="number">2</span>, <span class="number">1</span>]] = <span class="number">0</span></span><br><span class="line">im8 = np.concatenate((R_im, G_im, B_im), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>红色拉满：把红色通道变成255即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im9 = im.copy()</span><br><span class="line">im9[:, :, <span class="number">0</span>] = <span class="number">255</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通道重组：这里要想明白通道怎么组合，剩下的就很好做了。红色变成蓝色，绿色变成红色，蓝色变成绿色，也就是原本是红色的数值要变成蓝色通道，绿色数值变成红色通道，蓝色数值变成绿色通道，因此通道原本的<code>(0,1,2)</code>变成现在的<code>(1,2,0)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im10 = im.copy()</span><br><span class="line">im10 = im10[:, :, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-9</title>
    <url>/2020/04/22/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-9/</url>
    <content><![CDATA[<p>这一课是爬虫。</p>
<a id="more"></a>
<ol>
<li>使用两个库：<ol>
<li>Requests：获取网络数据</li>
<li>BeautifulSoup：分析网络数据</li>
</ol>
</li>
</ol>
<h3 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h3><ol>
<li><p>获取某网址信息：<code>requests.get(url, params=None, **kwargs)</code></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">html= requests.get(<span class="string">"html://www.bnu.edu.cn"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'bnu.html'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html.content)		<span class="comment"># 保存html的内容</span></span><br><span class="line">type(html)		<span class="comment"># requests.models.Response</span></span><br><span class="line">html.url		<span class="comment"># 'https://www.bnu.edu.cn/'</span></span><br><span class="line">html.content	<span class="comment"># 二进制内容</span></span><br><span class="line">html.text		<span class="comment"># 字符串（可能乱码）</span></span><br><span class="line">html.encoding	<span class="comment"># 'ISO-8859-1'</span></span><br><span class="line">html.encoding=<span class="string">'utf-8'</span>  <span class="comment">#修改编码</span></span><br><span class="line">html.request.headers	<span class="comment"># 访问方式： &#123;'User-Agent': 'python-requests/2.22.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把访问方式伪装成正常浏览器：</p>
<ol>
<li><p>获取浏览器的访问方式：</p>
<ol>
<li><p>在浏览器中打开链接；</p>
</li>
<li><p>按F12，找到Network；</p>
</li>
<li><p>随便选一个资源点一下（如果一个都没有，就刷新一下网页）；</p>
</li>
<li><p>在Request Headers里找到User-Agent并把整个内容复制出来。</p>
<p><img src="https://github.com/kun-bin/image/blob/master/0422.png?raw=true" alt="示意图"></p>
</li>
</ol>
</li>
<li><p>在代码中做伪装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>&#125;</span><br><span class="line">html = requests.get(<span class="string">"http://www.bnu.edu.cn"</span>, headers=head)</span><br><span class="line">html.request.headers	<span class="comment"># 访问方式变成User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><ol>
<li><p>分析页面信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)  <span class="comment">#lxml HTML 解析器：速度快，文档容错能力强</span></span><br><span class="line">type(bsObj)		<span class="comment"># bs4.BeautifulSoup</span></span><br><span class="line">bsObj.title     <span class="comment">#获得html中的title标签: &lt;title&gt;北京师范大学&lt;/title&gt;</span></span><br><span class="line">type(bsObj.title )	<span class="comment"># bs4.element.Tag</span></span><br><span class="line">bsObj.img   <span class="comment">#获得html中的第一个img标签: &lt;img alt="" src="images/logo1.png"/&gt;</span></span><br><span class="line">bsObj.a    <span class="comment">#获得html中的第一个a标签: &lt;a href="https://one.bnu.edu.cn" target="_blank"&gt;信息门户&lt;/a&gt;</span></span><br><span class="line">print(type(bsObj.img), type(bsObj.a ))	<span class="comment"># &lt;class 'bs4.element.Tag'&gt; &lt;class 'bs4.element.Tag'&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取标签信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bsObj.a.get_text()	<span class="comment"># '信息门户'</span></span><br><span class="line">bsObj.a.text		<span class="comment"># '信息门户'</span></span><br><span class="line">bsObj.a.attrs		<span class="comment"># &#123;'href': 'https://one.bnu.edu.cn', 'target': '_blank'&#125;</span></span><br><span class="line">bsObj.a[<span class="string">'href'</span>]		<span class="comment"># 获取a标签的href属性值：'https://one.bnu.edu.cn'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到特定标签：<code>find( name , attrs , recursive , text , **kwargs )</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alink=bsObj.find(<span class="string">'a'</span>)   <span class="comment"># 没有属性限定，找到第一个a标签</span></span><br><span class="line">print(alink)			<span class="comment"># &lt;a href="https://one.bnu.edu.cn" target="_blank"&gt;信息门户&lt;/a&gt;</span></span><br><span class="line">blink=bsObj.find(<span class="string">'a'</span>,text=<span class="string">'学部院系'</span>)	<span class="comment"># 限定了属性 text的值</span></span><br><span class="line">print(blink)			<span class="comment"># &lt;a href="xbyx/index.htm"&gt;学部院系&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>找到所有指定标签：<code>find_all( name , attrs , recursive , text , limit, **kwargs )</code>返回列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alink=bsObj.find_all(<span class="string">'a'</span>)</span><br><span class="line">print(alink)	<span class="comment"># 所有a标签的列表</span></span><br><span class="line">blink=bsObj.find_all(<span class="string">"a"</span>, limit=<span class="number">2</span>)	<span class="comment"># 只找前两个a标签</span></span><br><span class="line">print(blink)				<span class="comment"># [&lt;a href="https://one.bnu.edu.cn" target="_blank"&gt;信息门户&lt;/a&gt;, &lt;a href="http://xxgk.bnu.edu.cn/" target="_blank"&gt;信息公开&lt;/a&gt;]</span></span><br><span class="line">clink=bsObj.find_all(<span class="string">'span'</span>, class_=<span class="string">"more01"</span>)	<span class="comment"># class值符合要求的span标签</span></span><br><span class="line">print(clink)		<span class="comment"># [&lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;, &lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;, &lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;, &lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">imglist = bsObj.find_all(<span class="string">'img'</span>, &#123;<span class="string">"src"</span>:re.compile(<span class="string">".+\.jpg"</span>)&#125;)	<span class="comment"># 符合正则表达的标签</span></span><br><span class="line">print(imglist)</span><br><span class="line"></span><br><span class="line">dlink=bsObj.find(<span class="string">'div'</span>, class_=<span class="string">"nav"</span>).find_all(<span class="string">'a'</span>)	<span class="comment"># find和findall结合使用</span></span><br><span class="line">print(dlink)</span><br></pre></td></tr></table></figure>
</li>
<li><p>相对url转绝对url：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">url=<span class="string">'https://www.bnu.edu.cn/'</span></span><br><span class="line">blink = urljoin(url, blink[<span class="string">'href'</span>])</span><br><span class="line">print(blink)	<span class="comment"># https://www.bnu.edu.cn/xbyx/index.htm</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>图像相关（img标签）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clink=bsObj.find(<span class="string">'img'</span>)</span><br><span class="line">print(clink)			<span class="comment"># &lt;img alt="" src="images/logo1.png"/&gt;</span></span><br><span class="line">print(clink[<span class="string">'src'</span>])		<span class="comment"># images/logo1.png</span></span><br><span class="line">logo= requests.get(urljoin(url, clink[<span class="string">'src'</span>]), headers=head) <span class="comment">#获得图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">im=Image.open(BytesIO(logo.content))</span><br><span class="line">im.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图像</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'D:\2020Python\Ch8\BNU-logo.png'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f: </span><br><span class="line">    f.write(logo.content)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'D:\2020Python\Ch8\BNU-logo.'</span>+clink[<span class="string">'src'</span>][<span class="number">-3</span>:], <span class="string">'wb'</span>) <span class="keyword">as</span> f: </span><br><span class="line">    f.write(logo.content)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>class</code>标签的访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dlink=bsObj.find('span', class="col-md-10")  #class 是关键词，不能这样使用</span><br><span class="line"><span class="comment"># 解决方案1</span></span><br><span class="line">dlink=bsObj.find(<span class="string">'div'</span>, class_=<span class="string">"item-txt01"</span>)</span><br><span class="line">print(dlink)</span><br><span class="line"><span class="comment"># 解决方案2</span></span><br><span class="line">dlink=bsObj.find(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>:<span class="string">'item-txt01'</span>&#125;)</span><br><span class="line">print(dlink.text)</span><br></pre></td></tr></table></figure>
</li>
<li><p>网页源码树状结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clink=bsObj.find(<span class="string">'li'</span>)</span><br><span class="line">clink.parent  <span class="comment">#父节点</span></span><br><span class="line">clink.children  <span class="comment">#孩子节点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> clink.children:</span><br><span class="line">    print(child)	<span class="comment"># 输出子节点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> clink.descendants:    <span class="comment">#子孙节点，后代节点</span></span><br><span class="line">    print(child)</span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> clink.next_siblings:  <span class="comment">#兄弟节点</span></span><br><span class="line">    print(sibling)</span><br><span class="line">clink.find_parent(<span class="string">'div'</span>, class_=<span class="string">'nav'</span>)  <span class="comment">#满足class为‘nav’的父节点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> clink.findChildren(<span class="string">'a'</span>):  <span class="comment">#找到 a标签 孩子</span></span><br><span class="line">    print(child)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="爬取网页所有图片的示例"><a href="#爬取网页所有图片的示例" class="headerlink" title="爬取网页所有图片的示例"></a>爬取网页所有图片的示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#只爬取url网页上的图片，不爬next网页上的图片</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line">url = <span class="string">'http://news.bnu.edu.cn/sj/gysd/index.htm'</span></span><br><span class="line">head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">html = requests.get(url, headers = head)</span><br><span class="line">bsObj= BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">allLinks = bsObj.find_all(<span class="string">'div'</span>, class_=<span class="string">"grid"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> allLinks:</span><br><span class="line">    imglink = i.find(<span class="string">'img'</span>)[<span class="string">'src'</span>]	</span><br><span class="line">    imglink = urljoin(url, imglink)	<span class="comment"># 图片链接</span></span><br><span class="line">    name = i.find(<span class="string">'h3'</span>).text		<span class="comment"># 图片标题</span></span><br><span class="line">    print(imglink, name)</span><br><span class="line">    img  = requests.get(imglink, headers = head)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">r'D:\2020Python\Ch8\图片/'</span>+name+imglink[<span class="number">-4</span>:], <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(img.content)		<span class="comment"># 保存图片</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#爬取本网页以及下一页的图片</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">url=<span class="string">'http://news.bnu.edu.cn/sj/gysd/index.htm'</span></span><br><span class="line">head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">path=<span class="string">'D:/2020Python/Ch8/光影师大/'</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.mkdir(path)</span><br><span class="line">nexturl=url</span><br><span class="line"><span class="keyword">while</span> nexturl:</span><br><span class="line">    html = requests.get(nexturl, headers=head)</span><br><span class="line">    bsObj=BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">    imgslink=bsObj.find_all(<span class="string">'div'</span>, class_=<span class="string">"grid"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> imgslink:</span><br><span class="line">        imglink=i.find(<span class="string">'img'</span>)[<span class="string">'src'</span>]</span><br><span class="line">        imglink=urljoin(nexturl,imglink)</span><br><span class="line">        name=i.find(<span class="string">'h3'</span>).text</span><br><span class="line">        name=<span class="string">''</span>.join([i <span class="keyword">for</span> i <span class="keyword">in</span> name <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'\\'</span>,<span class="string">'/'</span>,<span class="string">':'</span>,<span class="string">'*'</span>,<span class="string">'?'</span>,<span class="string">'"'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'|'</span>]])</span><br><span class="line">        print(imglink, name)        </span><br><span class="line">        img=requests.get(urljoin(nexturl,imglink), headers=head)</span><br><span class="line">        <span class="keyword">with</span> open(path+name+imglink[<span class="number">-4</span>:], <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(img.content)        </span><br><span class="line">    temp=bsObj.find(<span class="string">'a'</span>,class_=<span class="string">"next"</span>)	<span class="comment"># 获取next标签（下一页）</span></span><br><span class="line">    <span class="keyword">if</span> temp:</span><br><span class="line">        nexturl=urljoin(nexturl,temp[<span class="string">'href'</span>])	<span class="comment"># 获取下一页的url</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nexturl=<span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><p>抓取北京师范大学中头条关注网站： <a href="http://news.bnu.edu.cn/zx/ttgz/index.htm" target="_blank" rel="noopener">http://news.bnu.edu.cn/zx/ttgz/index.htm</a> 上迄今为止所 有头条关注报道的发表日期、标题、链接以及浏览次数，保存为 一个csv文件，要求使用函数封装。</p>
<p>思路：</p>
<ol>
<li><p>导入所需库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析这个网站，发现了很神奇的一点，该网站一共68页，应该只有第68页没有<code>next</code>标签，但实际上它第67页就没了。如果用保存图像那个例子里的方式访问，则无法访问到第68页，所以考虑写个函数来获取网站一共多少页，然后<code>for</code>循环读网页内容。</p>
<p>经过仔细观察，可以发现网页下面有一个元素用来显示“现在是第几页/总共多少页”，源代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pages "</span>&gt;</span></span><br><span class="line">		   			            页数：<span class="tag">&lt;<span class="name">span</span>&gt;</span>1/68<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          总数：<span class="tag">&lt;<span class="name">span</span>&gt;</span>680<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">						</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.htm"</span> <span class="attr">class</span>=<span class="string">"on_pages"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index1.htm"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index2.htm"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index3.htm"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index4.htm"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index5.htm"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index6.htm"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index7.htm"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index8.htm"</span>&gt;</span>9<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index9.htm"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index1.htm"</span> <span class="attr">class</span>=<span class="string">"next"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../../images/pages04.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index10.htm"</span> <span class="attr">class</span>=<span class="string">"end"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../../images/pages05.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因此可以找到<code>class = pages</code> 的<code>div</code>标签，然后获取其中<code>span</code>标签的内容，并截取<code>/</code>符号后面的内容转为数字，即可得到网站页数，写成函数的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page</span><span class="params">(url, head)</span>:</span></span><br><span class="line">    html = requests.get(url, headers=head)</span><br><span class="line">    bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">    <span class="keyword">return</span> int(bsObj.find(class_=<span class="string">"pages"</span>).find(<span class="string">'span'</span>).text.split(<span class="string">'/'</span>)[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来可以通过<code>for</code>循环访问每一页，第一页是<code>index.htm</code>，接下来是<code>index1.htm</code>等等，直到最后是<code>index67.htm</code>。</p>
<ol>
<li><p>分析网页源码可知，在每一页中，我们需要提取的内容一定在<code>class = item-info01</code>的标签中，因此使用<code>findall</code>然后遍历得到的标签列表。</p>
</li>
<li><p>分析每个标签源码可知，文章标题出现在<code>h3</code>中，即<code>title = i.find(&#39;h3&#39;).text</code>。</p>
</li>
<li><p>文章链接是<code>a</code>标签的<code>href</code>属性，是相对链接，要转换为绝对链接，不过这里需要注意，有一些文章用了微信链接等站外网页作为内容，因此这些链接是绝对链接，不需要转换。所以要判断一下首字母是否为<code>h</code>。此外，在我们保存的时候，链接后面要加浏览次数，直接用逗号分隔会导致打开csv时链接和浏览次数连在一起，所以链接本身保存时在末尾加个空格。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">link = i.find(<span class="string">'a'</span>)[<span class="string">'href'</span>]</span><br><span class="line"><span class="keyword">if</span> link[<span class="number">0</span>] != <span class="string">'h'</span>:</span><br><span class="line">	link = urljoin(url, link)</span><br><span class="line">link += <span class="string">' '</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>文章时间是<code>class = time</code>的<code>span</code>标签对应的内容，即<code>time = i.find(&#39;span&#39;, class_=&quot;time&quot;).text</code>。</p>
</li>
<li><p>最后是文章浏览次数，这个网站浏览次数是用script做的，所以要跳转到对应链接，然后从新网页里获取浏览次数。对应的相对链接是<code>script</code>标签中的<code>src</code>属性，因此要跳转的新网页是<code>urljoin(url, i.find(&#39;script&#39;)[&#39;src&#39;])</code>，这个网页的内容只有<code>document.write(&#39;31&#39;)</code>这样的字符，所以获取网页内容后提取它17位开始、倒数第3位结束的内容即可得到浏览次数（类型为字符串）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">viewlink = urljoin(url, i.find(<span class="string">'script'</span>)[<span class="string">'src'</span>])</span><br><span class="line">view = BeautifulSoup(requests.get(viewlink).text, <span class="string">'lxml'</span>).text[<span class="number">16</span>:<span class="number">-3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后把上述内容按顺序加到列表中，然后在整个循环结束后返回列表即可。完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analy</span><span class="params">(page, url, head)</span>:</span></span><br><span class="line">    lists = []</span><br><span class="line">    nexturl = url</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(page):</span><br><span class="line">        html = requests.get(nexturl, headers=head)</span><br><span class="line">        bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">        allLink = bsObj.find_all(class_=<span class="string">"item-info01"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> allLink:</span><br><span class="line">            title = i.find(<span class="string">'h3'</span>).text</span><br><span class="line">            link = i.find(<span class="string">'a'</span>)[<span class="string">'href'</span>]</span><br><span class="line">            <span class="keyword">if</span> link[<span class="number">0</span>] != <span class="string">'h'</span>:</span><br><span class="line">                link = urljoin(url, link)</span><br><span class="line">            link += <span class="string">' '</span></span><br><span class="line">            time = i.find(<span class="string">'span'</span>, class_=<span class="string">"time"</span>).text</span><br><span class="line">            viewlink = urljoin(url, i.find(<span class="string">'script'</span>)[<span class="string">'src'</span>])</span><br><span class="line">            view = BeautifulSoup(requests.get(viewlink).text, <span class="string">'lxml'</span>).text[<span class="number">16</span>:<span class="number">-3</span>]</span><br><span class="line">            lists.append([time, title, link, view])</span><br><span class="line">        nexturl = urljoin(nexturl, <span class="string">'index'</span> + str(index + <span class="number">1</span>) + <span class="string">'.htm'</span>)</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>在得到列表后，根据要求输出csv文件，这部分内容是上一课讲过的，基本没有变化，注意编码要用<code>utf-8-sig</code>，如果用其他编码，保存的中文会乱码；如果只是<code>utf-8</code>没<code>sig</code>，则excel打开时中文会乱码。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writecsv</span><span class="params">(lists)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"reportsInfo.csv"</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>, encoding=<span class="string">'utf-8-sig'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f_csv = csv.writer(f)</span><br><span class="line">        headers = [<span class="string">'日期'</span>, <span class="string">'标题'</span>, <span class="string">'链接'</span>, <span class="string">'浏览次数'</span>]</span><br><span class="line">        f_csv.writerow(headers)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> lists:</span><br><span class="line">            f_csv.writerow(row)</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后是主函数部分，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head = &#123;</span><br><span class="line">    <span class="string">'user-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>&#125;</span><br><span class="line">url = <span class="string">'http://news.bnu.edu.cn/zx/ttgz/index.htm'</span></span><br><span class="line">page = page(url, head)</span><br><span class="line">lists = analy(page, url, head)</span><br><span class="line">writecsv(lists)</span><br><span class="line">print(<span class="string">"FIN"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-8</title>
    <url>/2020/04/17/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-8/</url>
    <content><![CDATA[<p>这一课讲文件读写。</p>
<a id="more"></a>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ol>
<li><p>文件类型：文本文件（纯文本、源代码、网页）、二进制文件（图片、word、excel、ppt）</p>
</li>
<li><p>读文本文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r'/path/to/file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.read()</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>这样用<code>with open as</code>可以不用写<code>close</code></p>
</li>
<li><p>open函数：<code>open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code> 返回一个文件对象，是可迭代对象</p>
</li>
<li><p>tell函数：<code>f.tell()</code>返回文件指针当前在的位置</p>
</li>
<li><p>文本文件操作：</p>
<p>以下都是写在<code>with open</code>的代码块里面</p>
<ol>
<li>读文本文件：<ol>
<li><code>f.readline()</code>：读一行，到换行符结束，返回字符串</li>
<li><code>f.read(2)</code>：接着读2个字符，返回字符串</li>
<li><code>f.readlines()</code>：把剩下的都读完，返回列表，每一行作为列表中的一个元素</li>
</ol>
</li>
<li>写文本文件：<ol>
<li><code>f.write</code>：写入字符串，不换行，可以在字符串末尾加<code>\n</code>来实现换行</li>
<li><code>f.writelines</code>：写入列表元素，不换行，可以在要换行的元素末尾加<code>\n</code></li>
</ol>
</li>
<li>文件模式相关：<ol>
<li>用新建文件的模式（<code>x</code>）来open文件，如果存在同名文件，则会报错</li>
<li>用<code>w</code>方式写文件，如果存在同名文件，会清空原有内容再写入</li>
<li>用<code>a</code>方式写文件，存在同名文件的时候，不会清空内容，而是在文件末尾写入新内容</li>
<li>用<code>r+</code>的方式读写文件，默认位置为文件开头，读完以后移到结尾</li>
<li>用<code>w+</code>的方式读写文件，清空文件内容以后读写</li>
<li>用<code>a+</code>的方式读写文件，默认位置是文件末尾</li>
<li>带+的都是可读可写，不带+的则只有读或者写</li>
</ol>
</li>
<li>改变文件读写位置：<code>seek(offset, whence=0)</code>，从whence(0起始，1当前，2末尾)偏移offset个字节。例如<code>f.seek(0)</code>可以把文件指针放到最开始的地方。</li>
<li>字符字节说明：utf-8编码中文3字节英文1字节；gbk编码中文2字节英文1字节</li>
</ol>
</li>
<li><p>二进制文件操作：</p>
<ol>
<li>open函数的打开模式为<code>b</code></li>
</ol>
</li>
<li><p>CSV文件：文本文件</p>
<ol>
<li>由若干条记录组成，每条记录由字段组成，字段间由分 隔符分开，最常见的分隔符是逗号，也可以是制表符、分号等</li>
<li>列表读写：<code>csv.reader</code>和<code>csv.writer</code></li>
<li>字典读写：<code>csv.DictReader</code>和<code>csv.DictWriter</code></li>
<li><code>csv.reader(csvfile, dialect=‘excel’, **fmtparams)</code>：以字符串列表的形式读入文件内容，一行是一个列表<ol>
<li>是可迭代对象，可以通过<code>next</code>访问，比如读完文件先用next把第一行存在标题变量里，再遍历剩下的内容</li>
</ol>
</li>
<li><code>csv.writer(csvfile, dialect=‘excel’, **fmtparams)</code>：把字符串列表写入csv文件，注意先写入标题行，再写入剩下内容</li>
<li><code>csv.DictReader(csvfile, fieldnames=None, restkey=None, restval=None, dialect=‘excel’, *args, **kwds)</code>字典方式读入，标题是key，内容是value<ol>
<li>csv文件没有标题行时，可以设定列表指定标题行，然后<code>csv.DictReader(f,headers)</code>来建立内容和标题一一对应的字典</li>
</ol>
</li>
<li><code>csv.DictWriter(csvfile, fieldnames, restval=‘’, extrsaction=‘raise’, dialect=‘excel’, *args, **kwds)</code> 要指定标题行和内容，在创建csv对象时就指定标题，接下来写入标题，最后写入内容</li>
</ol>
</li>
</ol>
<h3 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h3><ol>
<li><p>读入《Declaration.txt》文件，该文件里存的是一篇英文文章 ，要求把这篇文章中的不重复单词（单词的不同时态以及单复数都 看成是不同的单词）进行排序后写入一个新的txt文件，并要求每行 5个单词，同时注意对齐。</p>
<p>思路：</p>
<ol>
<li><p>使用<code>with open</code>方式读入文件并把其中的单词存入列表；</p>
</li>
<li><p>借助<code>Counter</code>统计词频和排序</p>
</li>
<li><p>把排序之后的列表写入新文件</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 读入文件内容，把单词存入列表并返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strtolist</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open (name,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s = f.read()</span><br><span class="line">    words = re.findall(<span class="string">r'[a-zA-Z]+'</span>,s)</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对列表中的单词按字母顺序排序并返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortword</span><span class="params">(words)</span>:</span></span><br><span class="line">    list1 = collections.Counter(words)</span><br><span class="line">    list2 = sorted(list1.items())</span><br><span class="line">    list3 = []</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> list2:</span><br><span class="line">        list3.append(key)</span><br><span class="line">    <span class="keyword">return</span> list3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把列表中的元素按要求写入文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writefile</span><span class="params">(lists)</span>:</span></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'wordlist.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">            f.write(<span class="string">'&#123;:&lt;16&#125;'</span>.format(i))</span><br><span class="line">            f.write(<span class="string">'\t'</span>)</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                f.write(<span class="string">'\n'</span>)</span><br><span class="line">                </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    words = strtolist(<span class="string">'Declaration.txt'</span>)</span><br><span class="line">    lists = sortword(words)</span><br><span class="line">    writefile(lists)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>读入存有姓名和成绩的 成绩单.csv 文件，计算最终加权成绩（ 小数点后保留两位，三个成绩的权重分别为0.22,0.18,0.6），并 把该成绩追到到原有信息中，保存为一个新的csv文件。</p>
<p>思路：</p>
<ol>
<li><p>读入csv文件，并为标题行添加“最终成绩”</p>
</li>
<li><p>计算平均分并添加到这一行的末尾，保留2位小数</p>
</li>
<li><p>把这一行的数据存到列表中</p>
</li>
<li><p>把刚才的内容逐行写入新的csv文件，注意这里要在之前那个文件关闭之前完成</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"><span class="keyword">with</span> open (<span class="string">'成绩单.csv'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv=csv.reader(f)</span><br><span class="line">    headers = next(f_csv)</span><br><span class="line">    headers.append(<span class="string">'最终成绩'</span>)</span><br><span class="line">    lists = []</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        avg = <span class="number">0.22</span>*int(row[<span class="number">1</span>])+<span class="number">0.18</span>*int(row[<span class="number">2</span>])+<span class="number">0.6</span>*int(row[<span class="number">3</span>])</span><br><span class="line">        row.append(avg)</span><br><span class="line">        row[<span class="number">4</span>]=str(<span class="string">'&#123;:.2f&#125;'</span>.format(row[<span class="number">4</span>]))</span><br><span class="line">        lists.append(row)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'新成绩单.csv'</span>,<span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> s:</span><br><span class="line">        s_csv=csv.writer(s)</span><br><span class="line">        s_csv.writerow(headers)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> lists:</span><br><span class="line">            s_csv.writerow(row)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-7</title>
    <url>/2020/04/16/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-7/</url>
    <content><![CDATA[<p>这一课讲python中函数和模块的使用。</p>
<a id="more"></a>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ol>
<li><p>函数定义时可以为参数指定默认值，这样没传参的时候就会用默认值，要先声明没默认值的参数，再声明有默认值的。</p>
</li>
<li><p>调用函数时可以直接指明参数值（<code>mysum1(score1 = 88, score2 = 79)</code>)，不指明的参数写前面，指明的放后面。</p>
</li>
<li><p>指针（*）形式传递可变参数，以元组形式打包多出来的参数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum2</span><span class="params">(a,b,*c)</span>:</span></span><br><span class="line">	total=a+b</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> c:</span><br><span class="line">        total=total+n</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">print(my_sum2(<span class="number">1</span>,<span class="number">2</span>))				<span class="comment">#c=()	输出3</span></span><br><span class="line">print(my_sum2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))		<span class="comment">#c=(3,4,5)	输出15</span></span><br><span class="line">print(my_sum2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>))	<span class="comment">#c=(3,4,5,10,20)	输出45</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>双指针（**）形式传递可变参数，以字典形式打包多出来的参数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum3</span><span class="params">(a,b,*c,**d)</span>:</span></span><br><span class="line">	total=a+b</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> c:</span><br><span class="line">        total=total+n</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">        total=total+d[key]</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">print(my_sum3(<span class="number">1</span>,<span class="number">2</span>))							<span class="comment">#c=() d=&#123;&#125; 输出3</span></span><br><span class="line">print(my_sum3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))					<span class="comment">#c=(3,4,5) d=&#123;&#125; 输出15</span></span><br><span class="line">print(my_sum3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,male=<span class="number">6</span>,female=<span class="number">7</span>))	<span class="comment">#c=(3,4,5) d=&#123;'male':6,'female':7&#125; 输出28</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><em>或*</em>的参数如果不位于形参列表的最后位置，则会使其后面声 明的参数为强制命名参数；使用一个星号而不带参数，也可导致强制命名参数。</p>
</li>
<li><p>列表、元组、字典可通过<em>和*</em>作为参数传递给函数。</p>
</li>
<li><p>形参复制了实参所指对象的引用</p>
</li>
</ol>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><ol>
<li>返回多个值时，是元组形式。</li>
</ol>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ol>
<li><p>局部变量全局变量和其他语言基本一致</p>
</li>
<li><p>只要在函数体内有赋值语句，不管在哪一行，这个变量就是局部变量，函数体内也只会用这个局部变量，而不是同名全局变量，例如下述代码会直接报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(var)</span><br><span class="line">    var=<span class="number">200</span></span><br><span class="line">fun()</span><br><span class="line"></span><br><span class="line">var=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    var+=<span class="number">1</span></span><br><span class="line">    print(var)</span><br><span class="line">fun()</span><br><span class="line"></span><br><span class="line">报错信息：local variable <span class="string">'var'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数体内用全局变量，要声明<code>global</code></p>
</li>
<li><p>函数嵌套函数时，内层函数变量作用域只在内层，不影响外层，如果要内层用外层的，要声明<code>nonlocal</code></p>
</li>
</ol>
<h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><ol>
<li><p>递归</p>
</li>
<li><p>函数可以作为其他函数的参数</p>
</li>
<li><p>lambda匿名函数：实现行内函数 <code>lambda 形参列表:返回的结果</code></p>
<p>例如：<code>f=lambda x,y: x+y</code>，<code>f(12,34)=46</code></p>
</li>
<li><p>map函数：以把一个函数作用到可迭代对象（如列表）的每一个 元素。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">-2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">b=map(<span class="keyword">lambda</span> x: x+<span class="number">2</span>, a)</span><br><span class="line">print(b)	<span class="comment">#b是一个可迭代对象，print得到它的地址，for循环输出可知b=0,3,5</span></span><br><span class="line">c=map(abs, a)</span><br><span class="line">c=list(c)</span><br><span class="line">print(c)	<span class="comment">#c=[2,1,3]</span></span><br><span class="line">d=map(<span class="keyword">lambda</span> x,y: x+y, a,c)</span><br><span class="line">print(list(d))	<span class="comment">#输出[0,2,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter函数：筛选出可迭代对象中满足条件的元素，<code>filter( 返回bool类型的函数, 可迭代对象)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">0</span>, (<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line">print(list(a))		<span class="comment"># [2,5]</span></span><br><span class="line">b=filter(str.isalpha, (<span class="string">'word'</span>,<span class="string">','</span>,<span class="string">'\n'</span>,<span class="string">'$'</span>,<span class="string">'1'</span>))</span><br><span class="line">print(list(b))		<span class="comment"># ['word']</span></span><br><span class="line">c=filter(<span class="literal">None</span>,(<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line">print(list(b))		<span class="comment"># [-1,2,-3,5] 传入None时会把序列中的false值比如0、空值等都去掉</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce函数：对可迭代对象的元素进行递归计算，<code>reduce( 带两个参数的函数, 可迭代对象)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=functools.reduce(operator.add,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br><span class="line">print(a)	<span class="comment">#25</span></span><br><span class="line">b=functools.reduce(<span class="keyword">lambda</span> x,y:x+y,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br><span class="line">print(b)	<span class="comment">#25</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><ol>
<li><p>对第二次作业进行函数封装，按功能封装成几个函数。</p>
<p>这个没啥说的，本来就是用函数写的。</p>
</li>
<li><p>利用map、filter、reduce、lambda函数，对一个元素为数字 字符串的列表，分别求出其中包含的所有奇数的乘积以及所有 偶数的乘积。</p>
<p>思路：首先要把列表<code>l</code>的元素从字符串转成整数，从而才能进行奇偶性判断和乘法运算，这里用<code>map</code>函数来完成；接下来用<code>filter</code>函数就可以把奇数和偶数分别放到两个列表中，最后用<code>reduce</code>函数即可进行乘法运算，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">l=[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'14'</span>,<span class="string">'20'</span>,<span class="string">'5'</span>,<span class="string">'7'</span>,<span class="string">'39'</span>,<span class="string">'150'</span>,<span class="string">'6'</span>]</span><br><span class="line">m=list(map(<span class="keyword">lambda</span> x: int(x), l))</span><br><span class="line">a=filter(<span class="keyword">lambda</span> x: x%<span class="number">2</span>==<span class="number">0</span>, m)</span><br><span class="line">b=functools.reduce(<span class="keyword">lambda</span> x,y:x*y,list(a))</span><br><span class="line">c=filter(<span class="keyword">lambda</span> x: x%<span class="number">2</span>==<span class="number">1</span>, m)</span><br><span class="line">d=functools.reduce(<span class="keyword">lambda</span> x,y:x*y,list(c))</span><br><span class="line">print(<span class="string">'偶数乘积是'</span>,b)</span><br><span class="line">print(<span class="string">'奇数乘积是'</span>,d)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一次作业第三题打印结果为24的表达式，我们通过嵌套循环 得到列表的全排列，试试采用递归函数求全排列。</p>
<p>思路：</p>
<ol>
<li><p>列表只有1个元素时，全排列就是列表本身；</p>
</li>
<li><p>列表有2个元素时，全排列是[a,b]和[b,a]；</p>
</li>
<li><p>列表有n个元素时，将第一个元素固定，对剩下n - 1个元素进行全排列。再将第一个元素依此与其他元素交换，对每次交换后剩下的n-1个元素进行全排列。对n-1个元素的全排列就是一个递归过程。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(l, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start==end:</span><br><span class="line">        print(l)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i = start</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(start, end): </span><br><span class="line">            l[j], l[i] = l[i], l[j]</span><br><span class="line">            permutations(l, start + <span class="number">1</span>, end)</span><br><span class="line">            l[i], l[j] = l[j], l[i]            </span><br><span class="line">num=[<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>]</span><br><span class="line">permutations(num, <span class="number">0</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Privacy Policy in Online Social Network with Targeted Advertising Business</title>
    <url>/2020/04/15/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Privacy-Policy-in-Online-Social-Network-with-Targeted-Advertising-Business/</url>
    <content><![CDATA[<h2 id="在线社交网络隐私政策与定向广告业务"><a href="#在线社交网络隐私政策与定向广告业务" class="headerlink" title="在线社交网络隐私政策与定向广告业务"></a>在线社交网络隐私政策与定向广告业务</h2><a id="more"></a>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ol>
<li>社交网络提供商SNP利用用户信息实现定向投放广告，广告商付费</li>
<li>隐私政策：SNP应该利用的用户信息比例</li>
<li>用户、广告商、SNP——&gt;三阶段stackelberg博弈</li>
<li>更高的信息利用将阻碍用户展示信息，降低被利用信息的总量，并损害广告收入，基于用户信息等级与隐私策略之间的关联，进一步刻画出最优隐私策略。</li>
</ol>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><ol>
<li>广告商决定支付的广告费（更多数据意味着更精准投放——&gt;更高的广告费）：广告商如何在用户信息利用所限制的投放精准度的基础上进行广告投放，以实现预期收益的最大化?</li>
<li>用户决定在社交平台的活跃度（更好的隐私保护——&gt;更活跃）：在隐私受到侵犯的情况下，用户在社交活动中暴露自己的程度如何?</li>
<li>SNP决定隐私政策（广告费和用户活跃度的权衡）：SNP如何采取适当的隐私政策来最大化他的效用，包括社会网络效益和目标广告收入?</li>
</ol>
<h4 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h4><ol>
<li>用户，决定活跃度（在社交平台上发布的信息等级），收益三部分相加组成：<ol>
<li>网络收益：用户在社交平台上进行社交互动所得到的的收益，由用户自己的隐私等级和其他用户的隐私等级共同决定，这部分是一个对数函数（根据梅特卡夫定律决定函数形式）</li>
<li>隐私损失：由【用户提供信息的程度和SNP的隐私等级】对应的函数共同决定（相乘），是一个增函数</li>
<li>补贴：SNP鼓励用户在社交平台积极活跃，会提供固定的补贴，用户有一定概率拿到，拿到的概率由【用户提供信息的程度和SNP的隐私等级】对应的函数共同决定（相乘）</li>
</ol>
</li>
<li>广告商，决定广告费，收益两部分相乘组成：<ol>
<li>一个用户买该产品的净收益（考虑核算收入和生产成本）</li>
<li>目标用户看了广告以后买产品的概率，两部分相加组成：<ol>
<li>由【用户提供信息的程度和SNP的隐私等级】对应的概率</li>
<li>投放不精准的情况下（不能依靠SNP时）的先验概率（就是广告给不感兴趣的人放了之后这个人来买的概率）</li>
</ol>
</li>
<li>上述两部分相乘是一个用户带来的收益，广告商总收益是把所有目标用户的加起来，再减去支付给SNP的广告费</li>
</ol>
</li>
<li>SNP，决定隐私政策和目标广告费，收益三部分相加（减）组成：<ol>
<li>社交网络价值：用户活跃带来的收益，要去掉对用户活跃度的补贴</li>
<li>目标广告收益：单个用户的广告费*目标用户</li>
<li>隐私问题：出现隐私问题时所面临的金钱、名誉损失，有概率，泄露越多损失越大</li>
</ol>
</li>
<li>stackelberg博弈：<ol>
<li>第一阶段SNP考虑用户和广告商的决策来决定隐私等级和广告费</li>
<li>第二阶段用户根据隐私政策决定活跃度</li>
<li>第三阶段广告商根据用户信息和广告费决定是否投放广告</li>
</ol>
</li>
</ol>
<h4 id="Advertiser’s-Decision"><a href="#Advertiser’s-Decision" class="headerlink" title="Advertiser’s Decision"></a>Advertiser’s Decision</h4><ol>
<li>简单的让收益大于广告费，然后显然隐私政策越大（SNP泄露用户信息越多或用户自己暴露越多），广告商越容易挣钱</li>
</ol>
<h4 id="Users’-Behavior"><a href="#Users’-Behavior" class="headerlink" title="Users’ Behavior"></a>Users’ Behavior</h4><ol>
<li>多个用户之间的交互——&gt;多用户信息展示博弈——&gt;纳什均衡：所有用户都收益最大化</li>
<li>信息展示博弈具有超模性：博弈方行为是紧集，收益函数是连续函数且二阶导大于0——&gt;当其他玩家选择更高决策时，该玩家选择更高决策的效用增加得更多——&gt;一个玩家的最佳反应是其他玩家决策的一个非递减函数</li>
<li>所有用户活跃度从0开始，逐个根据其他用户的活跃度调整自己的来最大化收益，直到收敛——&gt;最小纳什均衡</li>
<li>均衡属性分析：<ol>
<li>假设用户效用总的来说是一个凸函数（活跃度越高，活跃度的提高所带来的收益越小，和超模性不冲突）</li>
<li>隐私损失函数是凹函数：越活跃，隐私损失越多</li>
<li>补贴函数是凸函数：越活跃，补贴增长越少</li>
<li>补贴要能弥补隐私损失函数和补贴函数的冲突比例，避免出现大家都是0的场面（从而都是0的场面不是纳什均衡）</li>
<li>处于NE时，隐私政策越高，用户收益越低，存在一个隐私政策阈值，小于这个值（只用很少一部分隐私），用户会选择完全暴露信息（活跃度=1），大于该值，活跃度&lt;1</li>
<li>当隐私政策小于阈值时，【用户提供信息的程度和SNP的隐私等级相乘】随隐私政策增加而增加；大于阈值时，【】随…增加而减小；直接来说就是，用户愿意完全暴露信息时，提取更多信息能更好地服务用户（或者说补贴等等综合下来最好），反之，则隐私提取越少越好了</li>
<li>如果两个用户对社交网络价值的判断相等，那么他们均衡解对应的活跃度也相等；如果不相等，价值判断高的，均衡解时的活跃度也更高；直接说就是，更看重社交价值的会更倾向于高活跃度</li>
</ol>
</li>
</ol>
<h4 id="SNP’s-Decision"><a href="#SNP’s-Decision" class="headerlink" title="SNP’s Decision"></a>SNP’s Decision</h4><ol>
<li>均衡解没有具体形式——&gt;用户均衡解和隐私政策之间的关系来说明SNP效用函数的单调性</li>
<li>广告商收入中的用户数量是离散的，且取决于隐私政策和广告费</li>
<li>将SNP效用函数拆开：<ol>
<li>广告费收益：单个用户广告费*用户个数（由用户活跃度均衡解、隐私政策和单用户广告费共同决定），通过对广告商效用函数的分析，找到固定隐私政策时最优的单用户广告费</li>
<li>社交网络收益—隐私问题：最优广告费作为隐私政策的函数代入，得到最优隐私政策</li>
</ol>
</li>
<li>最优广告费定价问题：<ol>
<li>把用户个数问题转化成了概率问题：广告商有多大概率向某用户投放广告</li>
<li>社交参数简化为两个值：一高一低</li>
</ol>
</li>
<li>隐私问题：<ol>
<li>社交参数依旧只有两个值，对应的均衡解的隐私政策阈值也是两个值</li>
<li>可以推导出效用函数的单调性</li>
<li>假设隐私问题函数是凹函数，广告商效用函数是凸函数，也就是隐私问题越严重，损失增长得会越多，广告商从中得到的收益增长越少——&gt;求导分析找最优隐私政策的特点</li>
</ol>
</li>
</ol>
<h4 id="Numerical-Result"><a href="#Numerical-Result" class="headerlink" title="Numerical Result"></a>Numerical Result</h4><ol>
<li>这部分很少，没说数值实验具体是怎么做的</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>stackelberg game</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-分片相关</title>
    <url>/2020/04/13/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-%E5%88%86%E7%89%87%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>关于区块链分片的几篇论文。</p>
<a id="more"></a>
<h2 id="1-RapidChain-Scaling-Blockchain-via-Full-Sharding"><a href="#1-RapidChain-Scaling-Blockchain-via-Full-Sharding" class="headerlink" title="1. RapidChain: Scaling Blockchain via Full Sharding"></a>1. RapidChain: Scaling Blockchain via Full Sharding</h2><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ol>
<li>分片目的：解除区块链性能和扩展性的限制</li>
<li>分片定义：将处理事务的开销分配给多个更小的节点组，这些组并行工作以最大限度地提高性能，同时显著地减少每个节点的通信、计算和存储，从而允许系统扩展到大型网络。</li>
<li>现有分片协议的问题：扩展性受限制、安全性</li>
<li>本文RapidChain：公链分片</li>
</ol>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><ol>
<li><p>节点分到不同的committees，区块和账本并行</p>
</li>
<li><p>系统中一共<code>n</code>个节点，则每个committee的大小为$m=c logn$，一共有$k=n/m$个committees，<code>c</code>是一个和安全有关的常数</p>
</li>
<li><p>优点：</p>
<ol>
<li>次线性通信：每个事务线性复杂度</li>
<li>高弹性：可以接受<code>1/3</code>的恶意节点</li>
<li>减少每个committee的开销和延迟</li>
<li>安全性：拜占庭容错</li>
<li>跨分片验证：committees通过路由机制发现其他committees</li>
<li>去中心化引导：新加入节点的设计</li>
</ol>
</li>
<li><p>RapidChain按固定时间周期推进，称为epoch，每个epoch结束时由被选中的reference committee（$C_R$)生成下一轮的随机数，该随机数让每个节点在下一轮开始时有新身份，并避免恶意节点的集中和节点共谋</p>
</li>
<li><p>对等发现和committee间的路由，存交易事务$t_x$的committee记作$C_{out}$</p>
</li>
<li><p>跨分片验证：$C_{out}$在生成区块记账之前会和input committee验证交易合法性</p>
</li>
<li><p>分片内共识：</p>
<ol>
<li>分片内成员用当前epoch的随机数选一个临时leader</li>
<li>leader用流言协议把区块发布给分片内所有节点</li>
<li>使用拜占庭协议（基于某论文的同步协议）确保所有节点同意同一个区块</li>
</ol>
</li>
<li><p>重新配置区块：每个epoch结束时由$C_R$产生，包含内容：</p>
<ol>
<li>下一轮的随机数</li>
<li>参与者列表和committee成员</li>
</ol>
<p>想参加下一轮的节点要在一定时间内解题PoW</p>
</li>
<li><p>这篇的related work部分之后可以参考</p>
</li>
</ol>
<h2 id="2-A-Secure-Sharding-Protocol-For-Open-Blockchains"><a href="#2-A-Secure-Sharding-Protocol-For-Open-Blockchains" class="headerlink" title="2. A Secure Sharding Protocol For Open Blockchains"></a>2. A Secure Sharding Protocol For Open Blockchains</h2><h4 id="Abstract-1"><a href="#Abstract-1" class="headerlink" title="Abstract"></a>Abstract</h4><ol>
<li>区块链有安全性，但规模很小，每秒处理3-7笔交易</li>
<li>ELASTICO：1/4拜占庭攻击，分为多个committees，每个处理自己的事务集合（称作分片）</li>
</ol>
<h4 id="Mehtod"><a href="#Mehtod" class="headerlink" title="Mehtod"></a>Mehtod</h4><ol>
<li>按算力分片</li>
<li>每个epoch流程：<ol>
<li>建立自己的公钥、IP并进行PoW，按公钥ID分为不同Committees</li>
<li>节点互相确认身份，记录自己committee有谁</li>
<li>committee内的共识：PBFT，带多数成员签名广播</li>
<li>最终共识广播：有一个final committee来进行合并（PBFT然后把接收的分片区块在committee内实现共识，然后全网广播）</li>
<li>产生下一轮的随机数，大家开始PoW，开始新的一轮</li>
</ol>
</li>
</ol>
<h2 id="3-A-Proof-of-Stake-Sharding-Protocol-for-Scalable-Blockchains"><a href="#3-A-Proof-of-Stake-Sharding-Protocol-for-Scalable-Blockchains" class="headerlink" title="3. A Proof of Stake Sharding Protocol for  Scalable Blockchains"></a>3. A Proof of Stake Sharding Protocol for  Scalable Blockchains</h2><ol>
<li><code>c</code>组，每组<code>n</code>个，一共<code>nc</code>个节点</li>
<li>普通节点组产生中间区块，发送给最终验证节点组</li>
<li>最终验证节点组产生最终区块，全网广播</li>
<li>每个epoch分为4步：<ol>
<li>分组，组内随机选leader，组内节点把身份信息发给leader，leader向其他组的leader广播</li>
<li>组内共识：一个交易随机分到某组，组内节点PoS，产生新的中间区块</li>
<li>最终验证组合并区块，组内PoS，产生最终区块并广播</li>
<li>t轮之后，刷新重组</li>
</ol>
</li>
</ol>
<h2 id="4-Ostraka-Secure-Blockchain-Scaling-by-Node-Sharding"><a href="#4-Ostraka-Secure-Blockchain-Scaling-by-Node-Sharding" class="headerlink" title="4. Ostraka: Secure Blockchain Scaling by Node Sharding"></a>4. Ostraka: Secure Blockchain Scaling by Node Sharding</h2><ol>
<li>采用UTXO、PoS</li>
<li>矿池、UTXO、区块链存储在被称为分片（shard）的几个机器上，机器可以扩展，每个分片的节点数量不一定一样</li>
<li>有一个机器称为 coordinator跟踪区块链并协调节点间的通信，可以要求某分片回滚到某区块链状态或开始新的链</li>
<li>分片有一个ID，由coordinator分配，决定该分片处理哪些事务</li>
<li>女巫分片：节点相同的分片</li>
<li>事务切分存储在对应分片上</li>
<li>总的来说就是有个类似路由器一样的机器来协调处理跨片事务，这篇基本上没看懂，以后有需要再看看</li>
</ol>
<h2 id="5-OptChain-Optimal-Transactions-Placement-for-Scalable-Blockchain-Sharding"><a href="#5-OptChain-Optimal-Transactions-Placement-for-Scalable-Blockchain-Sharding" class="headerlink" title="5. OptChain: Optimal Transactions Placement for Scalable Blockchain Sharding"></a>5. OptChain: Optimal Transactions Placement for Scalable Blockchain Sharding</h2><ol>
<li>新分片方式，最小化跨分片事务，动态事务分配，把相关和即将相关的事务分组到同一分片</li>
<li>对事务分片的依据：<ol>
<li>这样分是否减少了跨片事务</li>
<li>分片间的负载平衡</li>
</ol>
</li>
<li>TaN结构：UTXO模型的事务网络图结构</li>
<li>跨分片事务处理流程：<ol>
<li>用户创建跨分片事务，流言广播</li>
<li>几个UTXO所在的分片锁定UTXO并流言广播许可（或不许可）</li>
<li>接收事务的分片解锁UTXO并记账</li>
</ol>
</li>
<li>对事务分片的算法：<ol>
<li>TaN：把UTXO事务看做图里的节点，然后按图的拓扑结构分析出度和入度</li>
<li>T2S：用PageRank评分，判断节点加入哪个分片——&gt;尽可能减少跨分片事务</li>
<li>L2S：确认延迟，网络结构决定事务得到确认所需的时间——&gt;尽可能加快事务确认速度</li>
<li>T2S和L2S结合选择事务分片</li>
</ol>
</li>
</ol>
<h2 id="6-Poster-A-Proof-of-Stake-PoS-Blockchain-Protocol-using-Fair-and-Dynamic-Sharding-Management"><a href="#6-Poster-A-Proof-of-Stake-PoS-Blockchain-Protocol-using-Fair-and-Dynamic-Sharding-Management" class="headerlink" title="6. Poster: A Proof-of-Stake(PoS) Blockchain Protocol using Fair and Dynamic Sharding Management"></a>6. Poster: A Proof-of-Stake(PoS) Blockchain Protocol using Fair and Dynamic Sharding Management</h2><ol>
<li>每个epoch会重新分片并选择每个分片的block producers</li>
<li>在上一个epoch中，users用自己的信息和一部分资产注册成为validator（验证器），这个epoch开始以后，validator和事务被分成k个分片，分片规则为：<ol>
<li>验证器的地址和上一个区块的哈希值一起哈希然后对分片个数取余，即可得到验证器的分片</li>
<li>事务地址和…，即可得到事务的分片</li>
</ol>
</li>
<li>使用BFT-DPoS算法，在每个分片内选block producers：<ol>
<li>股权最大的成为该分片的producer</li>
<li>所有producers按顺序循环选总的producer</li>
<li>矿工可以投出与他们所持股份的平方根成比例的选票，而不是与所持股份成线性比例的选票。</li>
<li>根据BFT算法，分片的producer产生自己分片的区块，并由总producer合并广播</li>
</ol>
</li>
</ol>
<h2 id="7-SSChain-A-full-sharding-protocol-for-public-blockchain-without-data-migration-overhead"><a href="#7-SSChain-A-full-sharding-protocol-for-public-blockchain-without-data-migration-overhead" class="headerlink" title="7. SSChain: A full sharding protocol for public blockchain  without data migration overhead"></a>7. SSChain: A full sharding protocol for public blockchain  without data migration overhead</h2><ol>
<li><p>公链，拜占庭弹性，对事务分片和对状态分片，节点无需定期切换分片（避免数据冗余），使用UTXO</p>
</li>
<li><p>节点可以自由加入分片而无需刷新，为避免随之而来的51%攻击问题，本文提出了一个双层结构：</p>
<ol>
<li>根链验证分片的区块，避免恶意节点攻击，激励机制保证矿工愿意加入</li>
<li>分片维护不相交的分类帐并独立处理不相交的交易子集。</li>
<li>SSChain背后的关键思想是根链维护系统的安全性，而切分提高了吞吐量并减少了存储需求。</li>
</ol>
</li>
<li><p>同一分片内的交易有更低的确认延迟和更少的交易费用，进而鼓励用户片内交易</p>
</li>
<li><p>解耦事务验证和状态更新，拆分跨分片事务</p>
</li>
<li><p>激励机制：动态调节根链和分片的算力分配，根据参数可得到不同的吞吐量和安全性</p>
</li>
<li><p>跨分片事务：切分成分片内事务，或者由根链处理</p>
</li>
<li><p>根链：PoW，分类帐修剪机制</p>
</li>
<li><p>事务分片：</p>
<ol>
<li>事务地址包含比特币地址和分片ID</li>
<li>交易分类：<ol>
<li>inputs和outputs在一个分片内</li>
<li>inputs在一个分片内，outputs在不同分片</li>
<li>都在不同分片</li>
</ol>
</li>
<li>跨分片事务：<ol>
<li>交给根链——&gt;随分片增长会很难处理</li>
<li>鼓励用户在同一分片内创建新地址——&gt;跨分片变成同一分片</li>
<li>A+B——&gt;C的事务拆分成A——&gt;C和B——&gt;C（个人感觉这没用啊）</li>
</ol>
</li>
</ol>
</li>
<li><p>状态分片：一些节点储存整个区块链的状态而不是只存分片状态</p>
</li>
<li><p>市场激励机制：动态地调整切分和根链之间的哈希功率分配。在激励机制下，矿商可以自由选择最赚钱的碎片，从而避免了周期性的网络重组。有两个目的：</p>
<ol>
<li>为了维护系统安全，根链占用了整个网络的很大一部分算力。由于切分块是由根链网络验证的，恶意对手至少需要根链哈希能力的一半才能进行双倍开销攻击。</li>
<li>算力被鼓励平均分配到碎片中，这样每个碎片都可以正常工作。</li>
</ol>
</li>
</ol>
<h2 id="8-Trust-Based-Shard-Distribution-Scheme-for-Fault-Tolerant-Shard-Blockchain-Networks"><a href="#8-Trust-Based-Shard-Distribution-Scheme-for-Fault-Tolerant-Shard-Blockchain-Networks" class="headerlink" title="8. Trust-Based Shard Distribution Scheme for Fault-Tolerant Shard Blockchain Networks"></a>8. Trust-Based Shard Distribution Scheme for Fault-Tolerant Shard Blockchain Networks</h2><ol>
<li>TBSD：把恶意节点放到不同的分片，使用信任管理系统和遗传算法</li>
<li>定量衡量节点的信任度，对恶意节点进行信用惩罚</li>
<li>遗传算法找到最优分片方法，使得每个分片的信用度都差不多</li>
<li>总的来说信用系统分为5步：<ol>
<li>每一轮开始时，PoS选一个leader出块</li>
<li>全网广播验证区块，少数服从多数</li>
<li>SCO：节点信用表，由验证节点产生，上一步的验证结果作为信用评分的依据</li>
<li>LCR：根据SCO计算得到的相对信用分布矩阵</li>
<li>最终信用评估</li>
</ol>
</li>
<li>攻击模型：<ol>
<li>恶意节点成为leader</li>
<li>节点共谋</li>
<li>恶意节点行为不一致，一会儿诚实一会儿恶意</li>
</ol>
</li>
<li>分片过程：用GA</li>
</ol>
<h2 id="9-Two-Phase-Cooperative-Bargaining-Game-Approach-for-Shard-Based-Blockchain-Consensus-Scheme"><a href="#9-Two-Phase-Cooperative-Bargaining-Game-Approach-for-Shard-Based-Blockchain-Consensus-Scheme" class="headerlink" title="9. Two-Phase Cooperative Bargaining Game Approach for Shard-Based Blockchain Consensus Scheme"></a>9. Two-Phase Cooperative Bargaining Game Approach for Shard-Based Blockchain Consensus Scheme</h2><ol>
<li>分片后，进行议价博弈，事务总的来说平分给每个分片处理</li>
<li>有一个adjust shard负责确认，其他分片进行普通的挖矿</li>
<li>随机数分片，分片内共识：标准拜占庭一致协议，看起来是对节点分片</li>
<li>节点验证事务和参与共识的过程可看做两阶段博弈：<ol>
<li>事务分配问题</li>
<li>基于分片的共识机制</li>
</ol>
</li>
<li>讨价还价博弈这里没完全看懂，感觉就是分片和节点根据奖励和支出决定是否处理事务，上面的4.1里博弈方是分片，4.2的博弈方是区块链节点</li>
</ol>
<h2 id="A-Node-Rating-Based-Sharding-Scheme-for-Blockchain"><a href="#A-Node-Rating-Based-Sharding-Scheme-for-Blockchain" class="headerlink" title="A Node Rating Based Sharding Scheme for Blockchain"></a>A Node Rating Based Sharding Scheme for Blockchain</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Monoxide: Scale Out Blockchain with Asynchronous Consensus Zones</title>
    <url>/2020/04/07/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Monoxide%20Scale%20Out%20Blockchain%20with%20Asynchronous%20Consensus%20Zones/</url>
    <content><![CDATA[<h2 id="突破区块链不可能三角异步共识组"><a href="#突破区块链不可能三角异步共识组" class="headerlink" title="突破区块链不可能三角异步共识组"></a>突破区块链不可能三角异步共识组</h2><p>这篇没看完。</p>
<a id="more"></a>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ol>
<li>背景：加密货币在匿名在线支付方面很重要</li>
<li>问题：<ol>
<li>随用户和交易的增长，低吞吐量阻碍加密货币系统的扩展</li>
<li>每个节点复制整个网络的通信、存储和状态表示也阻碍了系统的扩展</li>
</ol>
</li>
<li>本文：<ol>
<li>Asynchronous Consensus Zones（异步一致网络）：分区域，不影响去中心化和安全性，每个区域独立并行，块内共识；</li>
<li>诸葛连弩系统：使得攻击单独的一个块的难度和攻击整个区块的难度一样大</li>
</ol>
</li>
</ol>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol>
<li>TPS（每秒交易数）很低的原因在于区块按顺序建立，而网络延迟导致广播时间不能过短</li>
<li>每一个完整的节点都需要复制整个网络的通信、存储和状态表示，系统受限于硬件设备而无法扩展</li>
<li>综上可扩展的区块链要考虑：<ol>
<li>共识协议的可扩展性</li>
<li>通信、存储、计算和内存的资源使用</li>
<li>去中心化和安全性</li>
</ol>
</li>
<li>以太坊已提出分片的设计</li>
<li>本文异步一致网络：<ol>
<li>分区域，通过在多个独立和并行实例(或一致区域)中划分和处理工作负载来扩展区块链系统</li>
<li>整个网络划分为区域，每个区域负责自己那部分，只在区域内复制，挖矿竞争和交易确认等在区块间异步进行</li>
<li>挑战在于：<ol>
<li>跨区域事务的吞吐量</li>
<li>诚实矿工稀释带来的安全性问题</li>
</ol>
</li>
</ol>
</li>
<li>本文最终原子确认：跨区域事务由原子性分解为多个事务，每个事务涉及单独一个区域</li>
<li>本文诸葛连弩：矿工挖矿成功时可以在不同的区域里创建多个区块，其算力平均分配到各个区域，而攻击者的攻击算力同样也被分到了不同区域，因此攻击单独一个区域和攻击整个系统难度一样</li>
</ol>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>对比PoS和PoW，UTXO和账户余额</p>
<ol>
<li>影响区块链系统和共识协议性能的因素：一致性（共识）、通信、存储、表示</li>
<li>PoW耗费算力来竞争记账权，但是加密货币一定程度上有对应现实世界的价值；PoS由节点的股权（财富）来决定区块的产生；本文用PoW，但改PoS也行</li>
<li>加密货币有两种交易模型，UTXO和账户余额，以太坊用了后者（更支持智能合约），本文也用了后者，总之账户余额模型有很多优点</li>
</ol>
<h3 id="System-Design"><a href="#System-Design" class="headerlink" title="System Design"></a>System Design</h3><ol>
<li><p>跨区域事务的执行：</p>
<ol>
<li>区域A执行检查余额然后取钱（ withdraw operation），下一个该区域的区块就会更新余额状态等</li>
<li>区域A把存钱（ deposit operation ）打包成一个中继操作（ relay transaction ）发给区域B</li>
<li>区域B执行存钱操作，不需要检查余额</li>
<li>取钱只涉及区域A，存钱只涉及区域B，因此不需要进行区域间的确认等</li>
</ol>
</li>
<li><p>划分和命名（Partitioning and Naming）：</p>
<ol>
<li>用户地址被均匀划分为$2^k$个区域，一个区域由它的分片尺度k和区域索引s来识别</li>
<li>群swarm：参与相同数据集的复制的一组节点。全节点加入群从而广播信息和接收其他全节点的信息。比特币和以太坊系统只有一个群，大家都保存同样的信息。</li>
<li>本文有多个出于不同目的建立的群，采用分布式哈希表(DHT)进行群寻址和对等发现。</li>
<li>系统中有一个包含所有全节点的全局群，用于复制所有区域的最小公共信息。</li>
<li>在每个群内，全节点稀疏分布，使用gossip protocol广播信息</li>
<li>区域特定的群也用分片尺度k和区域索引s来识别</li>
</ol>
</li>
<li><p>单独一个区域：区域间计算和事务相互隔离、独立并行，随网络增长会创建新区域</p>
<ol>
<li>全节点或矿工有特定标识符来决定在哪个区域内工作</li>
<li>每个区域有自己的区块链</li>
<li>矿工只与同区域的PoW竞争记账权</li>
<li>全节点会忽略其他区域的事务消息</li>
</ol>
</li>
<li><p>最小化跨区域开销：</p>
<ol>
<li>系统在每个节点上维护一个分布式哈希表(DHT)</li>
<li>大多数通信用于复制未经确认的事务，并广播带有已确认事务的新块</li>
<li>获取未确认事务或新块对应的区域索引s后，系统在DHT中选择索引相同的节点，通过gossip protocol把事务和区块发给它们。</li>
<li>只把中继事务发给对应区域，而不是全网广播</li>
<li>用于形成链的最小化数据会被复制到所有区域（下一部分讨论）</li>
</ol>
<h3 id="Efﬁcient-Cross-Zone-Atomicity"><a href="#Efﬁcient-Cross-Zone-Atomicity" class="headerlink" title="Efﬁcient Cross-Zone Atomicity"></a>Efﬁcient Cross-Zone Atomicity</h3><ol>
<li>事务分为取钱（relay）和存钱（deposit）操作，分别在对应的区域进行验证</li>
<li>为避免分叉出现的问题：<ol>
<li>取钱验证一次</li>
<li>存钱验证一次</li>
<li>中继操作隔一定数量的区块后才被打包</li>
</ol>
</li>
</ol>
<h3 id="Defense-Per-Zone-Security"><a href="#Defense-Per-Zone-Security" class="headerlink" title="Defense Per-Zone Security"></a>Defense Per-Zone Security</h3><ol>
<li>允许矿工完成一次PoW在多个区域建立多个区块（区块网？），每个区域只能建立一个</li>
<li>参与诸葛连弩的矿工的算力没被稀释，这样攻击单独一个区域所需的算力仍然是50%</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-6</title>
    <url>/2020/04/01/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-6/</url>
    <content><![CDATA[<p>这一课讲第三方库的安装和使用，然后用<code>wordcloud</code>和<code>jieba</code>生成词云图和中文分词。没有课堂练习，只有一个在上次作业基础上的作业。</p>
<p>我是直接<code>pip</code>安装的，在安装<code>wordcloud</code>时，<code>pip install wordcloud</code>很快就装好了，但是<code>jieba</code>反复出错，最后指定清华镜像，<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jieba</code>，这样就飞快地安装好了。</p>
<a id="more"></a>
<h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><p>(4) 利用<code>wordcloud</code>结合<code>jieba</code>分别对李白（杜甫）诗歌内容中的字和词语进行可视化。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>上节课的作业完成后已经得到了处理好的诗歌字符串和字频统计<code>Counter</code>，那么接下来就可以用这两个变量来得到对应的词云图。</p>
<p>用<code>fit_words()</code>函数根据已经得到的计数器<code>poems_counter</code>生成的字典来制作字频的词云图片，用<code>generate()</code>函数对用<code>jieba</code>进行分词之后的<code>poems_text</code>生成词频的词云图片。在保存图片后可以用<code>PIL</code>中的<code>Image.open()</code>和<code>show()</code>来显示图片。对应的函数代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_character</span><span class="params">(poems_counter, name)</span>:</span></span><br><span class="line">    dict_character = dict(poems_counter)</span><br><span class="line">    <span class="comment"># 生成图像对应的遮罩，这样词云图就是按图像里非白色区域来填充的</span></span><br><span class="line">    mask = np.array(Image.open(name + <span class="string">'.jpg'</span>))</span><br><span class="line">    <span class="comment"># 根据图像生成颜色表，这样词云图的颜色就和图像一致了</span></span><br><span class="line">    color = wordcloud.ImageColorGenerator(mask)</span><br><span class="line">    <span class="comment"># 生成词云图变量，背景白色，random_state的值影响字在图中的分布，color_func设定词云颜色，mask设定图像遮罩，font_path指定字体，不指定的话中文没法显示</span></span><br><span class="line">    wc = wordcloud.WordCloud(background_color=<span class="string">"white"</span>, random_state=<span class="number">42</span>, color_func=color, mask=mask, font_path=<span class="string">'C:\Windows\Fonts\simsun.ttc'</span>)</span><br><span class="line">    <span class="comment"># 根据字典生成词云图的内容</span></span><br><span class="line">    wc.fit_words(dict_character)</span><br><span class="line">    <span class="comment"># 保存词云图</span></span><br><span class="line">    wc.to_file(name + <span class="string">"cloud_character.png"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_word</span><span class="params">(poems_text, name)</span>:</span></span><br><span class="line">    text = <span class="string">' '</span>.join(jieba.cut(poems_text))</span><br><span class="line">    mask = np.array(Image.open(name + <span class="string">'.jpg'</span>))</span><br><span class="line">    color = wordcloud.ImageColorGenerator(mask)</span><br><span class="line">    wc = wordcloud.WordCloud(background_color=<span class="string">"white"</span>, random_state=<span class="number">42</span>, color_func=color, mask=mask, font_path=<span class="string">'C:\Windows\Fonts\simsun.ttc'</span>)</span><br><span class="line">    <span class="comment"># 根据文本字符串生成词云图的内容</span></span><br><span class="line">    wc.generate(text)</span><br><span class="line">    wc.to_file(name + <span class="string">"cloud_word.png"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_pic</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 打开图像</span></span><br><span class="line">    img1 = Image.open(name + <span class="string">"cloud_character.png"</span>)</span><br><span class="line">    img2 = Image.open(name + <span class="string">"cloud_word.png"</span>)</span><br><span class="line">    <span class="comment"># 显示图像</span></span><br><span class="line">    img1.show()</span><br><span class="line">    img2.show()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序部分</span></span><br><span class="line">cloud_character(counter_libai, <span class="string">'libai'</span>)</span><br><span class="line">cloud_character(counter_dufu, <span class="string">'dufu'</span>)</span><br><span class="line">cloud_word(text_libai, <span class="string">'libai'</span>)</span><br><span class="line">cloud_word(text_dufu, <span class="string">'dufu'</span>)</span><br><span class="line">show_pic(<span class="string">"libai"</span>)</span><br><span class="line">show_pic(<span class="string">"dufu"</span>)</span><br></pre></td></tr></table></figure>
<p>（最后生成的词云图是真的怪怪的……）</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-5</title>
    <url>/2020/03/31/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-5/</url>
    <content><![CDATA[<p>这一课讲的是字典和集合。</p>
<a id="more"></a>
<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ol>
<li><p>对于下列财经数据<code>lst</code>，如何构造公司代码和股票价格的字典<code>d</code>？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst=[(<span class="string">'AXP'</span>,<span class="string">'American Epress Company'</span>,<span class="string">'86.40'</span>),</span><br><span class="line">	(<span class="string">'BA'</span>,<span class="string">'The Boeing Company'</span>,<span class="string">'22.64'</span>),</span><br><span class="line">	(<span class="string">'CAT'</span>,<span class="string">'Caterpillar Inc.'</span>,<span class="string">'99.44'</span>),</span><br><span class="line">	(<span class="string">'CSCO'</span>,<span class="string">'Cisco System Inc.'</span>,<span class="string">'23.78'</span>),</span><br><span class="line">	(<span class="string">'CVX'</span>,<span class="string">'Chevron Corporation'</span>,<span class="string">'115.91'</span>)]</span><br><span class="line">d=&#123;<span class="string">'AXP'</span>:<span class="string">'86.40'</span>,<span class="string">'BA'</span>:<span class="string">'122.64'</span>,<span class="string">'CAT'</span>:<span class="string">'99.44'</span>,<span class="string">'CSCO'</span>:<span class="string">'23.78'</span>,<span class="string">'CVX'</span>:<span class="string">'115.91'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>答案：从列表构造字典，根据定义可以直接使用<code>d={a:c for a,b,c in lst}</code></p>
</li>
<li><p>如何把一个字典中的<code>key</code>和<code>value</code>互换？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=&#123;<span class="string">'blue'</span>:<span class="number">500</span>, <span class="string">'green'</span>:<span class="number">300</span>, <span class="string">'red'</span>:<span class="number">100</span>&#125;</span><br><span class="line">&#123;<span class="number">100</span>:<span class="string">'red'</span>, <span class="number">300</span>:<span class="string">'green'</span>, <span class="number">500</span>:<span class="string">'blue'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>答案：使用<code>items</code>属性即可，<code>new_d={value:key for key, value in d.items()}</code></p>
</li>
</ol>
<h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><ol>
<li>利用内置数据类型对李白和杜甫的诗歌进行分析，包括：</li>
</ol>
<p>(1)读入李白.txt，得到李白诗歌内容中的所有的汉字，并进一步得到其中的不重复汉字，最后打印所有汉字的个数、不重复汉字的个数、以及不重复汉字，打印汉字时要求每行10个汉字，汉字之间以2个空格分开。</p>
<p>(2)进一步利用字典进行李白诗歌的字频统计，即统计每个字出现的次数，并对字频进行归一化处理（即除以诗歌篇数），然后输出显示字频统计结果，输出显示时根据字频降序排列，只打印频率大于等于0.1的结果，并注意对齐。</p>
<p>(3)采用同上述相同的方法，得到杜甫诗歌的字频统计结果。在此基础上获得李白和杜甫的高频词集合（即频率大于等于0.1的汉字集合），利用集合操作进一步获得两位诗人都爱用的字、李白爱用但杜甫不爱用的字以及杜甫爱用而李白不爱用的字，并输出上述结果，输出时每行10个单词，汉字之间以2个空格分开。</p>
<p>说明：统计时不考虑题目、朝代、作者，只考虑诗歌内容。</p>
<p>作业思路：</p>
<p>首先是要读取txt文件，这里作业提示说用下述代码来读取文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'李白.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    poems_text = f.read()</span><br></pre></td></tr></table></figure>
<p>此时整个文件的内容作为字符串存在<code>poems_text</code>中，并且每首诗之间有换行符，因此使用<code>poems_list = poems_text.splitlines()</code>将每首诗作为列表<code>poems_list</code>中的元素（字符串）存储。</p>
<p>接下来遍历列表元素，因为每首诗格式都是“标题 朝代 作者 诗歌内容”这样，所以对每个字符串查找作者名字，并只留存作者名字之后的字符串内容，就可以得到我们需要统计的诗歌内容，再去掉中文标点、英文标点和空格，就得到了一个处理好的诗歌内容列表，这部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(poems_list)):</span><br><span class="line">    index = poems_list[i].find(name)</span><br><span class="line">    poems_list[i] = poems_list[i][index + <span class="number">3</span>:]</span><br><span class="line">    poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, zhon.hanzi.punctuation))</span><br><span class="line">    poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.punctuation))</span><br><span class="line">    poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, <span class="string">' '</span>))</span><br></pre></td></tr></table></figure>
<p>这时<code>poems_num = len(poems_list)</code>即可得到诗歌总数，<code>poems_text = &#39;&#39;.join(poems_list)</code>即可得到处理好之后的字符串。然后进行统计。</p>
<p>我们使用<code>poems_counter = collections.Counter(poems_text)</code>可以得到一个<code>Counter</code>计数器，该计数器是一个字典，<code>key</code> 是字，<code>val</code>是该字出现的次数，按出现次数遍历这个计数器，并把<code>key</code>加入到集合<code>poems_set</code>中，当字频（<code>val/poems_num</code>）低于0.1时，break结束遍历，这样就得到了高频字的集合，这部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">    <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    poems_set.add(key)</span><br></pre></td></tr></table></figure>
<p>接下来通过集合运算就可以得到李白和杜甫的交集和差集了。</p>
<p>关于格式化输出，首先是输出诗歌本身的字数、不重复字数和不重复字，每10个换行，字中间是两个空格，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(name + <span class="string">'诗词中总共有'</span> + str(len(poems_text)) + <span class="string">'个汉字，其中不重复的汉字有'</span> + str(len(poems_counter)) + <span class="string">'个，具体如下：'</span>)</span><br><span class="line">print_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> poems_counter:</span><br><span class="line">    print(key, end=<span class="string">'  '</span>)</span><br><span class="line">    print_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        print()</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>
<p>接下来是字频统计的输出，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'字频统计信息如下：\n汉字---频率'</span>)</span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">    <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'&#123;&#125;\t &#123;&#125;'</span>.format(key, val / poems_num))</span><br></pre></td></tr></table></figure>
<p>最后是字频集合的输出，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> set:</span><br><span class="line">    print(i, end=<span class="string">'  '</span>)</span><br><span class="line">    print_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        print()</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>
<p>整体代码我把诗歌的预处理部分作为一个函数、诗歌输出作为一个函数、集合输出作为一个函数，最后主函数调用它们。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> zhon.hanzi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poems</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(name + <span class="string">'.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        poems_text = f.read()</span><br><span class="line">    poems_list = poems_text.splitlines()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(poems_list)):</span><br><span class="line">        index = poems_list[i].find(name)</span><br><span class="line">        poems_list[i] = poems_list[i][index + <span class="number">3</span>:]</span><br><span class="line">        poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, zhon.hanzi.punctuation))</span><br><span class="line">        poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.punctuation))</span><br><span class="line">        poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, <span class="string">' '</span>))</span><br><span class="line">    poems_num = len(poems_list)</span><br><span class="line">    poems_text = <span class="string">''</span>.join(poems_list)</span><br><span class="line">    poems_counter = collections.Counter(poems_text)</span><br><span class="line">    poems_set = set()</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">        <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        poems_set.add(key)</span><br><span class="line">    <span class="keyword">return</span> poems_num, poems_text, poems_counter, poems_set</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_poem</span><span class="params">(name, poems_num, poems_text, poems_counter)</span>:</span></span><br><span class="line">    print(name + <span class="string">'诗词中总共有'</span> + str(len(poems_text)) + <span class="string">'个汉字，其中不重复的汉字有'</span> + str(len(poems_counter)) + <span class="string">'个，具体如下：'</span>)</span><br><span class="line">    print_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> poems_counter:</span><br><span class="line">        print(key, end=<span class="string">'  '</span>)</span><br><span class="line">        print_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            print()</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">'字频统计信息如下：\n汉字---频率'</span>)</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">        <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'&#123;&#125;\t &#123;&#125;'</span>.format(key, val / poems_num))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_set</span><span class="params">(set)</span>:</span></span><br><span class="line">    print_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> set:</span><br><span class="line">        print(i, end=<span class="string">'  '</span>)</span><br><span class="line">        print_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            print()</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_libai, text_libai, counter_libai, set_libai = poems(<span class="string">'李白'</span>)</span><br><span class="line">num_dufu, text_dufu, counter_dufu, set_dufu = poems(<span class="string">'杜甫'</span>)</span><br><span class="line">print_poem(<span class="string">'李白'</span>, num_libai, text_libai, counter_libai)</span><br><span class="line">print_poem(<span class="string">'杜甫'</span>, num_dufu, text_dufu, counter_dufu)</span><br><span class="line">s_both_love = set_libai &amp; set_dufu</span><br><span class="line">s_only_libai = set_libai - set_dufu</span><br><span class="line">s_only_dufu = set_dufu - set_libai</span><br><span class="line">print(<span class="string">'两位诗人都爱用的字有'</span> + str(len(s_both_love)) + <span class="string">'个，这些字为：'</span>)</span><br><span class="line">print_set(s_both_love)</span><br><span class="line">print(<span class="string">'李白爱用但杜甫不爱用的字有'</span>+str(len(s_only_libai))+<span class="string">'个，这些字为：'</span>)</span><br><span class="line">print_set(s_only_libai)</span><br><span class="line">print(<span class="string">'杜甫爱用但李白不爱用的字有'</span>+str(len(s_only_libai))+<span class="string">'个，这些字为：'</span>)</span><br><span class="line">print_set(s_only_dufu)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-4</title>
    <url>/2020/03/23/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-4/</url>
    <content><![CDATA[<p>这一课是讲字符串的，主要是几种字符串函数。</p>
<a id="more"></a>
<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ol>
<li><p>下面代码的运行结果是（）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">	print(i)</span><br><span class="line">	s.remove(i)</span><br></pre></td></tr></table></figure>
<p>A. 1 2 3 4 5（一个数字一行）</p>
<p>B. 1 3 5（一个数字一行）</p>
<p>答案：显然这里<code>s</code>是个列表，列表的<code>remove()</code>函数的作用是移除指定元素，只移除匹配到的第一个。按顺序看，最初列表是<code>s=[1,2,3,4,5]</code>，<code>for</code>循环访问列表的第一个元素，并输出<code>1</code>，接着移除<code>1</code>，这之后列表<code>s</code>的元素会整体往前挪一位，变成<code>s=[2,3,4,5]</code>，此时第一个元素变成<code>2</code>，第二个元素变成<code>3</code>，而<code>for</code>循环会去找列表的第二个元素，也就是跳过<code>2</code>访问<code>3</code>，输出并移除，变成<code>s=[2,4,5]</code>，然后输出并移除第三个元素<code>5</code>。</p>
<p>所以最后输出的是<code>1 3 5</code>，选B。</p>
</li>
<li><p>下列操作的结果是（）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">'!..Hi!!!.'</span></span><br><span class="line">s.strip(<span class="string">'!.'</span>)</span><br></pre></td></tr></table></figure>
<p>A. ‘.Hi!!!’        B. ‘.Hi!!!.’        C. ‘!..Hi!!’        D. ‘Hi’</p>
<p>答案：字符串的<code>strip</code>函数是移除字符串左右两边的指定字符元素，如果没指定就移除空格，然后遇到第一个不是指定元素的时候就停止移除操作，并且指定元素不会连起来看，也就是这里的<code>!</code>和<code>.</code>是会被看做两个元素，而不是一个完整的字符串，因此移除的时候并不是找连续的<code>!.</code>，而是移除左右两边所有<code>!</code>和<code>.</code>，也就是选D。</p>
</li>
<li><p>用一行代码把字符串<code>s=&#39;  abcdbacbaab&#39;</code>中的<code>b</code>去掉。</p>
<p>答案：首先可以用字符串中的翻译函数，将所有<code>b</code>翻译成空字符，也就是<code>s.translate(str.maketrans(&#39;&#39;, &#39;&#39;,&#39;b&#39;))</code>。最直接的方法是用字符串的<code>replace</code>函数，将<code>b</code>替换成空字符，即<code>s=s.replace(&#39;b&#39;,&#39;&#39;)</code>。</p>
</li>
<li><p>判断两个单词s1和s2是否构成字谜：即s1和s2的字母和个数相同，只是顺序不同，如cinema何iceman，要求只用一行代码。</p>
<p>答案：如果不要求只用一行代码，那办法有很多了，现在要求只用一行代码，因此只能采用字符串的<code>sorted()</code>函数，该函数会返回一个排好序的字符串，因此可以通过<code>sorted(s1)==sorted(s2)</code>来判断两个字符串是否构成字谜。</p>
</li>
<li><p>如何将<code>s=&#39;d,f,a,c,b,d,g,e,a,f&#39;</code>中的字母进行排序，得到新的字符串<code>s=&#39;a,a,b,c,d,d,e,f,f,g&#39;</code>？</p>
<p>答案：直接来说就是要把原字符串中的<code>,</code>去掉，剩下的字符串按字母顺序排序，然后再把<code>,</code>加回来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">'d,f,a,c,b,d,g,e,a,f'</span> </span><br><span class="line">s1=s.replace(<span class="string">','</span>,<span class="string">''</span>) </span><br><span class="line">s2=sorted(s1) </span><br><span class="line"><span class="string">','</span>.join(s2)</span><br></pre></td></tr></table></figure>
<h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><ol>
<li><p>在第一课练习的基础上，判断一个字符串是否是回文串（规则更宽松）：</p>
<p>例如：Madam, I’m Adam                 True</p>
<p>A man, a plan, a canal, Panama!                True</p>
<p>客上天然居，居然天上客.                True</p>
<p>答案：我的思路是把字符串里所有的标点和空格去掉，然后把所有字母都转成小写字母，最后用之前写好的函数来判断字符串是否是回文串。 <code>string.punctuation</code>中存有所有标点符号，因此可以将字符串中所有的<code>string.punctuation</code>替换成空字符，从而去掉标点；空格同理；<code>casefold()</code>函数可以使字符串中所有的字符都变成小写。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindromic4</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num == num[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_space_punc</span><span class="params">(s)</span>:</span></span><br><span class="line">    s_1=s.translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.punctuation))</span><br><span class="line">    s_2=s_1.translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, <span class="string">' '</span>))</span><br><span class="line">    s_3=s_2.casefold()</span><br><span class="line">    <span class="keyword">return</span> s_3</span><br><span class="line">    </span><br><span class="line">s1 = <span class="string">"Madam, I'm Adam"</span></span><br><span class="line">s2 = <span class="string">"A man, a plan, a canal, Panama!"</span></span><br><span class="line">s3 = <span class="string">"客上天然居，居然天上客."</span></span><br><span class="line"></span><br><span class="line">print(is_palindromic4(del_space_punc(s1)))</span><br><span class="line">print(is_palindromic4(del_space_punc(s2)))</span><br><span class="line">print(is_palindromic4(del_space_punc(s3)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入一个字符串a和字符串b，查找b在a中的所有位置并输出显示。</p>
<p>例如：请输入一个字符串：abcdeabcdeab</p>
<p>请输入另一个字符串：ab</p>
<p>输出0 5 10</p>
<p>答案：直接一些的想法是遍历字符串检索<code>a</code>，然后看下一个字符是否是<code>b</code>，不过百度之后发现可以直接用正则匹配，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = input(<span class="string">'请输入一个字符串：'</span>)</span><br><span class="line">b = input(<span class="string">'请输入另一个字符串：'</span>)</span><br><span class="line">print([i.start() <span class="keyword">for</span> i <span class="keyword">in</span> re.finditer(b,a)])</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计一篇文章（看成一个长字符串）中单词的个数，以及文章中不同单词的个数及列表，最后输出显示。（备注：单词的不同时态 以及单复数都看成是不同的单词）。字符串为变量speech，<code>speech=&#39;&#39;&#39;  Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal. Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this. But, in a larger sense, we can not dedicate -- we can not consecrate -- we can not hallow -- this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us -- that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion -- that we here highly resolve that these dead shall not have died in vain -that this nation, under God, shall have a new birth of freedom -- and that government of the people, by the people, for the people, shall not perish from the earth.&#39;&#39;&#39;</code></p>
<p>答案：受上一题的影响，这里也考虑用正则匹配来判断有多少个单词，并把单词放到一个列表中，再根据列表建立字典从而输出词频。统计词频可以用<code>collections.Counter</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">speech=<span class="string">'''  Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal. Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this. But, in a larger sense, we can not dedicate -- we can not consecrate -- we can not hallow -- this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us -- that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion -- that we here highly resolve that these dead shall not have died in vain -that this nation, under God, shall have a new birth of freedom -- and that government of the people, by the people, for the people, shall not perish from the earth.'''</span></span><br><span class="line">words=re.findall(<span class="string">r'[a-zA-Z]+'</span>,speech)</span><br><span class="line">count=len(words)</span><br><span class="line">print(<span class="string">'单词出现次数：'</span>,count)</span><br><span class="line">list2 = collections.Counter(words)</span><br><span class="line">print(dict(list2))</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-8</title>
    <url>/2020/03/23/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-8/</url>
    <content><![CDATA[<p>还没开始看，看完再写。</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-7</title>
    <url>/2020/03/15/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-7/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part7/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/02/02/lets-build-a-simple-interpreter-part-07/" target="_blank" rel="noopener">翻译</a></p>
<p>（这次翻译又出现了一些不影响理解的小问题。课程代码越来越长，我决定改一下文档结构，不在一开始放整块代码了。）</p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课的知识点格外多。</p>
<h4 id="抽象语法树和解析树"><a href="#抽象语法树和解析树" class="headerlink" title="抽象语法树和解析树"></a>抽象语法树和解析树</h4><ol>
<li><p>在之前的代码中，词法分析结束后进行语法分析的同时就完成了运算，这种 interpreter 被称为语法导向解释器 (syntax-directed interpreter)，对于更复杂的语法结构，我们需要建立一个中间表示（intermediate representation, IR），我们的 parser 会 负责构建 IR 而 interpreter 会用来解释由 IR 所代表的输入。一般来说会用树来构建IR。</p>
</li>
<li><p>解析树（有时叫做具体语法树）是一个根据我们的语法定义来表示一门语言的句法结构的树形结构。它基本上展示了你的 <code>parser</code> 如何识别语言结构或者， 换句话说，它展示了你语法的开始符号怎么派生出该编程语言中一个特定的字符串的。</p>
</li>
<li><p>抽象语法树（AST）是我们的解释器和未来编译器项目的中心数据结构。</p>
</li>
<li><p>如下图，分别是的AST和解析树。</p>
<p><img src="https://github.com/kun-bin/image/blob/master/lsbasi_part7_ast_01.png?raw=true" alt="AST和解析树对比"></p>
</li>
<li><p>简单来说，AST就是把操作数放到叶节点，操作符放到中间节点和根节点，操作符节点在树中的高度可以体现运算优先级，括号改变优先级也是通过改变操作符的高度。</p>
</li>
<li><p>具体到代码，首先要构建一个AST类，目前这个类里什么也没有，就只是用来让别的类继承。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>接下来要定义这个树的节点类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二元操作符类，继承AST</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">		self.left = left</span><br><span class="line">		self.token = self.op = op</span><br><span class="line">		self.right = right</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 整数类，继承AST</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">		self.token = token</span><br><span class="line">		self.value = token.value</span><br></pre></td></tr></table></figure>
<p><code>Token</code>这个类和前几课里的完全一致。</p>
<p>到此为止，我们就创建好AST的基本结构了，接下来可以通过赋值的方式一点点创建一个解析式的AST，例如<code>2*7+3</code>的AST：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立加号和乘号的Token</span></span><br><span class="line">mul_token = Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">plus_token = Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"><span class="comment"># 先建立乘法操作符的节点</span></span><br><span class="line">mul_node = BinOp(</span><br><span class="line">    <span class="comment"># 左边是第一个乘数</span></span><br><span class="line">    left=Num(Token(INTEGER, <span class="number">2</span>)),</span><br><span class="line">    <span class="comment"># 是乘法</span></span><br><span class="line">    op=mul_token,</span><br><span class="line">    <span class="comment"># 右边是第二个乘数</span></span><br><span class="line">    right=Num(Token(INTEGER, <span class="number">7</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment">#建立加法操作符的节点</span></span><br><span class="line">add_node = BinOp(</span><br><span class="line">    <span class="comment"># 左边是刚才进行的乘法节点</span></span><br><span class="line">    left=mul_node,</span><br><span class="line">    <span class="comment"># 中间是加号</span></span><br><span class="line">    op=plus_token,</span><br><span class="line">    <span class="comment"># 右边是加数</span></span><br><span class="line">    right=Num(Token(INTEGER, <span class="number">3</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把上述内容合并到之前的代码中，在<code>Lexer</code>得到词法单元后，不是直接进行运算，而是建立AST，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parse</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        和之前一样</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        和之前一样</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        和之前一样</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="comment"># 之前是return token.value</span></span><br><span class="line">	    	<span class="keyword">return</span> Num(token)</span><br><span class="line">		<span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            <span class="comment"># 之前是value = self.expr()</span></span><br><span class="line">            node = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="comment"># 之前是return value</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 之前是value = self.factor()</span></span><br><span class="line">		node = self.factor()</span><br><span class="line">		<span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">            	self.eat(MUL)</span><br><span class="line">                <span class="comment"># 之前有value *= self.factor()求值</span></span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">            	self.eat(DIV)</span><br><span class="line">                <span class="comment"># 之前有value /= self.factor()求值</span></span><br><span class="line">	    	node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line">        <span class="comment"># 之前是return value</span></span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 之前是value = self.term()</span></span><br><span class="line">        node = self.term()</span><br><span class="line">		<span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">		    token = self.current_token</span><br><span class="line">	    	<span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">				self.eat(PLUS)</span><br><span class="line">                <span class="comment"># 之前有value += self.factor()求值</span></span><br><span class="line">	    	<span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">				self.eat(MINUS)</span><br><span class="line">                <span class="comment"># 之前有value -= self.factor()求值</span></span><br><span class="line">	    	node = BinOp(left=node, op=token, right=self.term())</span><br><span class="line">        <span class="comment"># 之前是return value</span></span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.expr()</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结一下就是，原本求值的地方，现在改为不断给<code>node</code>赋值，而<code>node</code>则层层嵌套，最终可以表达出AST。</p>
</li>
<li><p>以<code>7 + 3 * (10 - 1)</code>为例，看这份代码：</p>
<ol>
<li><code>parse</code>调用<code>expr()</code>，进入<code>expr</code>；</li>
<li><code>expr</code>调用<code>term</code>，<code>term</code>调用<code>factor</code>，发现是<code>INTEGER</code>，于是返回<code>Num(token(INTEGER,7))</code>作为<code>node</code>，<code>term</code>发现接下来不是乘除法，于是直接返回<code>node</code>，回到<code>expr</code>，该节点类型以下简写为<code>Num(7)</code>；</li>
<li><code>expr</code>发现接下来是加法，于是<code>node</code>变为<code>BinOp(left=Num(7), op=Token(PLUS, &#39;+&#39;), right=self.term())</code>，再次调用<code>term</code>；</li>
<li><code>term</code>调用<code>factor</code>得到<code>Num(3)</code>，接下来是乘法，于是这里要返回给第三步中<code>expr</code>的<code>right</code>的东西变成了<code>BinOp(left=Num(3), op=Token(MUL, &#39;*&#39;), right=self.factor())</code>，显然又要调用<code>factor</code>；</li>
<li><code>factor</code>判断接下来的左括号，于是调用<code>expr</code>处理，内容和上面的类似，会返回<code>BinOp(left=Num(10), op=Token(MINUS, &#39;-&#39;), right=Num(1))</code>给第四步的<code>right</code>；</li>
<li>以此类推，最终<code>parse</code>中得到的是<code>node=BinOp(left=Num(7), op=Token(PLUS, &#39;+&#39;), right=BinOp(left=Num(3), op=Token(MUL, &#39;*&#39;), BinOp(left=Num(10), op=Token(MINUS, &#39;-&#39;), right=Num(1))))</code>。</li>
</ol>
</li>
</ol>
<h4 id="遍历树求值"><a href="#遍历树求值" class="headerlink" title="遍历树求值"></a>遍历树求值</h4><ol>
<li><p>在得到AST之后，就要开始求值了，我们采用后序遍历的方法来遍历AST进行运算。</p>
<ol>
<li><p>前序遍历：<strong>根</strong>左右</p>
</li>
<li><p>中序遍历：左<strong>根</strong>右</p>
</li>
<li><p>后序遍历：左右<strong>根</strong></p>
</li>
<li><p>显然前中后是指根节点的遍历输出顺序，如下图的树，前序遍历的输出结果是：1-&gt;2-&gt;4-&gt;6-&gt;7-&gt;3-&gt;5，中序遍历是4-&gt;6-&gt;7-&gt;2-&gt;1-&gt;5-&gt;3，后序遍历是7-&gt;6-&gt;4-&gt;2-&gt;5-&gt;3-&gt;1</p>
<p><img src="https://github.com/kun-bin/image/blob/master/visit.png?raw=true" alt="一棵树"></p>
</li>
<li><p>对应到AST中，就是先访问<code>node</code>的<code>left</code>，得到一个结果，再访问<code>right</code>，得到另一个结果，最后访问中间的<code>op</code>，进行运算，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="comment"># for every child node from left to right</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">		visit(child)</span><br><span class="line">    <span class="comment"># 指加减乘除等运算操作</span></span><br><span class="line">    &lt;&lt;postorder actions&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>有时可能三种遍历都需要进行一些操作，因此伪代码改为：</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    &lt;&lt; preorder actions &gt;&gt;</span><br><span class="line">    left_val = visit(node.left)</span><br><span class="line">    &lt;&lt; inorder actions &gt;&gt;</span><br><span class="line">    right_action = visit(node.right)</span><br><span class="line">    &lt;&lt; postorder actions &gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体来实现的时候首先要有<code>NodeVisitor</code>类：</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        method_name = <span class="string">'visit_'</span> + type(node).__name__</span><br><span class="line">        visitor = getattr(self, method_name, self.generic_visit)</span><br><span class="line">        <span class="keyword">return</span> visitor(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">		<span class="keyword">raise</span> Exception(<span class="string">'No visit_&#123;&#125; method'</span>.format(type(node).__name__))</span><br></pre></td></tr></table></figure>
<p>   <code>getattr(object, name, default)</code>函数的作用是，返回<code>object</code>这个变量的<code>name</code>属性，如果没有<code>name</code>则返回<code>default</code>，如果用这个函数的时候没有指明<code>default</code>，那么当<code>name</code>属性不存在时会报错。</p>
<p>   <code>f.__name__</code>的作用是返回<code>f</code>的函数名。</p>
<p>   在这段代码中，首先<code>method_name</code>是当前节点<code>node</code>对应<code>Token</code>的<code>type</code>，接下来返回该<code>NodeVisitor</code>对象的<code>method_name</code>属性，如果不存在则报错。具体来说，当<code>node</code>类型是<code>BinOp</code>时，会返回<code>visit_BinOp(node)</code>，而<code>node</code>类型是<code>Num</code>时，则返回<code>visit_Num(node)</code>。</p>
</li>
<li><p>接下来看我们的解释器<code>Interpreter</code>类，它继承了<code>NodeVisitor</code>：</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(NodeVisitor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parser)</span>:</span></span><br><span class="line">		self.parser = parser</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> node.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interpret</span><span class="params">(self)</span>:</span></span><br><span class="line">        tree = self.parser.parse()</span><br><span class="line">        <span class="keyword">return</span> self.visit(tree)</span><br></pre></td></tr></table></figure>
<p>   首先是解释器的初始化，我们将<code>parser</code>得到的AST传入<code>Interpreter</code>。</p>
<p>   接下来访问二元运算符节点的函数，该函数逻辑很简单，就是判定传入的<code>node</code>对应的<code>op</code>类型是什么，然后访问其左右节点，最后进行运算。</p>
<p>   最后是访问整数节点的函数，该函数负责将节点的<code>value</code>返回。</p>
<p>   这里要总结一下<code>node</code>这个变量，因为<code>python</code>里不需要指定变量类型，会动态决定，实际上这里的<code>node</code>有两个可能，当它是叶节点的时候，它是整数，也就是<code>Num(Token)</code>类型，在<code>visit</code>函数后会返回并执行<code>visit_Num</code>函数；而当它是中间节点和根节点时，就变成操作符，也就是<code>BinOp(left, op, right)</code>类型，在<code>visit</code>函数后会返回并执行<code>visit_BinOp</code>函数。</p>
</li>
<li><p>当调用解释器的<code>interpret</code>函数时，首先进入<code>visit</code>函数，判定是操作符，转入<code>visit_BinOp</code>函数，再判断运算类型，并访问左右节点直到得到一个返回值，最后进行运算得到结果。</p>
</li>
<li><p>总结一下，整个流程是：parser 从 lexer 中 得到 token 然后返回生成的 AST 给 interpreter 进行遍历并解释执行所给输入。</p>
</li>
</ol>
<h4 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h4><p>一个 <strong>递归下降parser</strong> 就 是一个自顶向下的 parser，它使用一组递归过程来处理输入。自顶向下反映了 parser 从 构建解析树的顶部结点开始逐渐构建更低的结点这一事实。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>写一个翻译器（提示：node visitor），它接收一个算术表达式作为输入并打印出它的后缀形式，即逆波兰式(Reverse Polish Notation, RPN)。例如，如果翻译器接收的输入是 表达式 <code>(5 + 3) * 12 / 3</code> 则输入应该是 <code>5 3 + 12 * 3 /</code> 。答案在<a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/ex1.py" target="_blank" rel="noopener">这儿</a>，不过要先自己解决再看啊。</p>
<p>我的想法是：逆波兰式输出顺序实际上就是这一课遍历的顺序，因此只需要在现有的<code>visit_BinOp</code>和<code>visit_Num</code>加上<code>print</code>就行，注意这里因为是后序输出，<code>BinOP</code>需要先<code>visit(left)</code>和<code>visit(right)</code>，再<code>print(op.value)</code>，代码修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">        tmp = self.visit(node.left) + self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">        tmp = self.visit(node.left) - self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">        tmp = self.visit(node.left) * self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">        tmp = self.visit(node.left) // self.visit(node.right)</span><br><span class="line">    print(node.op.value, end=<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    print(node.value, end=<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure>
</li>
<li><p>写一个翻译器（node visitor），它接收一个算术表达式作为输入并将它打印为 LISP 风 格的记法，即 <code>2 + 3</code> 变成 <code>(+ 2 3)</code> 及 <code>(2 + 3 * 5)</code> 变成 <code>(+ 2 (* 3 5))</code> 。你 可以在<a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/ex2.py" target="_blank" rel="noopener">这儿</a>打到答案，但在查看之前还是要先尝试自己解决。</p>
<p>这是要前序遍历输出，也就是先输出<code>op.value</code>，再进行<code>visit(left)</code>和<code>visit(right)</code>，和练习1相比，就是把<code>visit_BinOp</code>中的<code>print(node.op.value, end=&#39; &#39;)</code>放到最前面。</p>
</li>
</ol>
<p>（这俩练习的答案和我想的还有点不太一样……不过问题不大……）</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-6</title>
    <url>/2020/03/12/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-6/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part6/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/02/01/lets-build-a-simple-interpreter-part-06/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/lsbasi-part6" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'LPAREN'</span>, <span class="string">'RPAREN'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;repr(self.value)&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "4 + 2 * 3 - 6 / 2"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Lexer error'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            value += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'('</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(LPAREN, <span class="string">'('</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">')'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(RPAREN, <span class="string">')'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Interpreter error'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="keyword">return</span> token.value</span><br><span class="line">        <span class="keyword">elif</span> self.current_token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            value = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        value = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token_type = self.current_token.type</span><br><span class="line">            <span class="keyword">if</span> token_type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                value *= self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token_type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                value /= self.factor()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1))</span></span><br><span class="line"><span class="string">        22</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        value = self.term()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token_type = self.current_token.type</span><br><span class="line">            <span class="keyword">if</span> token_type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                value += self.term()</span><br><span class="line">            <span class="keyword">elif</span> token_type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                value -= self.term()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.expr()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            print()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> len(text.strip()):</span><br><span class="line">            interpreter = Interpreter(Lexer(text))</span><br><span class="line">            print(interpreter.parse())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课在加减乘除的基础上加入了括号，而括号里的内容又可以看做是一个新的加减乘除表达式，即如下语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr   : term   ((PLUS | MINUS) term)*</span><br><span class="line">term   : factor ((MUL | DIV) factor)*</span><br><span class="line">factor : INTEGER | LPAREN expr RPAREN</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>expr</code>和<code>term</code>没有任何变化，而<code>factor</code>则多了一种可能：<code>(expr)</code>，因此需要作出以下修改：</p>
<ol>
<li><code>Lexer</code>部分添加左右括号的返回；</li>
<li><code>Interpreter</code>现在分成了两个分支，字符类型是<code>INTEGER</code>时，和之前的一样，返回该字符的<code>value</code>；字符类型是左括号时，则返回该括号里的<code>expr</code>的值，并把右括号也读过去。</li>
</ol>
<p>这样的递归语法，称之为递归下降解释器。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>如本文的描述，写一个你自己版本的算术表达式解释器。记住：重复是学习之母。</p>
<p>试着回顾一下整个代码的思路：</p>
<ol>
<li><p>代码除了<code>main()</code>以外，有3个<code>class</code>，分别是<code>Token</code>、<code>Lexer</code>、<code>Interpreter</code>。</p>
</li>
<li><p><code>Token</code>是最基础的词法单元，有两个成员变量：<code>type</code>和<code>value</code>，此外有初始化和输出的函数。</p>
</li>
<li><p><code>Lexer</code>是词法分析器，成员变量为：<code>text</code>（完整的语句）、<code>pos</code>（当前读取到语句位置的索引）、<code>current_char</code>（当前读取出的字符），成员函数为：<code>error</code>（报词法错误）、<code>advance</code>（往后读取一个新字符）、<code>skip_whitespace</code>（跳过空格）、<code>integer</code>（把连续的数字字符转成整数返回）、<code>get_next_token()</code>（返回当前词法单元）。</p>
</li>
<li><p><code>Interpreter</code>是语法解释器，成员变量为：<code>lexer</code>（词法分析器）、<code>current_token</code>（当前处理的词法单元），成员函数为：<code>error</code>（报语法错误）、<code>eat()</code>（往后处理下一个词法单元）、<code>factor</code>、<code>term</code>、<code>expr</code>三个都是语法图里的内容，最后加了一个<code>parse</code>返回<code>expr()</code>。</p>
</li>
</ol>
<p>大致就是这样了。</p>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><p>这一课没有这一部分。</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-3</title>
    <url>/2020/03/11/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-3/</url>
    <content><![CDATA[<h3 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h3><p>这次上课有一些是以前不太了解的知识点。</p>
<a id="more"></a>
<h5 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h5><p>包括字符串、列表、元组、字节序列。</p>
<ol>
<li><p>索引访问：</p>
<p>有<code>n</code>个元素的数组，索引范围是<code>[0, n-1]</code>或<code>[-n, -1]</code>，也就是说，除了常规的类似其他语言中数组的下标索引方式，我们还可以通过<code>-1</code>来逆序访问。这在某些时候是很方便的一个操作，比如判断回文字符串。</p>
</li>
<li><p>遍历访问：</p>
<p>遍历也是用<code>for</code>循环，不过和其他语言不同的是，这里<code>for</code>循环中的<code>i</code>类型很随意，可以是<code>1, 2, 3, ...</code>也可以是元组、字符等，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'hello'</span>:</span><br><span class="line">	print(c)</span><br></pre></td></tr></table></figure>
<p>这里的<code>c</code>是字符，最终会把<code>h</code>, <code>e</code>, <code>l</code>, <code>l</code>, <code>o</code> 逐行输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>)]</span><br><span class="line">	print(t,t[<span class="number">0</span>],t[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>这里的<code>t</code>是元组，最终输出是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>,<span class="number">2</span>) <span class="number">1</span> <span class="number">2</span></span><br><span class="line">(<span class="number">3</span>,<span class="number">4</span>) <span class="number">3</span> <span class="number">4</span></span><br><span class="line">(<span class="number">5</span>,<span class="number">6</span>) <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>切片</p>
<p>序列<code>s</code>可以通过<code>s[i:j:k]</code>来截取其中的一部分，<code>i</code>是起点，<code>j</code>是终点，<code>k</code>是步长，注意这里的起点终点都可以是负数，结合上文可知，<code>s[::-1]</code>实际上就是序列的逆序。注意这个切片并不会改变序列<code>s</code>。想要将切片的下标信息保存下来，我们可以使用<code>slice(i:j:k)</code>函数。这里如果越界了也不会报错。</p>
</li>
<li><p>连接和重复</p>
<p>连接<code>+</code>：<code>s1+s2</code></p>
<p>重复<code>*</code>：<code>s*n</code> 或者 <code>n*s</code></p>
<p>增量赋值：<code>+=</code>和<code>*=</code></p>
<p>元组不可以<code>+=</code>序列，但是反过来序列<code>+=</code>元组是没问题的。</p>
</li>
<li><p>成员关系操作</p>
<p><code>in</code>和<code>not in</code>可以判断一个元素是否在序列中。</p>
<p><code>s.count(value)</code>可以统计<code>value</code>在序列<code>s</code>中出现的次数。</p>
<p><code>s.index(value, [start, [stop]])</code>查找value在序列指定范围 <code>[start,stop)</code>中第一次出现的下标。</p>
</li>
<li><p>序列内置函数</p>
<p><code>len</code> 单纯求序列长度</p>
<p><code>sorted</code>对序列排序并返回排序后的列表，不改变原始序列</p>
<p><code>reversed</code>逆序，不改动原序列，返回反向迭代器</p>
<p><code>max</code>和<code>min</code>求最大值和最小值，要求元素类型都一样</p>
<p><code>sum</code>序列求和，要求不能有非数字</p>
<p><code>enumerate</code>返回元素为<code>元组(计数，元素)</code> 的迭代器</p>
<p><code>zip</code>拼接多个对象<code>iter1、iter2…</code>的元素， 返回一个迭代器，其元素为各对象元素组成的元组。</p>
<p><code>all</code>和<code>any</code>判断序列的元素是否全部和部分为True</p>
</li>
<li><p>序列类型转换</p>
<p><code>str</code> <code>list</code> <code>tuple</code> <code>bytes</code> <code>bytearray</code>可以从字面意义看出是转成什么类型。</p>
</li>
<li><p>的</p>
</li>
<li><p>序列拆分</p>
<p><code>变量1,变量2,…,变量n = 序列</code>这样的赋值语句，可以把序列中的元素拆开赋值给前面的变量，不过类型要统一，比如序列中有元组，那前面对应位置的变量也要写成元组的形式。</p>
<p><code>*变量</code>的形式，可以把多个元素打包赋值给一个变量，但是只能出现一次。</p>
<p>可以用临时变量<code>_</code>来占位从而将指定位置的元素赋值给某个变量，例如<code>_, b, _ = (1, 2, 3)</code>就是把<code>2</code>赋值给<code>b</code>。</p>
</li>
</ol>
<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><ol>
<li><p><code>del</code>删除元素，赋值修改元素</p>
</li>
<li><p><code>s.append(x)</code> 把<code>x</code>追加到<code>s</code>末尾</p>
</li>
<li><p><code>s.clear()</code> 删除所有元素</p>
</li>
<li><p><code>s.copy()</code> 复制</p>
</li>
<li><p><code>s.extend(t)</code> 和上面的<code>s.append(x)</code>是一样的，区别在于，<code>append</code>把<code>x</code>作为一个整体加到末尾，而<code>extend</code>把<code>x</code>作为一个新的列表合并到<code>s</code>的末尾。</p>
</li>
<li><p><code>s.insert(i,x)</code>插入</p>
</li>
<li><p><code>s.pop([i])</code>返回并移除下标为<code>i</code>的元素，<code>i</code>省略时默认为最后一个元素</p>
</li>
<li><p><code>s.remove(x)</code>移除列表中第一次出现的<code>x</code></p>
</li>
<li><p><code>s.reverse()</code>列表反转</p>
</li>
<li><p><code>s.sort()</code>列表排序</p>
</li>
<li><p>列表解析表达式：处理可迭代对象并生成结果列表，具体格式为<code>[express for i_1 in 可迭代对象1…for i_N in 可迭代对象N [if condition] ]</code></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line">[(x+y,x*y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表解析生成字典和集合</span></span><br><span class="line">a = [(<span class="string">'小黑'</span>,<span class="string">'领导'</span>,<span class="number">30000</span>),(<span class="string">'小白'</span>,<span class="string">'职员'</span>,<span class="number">10000</span>),(<span class="string">'小蓝'</span>,<span class="string">'职员'</span>,<span class="number">5000</span>)]</span><br><span class="line">&#123;i[<span class="number">0</span>]:i[<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> a&#125;</span><br><span class="line"><span class="comment"># output: &#123;'小黑': 30000, '小白': 10000, '小蓝': 5000&#125;</span></span><br><span class="line">&#123;i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i[<span class="number">2</span>]&gt;=<span class="number">10000</span>&#125;</span><br><span class="line"><span class="comment"># output: &#123;'小白', '小黑'&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ol>
<li><p>已知一选手的各评委得分<code>score = [95, 85, 89, 88, 86, 95, 89, 98, 85, 75, 80]</code>，运用序列的各项操作求该选手的得分，计算规则：去掉一个最高分和一个最低分，剩下的分数计算平均分。</p>
<p>最直接的思路就是整体求和然后减去最大的和最小的再算平均值，也就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = [<span class="number">95</span>, <span class="number">85</span>, <span class="number">89</span>, <span class="number">88</span>, <span class="number">86</span>, <span class="number">95</span>, <span class="number">89</span>, <span class="number">98</span>, <span class="number">85</span>, <span class="number">75</span>, <span class="number">80</span>]</span><br><span class="line">s = (sum(score) - max(score) - min(score)) / (len(score) - <span class="number">2</span>)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断一个字符串是否是回文串：<code>a = &#39;abcdcba&#39;  b = &#39;abcdefg&#39;</code></p>
<p>这个题有很多思路，最快的办法就是用前面提到的<code>s[::-1]</code>来实现逆序，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindromic4</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num == num[::<span class="number">-1</span>]</span><br><span class="line">a = <span class="string">'abcdcba'</span></span><br><span class="line">b = <span class="string">'abcdefg'</span></span><br><span class="line">print(is_palindromic4(b))</span><br></pre></td></tr></table></figure>
<p>也可以选择把字符串转成<code>list</code>或者<code>tuple</code>然后使用<code>reverse</code>函数来实现逆序。即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(a)==list(reverse(a))</span><br><span class="line">tuple(a)==tuple(reverse(a))</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码执行后的<code>s</code>是（）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">s.append([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">s.extend(<span class="string">'34'</span>)</span><br><span class="line">s.extend([<span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">s.insert(<span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">s.insert(<span class="number">10</span>, <span class="number">8</span>)</span><br><span class="line">s.pop(<span class="number">2</span>)</span><br><span class="line">s.remove(<span class="string">'a'</span>)</span><br><span class="line">s[<span class="number">4</span>:] = []</span><br><span class="line">s.reverse()</span><br></pre></td></tr></table></figure>
<p>对照每个函数的作用可以很容易判断出最后的结果是<code>[&#39;4&#39;,&#39;3&#39;,[1,2],7]</code></p>
</li>
</ol>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li><p>使用<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>**</code>运算符和数字<code>2</code>,<code>3</code>,<code>4</code>,<code>5</code>，构造一个表达式，该表达式中上述4个数字和3种不同运算符各用一次，使得表达式的结果为24，打印出满足条件的表达式。</p>
<p>提示：</p>
<p>(1)构建表达式字符串，然后用内置函数<code>eval</code>计算该字符串 ，例如<code>eval(&#39;3*4/2+5&#39;)</code>返回<code>11.0</code>； </p>
<p>(2)两字符串可通过”+”连接成一个字符串，如<code>’he’+’llo’</code>会 得到<code>’hello’</code>； </p>
<p>(3)本题关键在于求排列，排列有多种实现方式，例如循环。</p>
<p>根据提示很容易想到一个思路：把数字的全排列和运算符的取3个排列分别列出来，然后逐一组合成字符串，使用<code>eval</code>计算结果，如果是24，就输出。查找资料后发现<code>python</code>有一个算排列的库函数<code>itertools.permutations(s, n)</code>，该函数返回列表<code>s</code>中取<code>n</code>个元素的排列结果，该结果也是一个列表，也就是说我们可以通过该函数得到数字和运算符的排列结果，并<code>for</code>循环遍历，将它们组成计算表达式并求结果，然后输出。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">op = [<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>, <span class="string">'**'</span>]</span><br><span class="line">num = [<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(num, <span class="number">4</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> itertools.permutations(op, <span class="number">3</span>):</span><br><span class="line">        s = i[<span class="number">0</span>] + j[<span class="number">0</span>] + i[<span class="number">1</span>] + j[<span class="number">1</span>] + i[<span class="number">2</span>] + j[<span class="number">2</span>] + i[<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> float(eval(s)) == <span class="number">24.0</span>:</span><br><span class="line">            print(s)</span><br></pre></td></tr></table></figure>
<p>此外，<code>python</code>中完成24点游戏的思路还有很多很多，复杂一些的办法可以是构造二叉树，然后遍历节点。</p>
</li>
<li><p>输入一个列表，然后删除该列表中的重复的元素，要求删除重复元素后还保持原排序，最后输出结果。例如，输入列表 <code>[0, 1, 1, 1, 3, 0, 3, 2]</code>，输出 <code>[0, 1, 3, 2]</code>。</p>
<p>这个题也有很多思路，比如逐个比较等。有一种很便捷的方法是，对输入列表生成字典，这样就按顺序去掉了重复元素，再将字典的<code>key</code>转成列表即可，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = eval(input(<span class="string">'请输入一个列表：'</span>))</span><br><span class="line">list2 = dict.fromkeys(list1)</span><br><span class="line">list3 = list(list2.keys())</span><br><span class="line">print(list3)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-5</title>
    <url>/2020/03/09/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-5/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part5/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/30/lets-build-a-simple-interpreter-part-05/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/lsbasi-part5" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, MINUS, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;repr(self.value)&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Lexer error'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            value += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Interpreter error'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER"""</span></span><br><span class="line">        value = self.current_token.value</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        value = self.factor()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            <span class="keyword">if</span> self.current_token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                value *= self.factor()</span><br><span class="line">            <span class="keyword">elif</span> self.current_token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                value /= self.factor()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt;  14 + 2 * 3 - 6 / 2</span></span><br><span class="line"><span class="string">        17</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        value = self.term()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            <span class="keyword">if</span> self.current_token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                value += self.term()</span><br><span class="line">            <span class="keyword">elif</span> self.current_token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                value -= self.term()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.expr()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            print()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(text.strip()):</span><br><span class="line">            interpreter = Interpreter(Lexer(text))</span><br><span class="line">            result = interpreter.parse()</span><br><span class="line">            print(result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课讲的是运算结合性和优先级的处理。</p>
<h4 id="什么是结合性"><a href="#什么是结合性" class="headerlink" title="什么是结合性"></a>什么是结合性</h4><p>当一个操作数（比如 7+3+1 中的 3）两边都有加号时，我们需要一个规则来决定哪个运算符作用于 3，根据经验，是左边的加号起作用（也就是先计算7+3），因此我们把加号看做是左结合的。类似地，减、乘、除也都是左结合的。</p>
<h4 id="什么是优先级"><a href="#什么是优先级" class="headerlink" title="什么是优先级"></a>什么是优先级</h4><p>当一个操作数（比如 7 + 5 <em> 2 中的5）两边有不同的运算符时，先进行运算的那个运算符优先级较高，比如我们说运算符\</em>比+先取运算符，*就有较高的优先级。</p>
<p>在一个表达式中有相同优先级的运算符出现时，我们就使用结合性惯例从左到右执行。</p>
<h4 id="构建语法和写解释器"><a href="#构建语法和写解释器" class="headerlink" title="构建语法和写解释器"></a>构建语法和写解释器</h4><p>以算术表达式为例，优先级列表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优先级</th>
<th>结合性</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>左结合</td>
<td>+, -</td>
</tr>
<tr>
<td>1</td>
<td>左结合</td>
<td>*, /</td>
</tr>
</tbody>
</table>
</div>
<p>从优先级表构建语法：</p>
<ol>
<li>对于每一个优先级定义一个非终结符。这个非终结符的生成式的 body 应该由本优先级的算术运算符和更高优先级的非终结符组成。</li>
<li>对表达式的基本单元(在我们的例子中是 INTEGER)新建一个额外的非终结符 <code>factor</code>. 一般原则就是如果你有 N 级优先级，你一共会需要 N+1 非终结符：每个优先级一个再 加上基本单元的一个。</li>
</ol>
<p>具体来说我们现在有2个优先级，因此会有3个非终结符，优先级为2的对应<code>expr</code>，优先级为1的对应<code>term</code>，最后是<code>factor</code>。</p>
<p><code>expr</code>要表达包含<code>term</code>的加减运算，即：<code>expr: term((PLUS|MINUS)term)*</code></p>
<p><code>term</code>则是包含<code>factor</code>的乘除运算，即：<code>term； factor((MUL|DIV)factor)*</code></p>
<p>最后<code>factor</code>是基本单元，即：<code>factor: INTEGER</code></p>
<p>然后就是和上一课一样的步骤写代码了。</p>
<p>（总的来说这一课没有什么新知识，但是我还是不能不看教程自己写…）</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>根据本文的描述凭记忆写出一个解释器，不要参考文中的代码。为你的解释器写一些测试，确保它们可以通过。</p>
<p>我太菜了所以并没法凭记忆写一个解释器，于是我开始照着代码抄一下，并很快发现就算是照抄我也会出错…</p>
<p>主要错误如下：</p>
<ol>
<li><code>else</code>后面忘了加<code>:</code>；</li>
<li>某个地方的赋值(<code>=</code>)一个不注意就写成了相等(<code>==</code>)；</li>
<li><code>while self.current_char is not None and self.current_char.isdigit():</code>以及前面判断空格的那个类似的语句，<code>is not None</code>一定要放前面，如果反过来，在当前字符是空的时候，执行<code>isdigit()</code>和<code>isspace()</code>就会报错了，所以要先判定不为空。</li>
</ol>
<p>我好菜啊.jpg</p>
</li>
<li><p>扩展这个解释器来处理包含括号的算术表达式，使得你的解释器可以对嵌套很深很深的算术表达式进行求值如：7 + 3 * (10 / (12 / (3 + 1) - 1))</p>
<p>这个我的想法是要设定一下括号的结合性，左括号是右结合而右括号是左结合，但是不会写。</p>
<p>看了下一课发现是要写递归语法分析，所以放下一课来写吧。</p>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>一个操作符是左结合的是什么意思？</p>
<p>是指当数字左右两边都有该运算符时，数字取左边的运算符。</p>
</li>
<li><p>操作符加减是左结合的还是右结合的？乘除呢？</p>
<p>都是左结合。</p>
</li>
<li><p>操作符加是否比操作符乘有更高的优先级？</p>
<p>否，乘的优先级更高。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-2</title>
    <url>/2020/03/04/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<ol>
<li><p>下面程序的运行结果是（    ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">		<span class="keyword">if</span> i == j == <span class="number">1</span>；</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(i, <span class="string">'----'</span>, j)</span><br></pre></td></tr></table></figure>
<p>A.    0 —— 0                B.    0 —— 0<br>​        0 —— 1                       0 —— 1<br>​        0 —— 2                       0 —— 2<br>​        1 —— 0                       1 —— 0<br>​        2 —— 0<br>​        2 —— 1<br>​        2 —— 2</p>
</li>
</ol>
<a id="more"></a>
<p>答案：A（我怀疑这题的选项对齐在网页上显示会出问题，不过懒得改了）</p>
<p><code>break</code>的中断只会断一层，也就是说这个代码在<code>i=j=1</code>的时候，属于<code>j</code>的循环会中断，<code>j=2</code>和<code>j=3</code>将跳过，直接开始<code>i=2, j=0</code>然后继续循环，也就是A选项。</p>
<ol>
<li><p>下面程序的运行结果是（    ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">		<span class="keyword">if</span> i == j == <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(i, <span class="string">'----'</span>, j)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>A.    0 —— 0                B.    0 —— 0<br>​        0 —— 1                       0 —— 1<br>​        0 —— 2                       0 —— 2<br>​        1 —— 0                       1 —— 0<br>​        2 —— 0<br>​        2 —— 1<br>​        2 —— 2</p>
</li>
</ol>
<p>答案：B</p>
<p>这里首先要学习的是<code>python</code>与其他语言中不太一样的<code>else</code>用法，在其他语言中，<code>else</code>只搭配<code>if</code>来做条件判断，而<code>python</code>中有<code>for... else...</code>、<code>while...else...</code>和<code>try...else...</code>的用法，具体来说，在<code>for</code>循环中如果有并触发了<code>break</code>，则<code>for</code>循环后的<code>else</code>语句不会被执行，如果没触发或者没有，则会执行<code>else</code>分支的语句；在<code>while</code>循环中，也是如此，<code>break</code>不执行或不存在的时候，就会执行<code>else</code>语句，而如果执行了<code>break</code>就不会执行<code>else</code>；<code>try</code>中的用法则是当<code>try</code>块中的语句正常执行完毕就会执行<code>else</code>分支。</p>
<p>其次，<code>continue</code>在循环中是用来跳过这次循环并开始下一次循环，比如在<code>j=1</code>的时候<code>continue</code>，则<code>j=1</code>中剩下的语句不执行，但是会开始执行<code>j=2</code>，而不是像<code>break</code>那样跳出<code>j</code>的循环去执行<code>i</code>的循环。</p>
<p>分析这个代码，这个<code>else</code>分支是<code>j</code>的循环对应的，也就是说<code>i=0,j=x</code>时，没触发<code>break</code>，每次都会执行<code>else</code>中的<code>continue</code>，也就是说此时最后一行的打断<code>i</code>的循环的<code>break</code>不会执行；在<code>i=j=1</code>的时候<code>j</code>的循环<code>break</code>了，那么<code>else</code>分支不会执行，就会执行到最后一行的<code>break</code>，从而打断<code>i</code>的循环，程序直接结束，也就是B选项。</p>
<p>课后作业：</p>
<ol>
<li>利用random库，随机出100道两个数的加、减口算题。要求 ： (1)a+b或者a-b，a、b和得数范围均为[0,100]；(2)如果是加法运算，要求有进位；如果是减法运算，要求有退位；(3)在屏幕上打印出结果，每一行显示4道题，注意对齐。示例如下。（示例就不放了总之就是100个加减法运算题，加法有进位减法有借位，输出是格式化的）</li>
</ol>
<p>这个本来是不难的，随机生成两个100以内的数字然后随机决定加减法就行，但是还必须有进位和退位。</p>
<p>一开始的思路是，先随机生成第一个数字<code>a</code>，然后再随机生成<code>0</code>和<code>1</code>来决定加减法，接下来如果是加法，就生成一个在<code>a</code>到<code>100-a</code>之间的数字<code>b</code>，如果是减法，就生成一个在<code>1</code>到<code>a</code>之间的数字<code>b</code>，这两个分支中，如果<code>b</code>不符合进位或者退位，就重新生成，也就是一个<code>while</code>循环。</p>
<p>按这个思路写好运行以后就发现了问题，那个<code>while</code>循环有时候会一直循环下去就是找不到符合进位或退位的数字<code>b</code>，这是因为一开始的数字<code>a</code>如果不合适，那什么数字也没法实现进位或者退位，比如加法中，个位数如果是<code>0</code>，这个数字还不是<code>90</code>，则无论如何也不会遇到进位；而减法中，这个数字如果个位是<code>9</code>，题目又要求不会出现负数的减法，那无论如何都不可能有借位运算。也就是说，先决定加减法，再生成一个恰当的数字<code>a</code>，它要符合一些条件，接着生成一个恰当的数字<code>b</code>，也要符合一些条件。</p>
<p>具体来说，数字<code>a</code>要符合：</p>
<pre><code>    1. 如果是加法，则个位数不是0，或这个数不是90，且范围在1到90之间；
     2. 如果是减法，则个位数不是9，且范围在10到100之间。
</code></pre><p>数字<code>b</code>要符合：</p>
<pre><code>    1. 如果是加法，则小于`100-a`，且个位数之和大于10，或十位数之和大于10；
    2. 如果是减法，则小于`a`，且个位数比`a`的个位数大，或十位数比`a`的十位数大。
</code></pre><p>最后就是格式化输出，然后就结束了，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">    bool = random.randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> bool == <span class="number">0</span>:</span><br><span class="line">        a = random.randint(<span class="number">1</span>, <span class="number">90</span>)</span><br><span class="line">        <span class="keyword">while</span> a != <span class="number">90</span> <span class="keyword">and</span> a % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            a = random.randint(<span class="number">1</span>, <span class="number">90</span>)</span><br><span class="line">        b = random.randint(<span class="number">1</span>, <span class="number">100</span> - a)</span><br><span class="line">        <span class="keyword">while</span> ((a % <span class="number">10</span> + b % <span class="number">10</span>) &lt; <span class="number">10</span>) <span class="keyword">and</span> ((a // <span class="number">10</span> + b // <span class="number">10</span>) &lt; <span class="number">10</span>):</span><br><span class="line">            b = random.randint(<span class="number">1</span>, <span class="number">100</span> - a)</span><br><span class="line">        print(<span class="string">'&#123;:&lt;2&#125; + &#123;:&lt;2&#125;='</span>.format(a, b), end=<span class="string">"\t\t"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a = random.randint(<span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">while</span> a % <span class="number">10</span> == <span class="number">9</span>:</span><br><span class="line">            a = random.randint(<span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">        b = random.randint(<span class="number">1</span>, a)</span><br><span class="line">        <span class="keyword">while</span> ((b % <span class="number">10</span>) &lt;= (a % <span class="number">10</span>)) <span class="keyword">and</span> ((b % <span class="number">100</span>) &lt;= (a % <span class="number">100</span>)):</span><br><span class="line">            b = random.randint(<span class="number">1</span>, a)</span><br><span class="line">        print(<span class="string">'&#123;:&lt;2&#125; - &#123;:&lt;2&#125;='</span>.format(a, b), end=<span class="string">"\t\t"</span>)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<p>补充一下关于<code>print</code>格式化输出的内容：</p>
<p><code>python</code>中的<code>print</code>函数有一个<code>end</code>参数，当直接<code>print</code>而没有<code>end</code>时，默认换行；当<code>end=&quot;&quot;</code>时，就不自动换行了；当<code>end=XXX</code>时，在<code>print</code>后，会接着有<code>XXX</code>，比如上面代码的<code>\t\t</code>，也不自动换行。</p>
<p>在<code>C</code>语言中，可以通过<code>prints(&quot;%d, %d&quot;, a, b)</code>来实现输出<code>a, b</code>，并通过<code>%x.yd</code>（比如<code>%5.3d</code>)来控制输出长度和精度，而<code>python</code>中有类似的用法，即<code>str.format()</code>，其基本语法是通过<code>{}</code>和<code>:</code>来代替<code>%</code>。<code>&#39;{:&lt;2} - {:&lt;2}=&#39;.format(a, b)</code>这样的语句含义是：把<code>a</code>和<code>b</code>按默认顺序填入前面的花括号，并把长度控制为2个字符且左对齐。</p>
<p><code>format()</code>的用法很多。</p>
<p>可以接受不限个数和顺序的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">"&#123;&#125; &#123;&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;1&#125; &#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'world hello world'</span></span><br></pre></td></tr></table></figure>
<p>可以指明参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(name=<span class="string">"菜鸟教程"</span>, url=<span class="string">"www.runoob.com"</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过字典设置参数</span></span><br><span class="line">site = &#123;<span class="string">"name"</span>: <span class="string">"菜鸟教程"</span>, <span class="string">"url"</span>: <span class="string">"www.runoob.com"</span>&#125;</span><br><span class="line">print(<span class="string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(**site))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过列表索引设置参数</span></span><br><span class="line">my_list = [<span class="string">'菜鸟教程'</span>, <span class="string">'www.runoob.com'</span>]</span><br><span class="line">print(<span class="string">"网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;"</span>.format(my_list))  <span class="comment"># "0" 是必须的</span></span><br></pre></td></tr></table></figure>
<p>可以向<code>format</code>传入对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssignValue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">my_value = AssignValue(<span class="number">6</span>)</span><br><span class="line">print(<span class="string">'value 为: &#123;0.value&#125;'</span>.format(my_value))  <span class="comment"># "0" 是可选的</span></span><br></pre></td></tr></table></figure>
<p>数字格式化输出的完整形式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.1415926</td>
<td>{:.2f}</td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td>{:+.2f}</td>
<td>+3.14</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>-1</td>
<td>{:+.2f}</td>
<td>-1.00</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td>{:.0f}</td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>5</td>
<td>{:0&gt;2d}</td>
<td>05</td>
<td>数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td>5</td>
<td>{:x&lt;4d}</td>
<td>5xxx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>10</td>
<td>{:x&lt;4d}</td>
<td>10xx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>1000000</td>
<td>{:,}</td>
<td>1,000,000</td>
<td>以逗号分隔的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td>{:.2%}</td>
<td>25.00%</td>
<td>百分比格式</td>
</tr>
<tr>
<td>1000000000</td>
<td>{:.2e}</td>
<td>1.00e+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>13</td>
<td>{:&gt;10d}</td>
<td>13</td>
<td>右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td>{:&lt;10d}</td>
<td>13</td>
<td>左对齐 (宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td>{:^10d}</td>
<td>13</td>
<td>中间对齐 (宽度为10)</td>
</tr>
</tbody>
</table>
</div>
<p><code>^</code>,<code>&lt;</code>, <code>&gt;</code> 分别是居中、左对齐、右对齐，后面带宽度， <code>:</code> 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。<code>+</code> 表示在正数前显示 <code>+</code>，负数前显示 <code>-</code>； （空格）表示在正数前加空格。</p>
<p>此外，还可以转进制输出，<code>b</code>、<code>d</code>、<code>o</code>、<code>x</code> 分别是二进制、十进制、八进制、十六进制。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">'&#123;:b&#125;'.format(11) --&gt; 1011</span><br><span class="line">'&#123;:d&#125;'.format(11) --&gt; 11</span><br><span class="line">'&#123;:o&#125;'.format(11) --&gt; 13</span><br><span class="line">'&#123;:x&#125;'.format(11) --&gt; b</span><br><span class="line">'&#123;:#x&#125;'.format(11) --&gt; 0xb</span><br><span class="line">'&#123;:#X&#125;'.format(11) --&gt; 0XB</span><br></pre></td></tr></table></figure>
<ol>
<li>编写程序，求解所有由两个四位数组成的亲和数。（如果两个正整数a和b满足：a的所有真因数（除本身以外的因数）之和等于b，同时b的所有真因数之和等于a，则称a，b是一对亲和数 。）</li>
</ol>
<p>思路是先写一个算真因数之和的函数，接着写两层循环，第一层<code>a</code>是1000到9999，第二层<code>b</code>是1000到<code>a</code>，然后调用函数判断<code>a</code>和<code>b</code>的真因数之和是否符合条件。一个整数<code>n</code>的真因数之和是很好计算的，只需要遍历1到<code>n//2+1</code>看是否整除<code>n</code>，然后把整除的累加一下，就可以了。</p>
<p>但是实际运行的时候，发现这样搞真的很慢，要等好久才会出结果，这是因为两层<code>for</code>循环，每次都要算两个真因数的和，而这也是一层循环，再加上<code>python</code>本身就效率很低，速度就格外慢了，因此最好的办法是能去掉一层循环，或者有什么库可以飞快地计算真因数之和。</p>
<p>然后在查资料的过程中，看到了另一种亲和数的定义：先求出数字<code>n</code>所有真因数之和<code>a</code>，然后再求出数字<code>a</code>所有真因数之和<code>b</code>。如果<code>a!= b</code> 且<code>n==b</code>，则<code>a</code>、<code>b</code>、<code>n</code>都是亲和数。</p>
<p>也就是说，可以只写一层循环<code>a</code>，计算<code>a</code>的真因数之和<code>b</code>，再计算<code>b</code>的真因数之和<code>sum_b</code>，如果<code>a=sum_b</code>，则符合条件输出一下，反之就直接继续下一次循环，算真因数之和的部分没有变化。这样循环少了一层，运算速度快了好多。</p>
<p>此外，看到一个不是用取余，而是用除法和整除结果来判断是否是因数的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span><span class="params">(n)</span>:</span>  <span class="comment">#计算数字n所有真因数之和</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n/i == float(n//i):</span><br><span class="line">            res += i</span><br><span class="line">    <span class="keyword">return</span>(res)</span><br></pre></td></tr></table></figure>
<p>猜测<code>python</code>中的除法、整除、取余可能有运算时间的差别，不过应该不大。</p>
<p>最后代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算一个数的真因数和</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_factor</span><span class="params">(n)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            sum += i</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">1000</span>, <span class="number">9999</span>):</span><br><span class="line">    b = sum_of_factor(a)</span><br><span class="line">    <span class="keyword">if</span> b &lt;= a:</span><br><span class="line">        sum_b = sum_of_factor(b)</span><br><span class="line">        <span class="keyword">if</span> sum_b == a:</span><br><span class="line">            print(a, b)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[4]</title>
    <url>/2020/02/28/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-4/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/28/lets-build-a-simple-interpreter-part-04/" target="_blank" rel="noopener">翻译</a></p>
<p>(这个翻译里有个别地方翻译错了……)</p>
<p><a href="https://www.oschina.net/translate/lsbasi-part4" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, MUL, DIV, EOF = <span class="string">'INTEGER'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return an INTEGER token value.</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string">        expr   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.factor()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result // self.factor()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h4 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h4><p>虽然课程内容里没有过多涉及这部分，但还是复习一下。从<a href="https://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="noopener">这里</a>复制的</p>
<h5 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h5><p>指不会显示在文本中的字符，主要用于控制文本显示格式，例如换行、分页等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\cx</td>
<td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><p>指正则匹配规则中比较特殊的一些标记。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$</td>
<td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。</td>
</tr>
<tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符 \n 之外的任何单字符。</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始。</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>指明两项之间的一个选择。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h5><p>指限定表达式匹配次数的符号。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配前面的子表达式任意次，可以是零次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody>
</table>
</div>
<p>例如：<code>/[1-9][0-9]*/</code>是指第一位是1-9的某个数字，后面有任意多个0-9的数字，也就是正整数。</p>
<h4 id="上下文无关语法-BNF"><a href="#上下文无关语法-BNF" class="headerlink" title="上下文无关语法/BNF"></a>上下文无关语法/BNF</h4><ol>
<li><p>由一系列规则组成，被称为产生式；</p>
</li>
<li><p>一条规则由一个非终结符(叫做 <strong>head</strong> 或 生成式的 <strong>左边</strong>)，一个分号，和一系列终结 符和/或非终结符(叫做 <strong>body</strong> 或 <strong>右边</strong>)组成；</p>
</li>
<li><p>第一条规则左边的非终结符被叫做 <strong>开始符号</strong>；</p>
</li>
<li><p>通过语法派生出算术表达式的方式 为：首先从开始符号开始，然后反复地使用所包含的非终结符的规则替换该终结符， 直到生成一个只包含终结符的句子。语法能组成的句子构成了一门语言。</p>
<p>例如：一个只有乘除法的计算表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr   : factor ((MUL|DIV) factor)*</span><br><span class="line">factor : INTEGER</span><br></pre></td></tr></table></figure>
<p>有两条规则，其中，<code>expr</code>是开始符号，<code>expr</code>和<code>factor</code>这样的变量是非终结符，<code>MUL</code>、<code>DIV</code>、<code>INTEGER</code>这样的<code>token</code>是终结符。</p>
<p>解读该语法：</p>
<ol>
<li><code>expr</code> 是一个<code>factor</code>后面可选地跟一个乘或除运算符再跟另一个<code>factor</code>，后面也相应可选地跟一个乘或除运算符再跟另一个<code>factor</code>，如此重复。</li>
<li><code>factor</code>是一个整数。</li>
</ol>
</li>
</ol>
<h4 id="语法转代码的规则"><a href="#语法转代码的规则" class="headerlink" title="语法转代码的规则"></a>语法转代码的规则</h4><ol>
<li><p>对于语法中定义的每个规则<code>R</code>，将它做成一个有相同名字的方法，对该规则的引用就变成了一个方法调用：<code>R()</code>。该方法的方法体遵循该规则的步骤，过程中使用相同的准则。</p>
</li>
<li><p>多选一 <code>(a1|a2|aN)</code> 变成 <code>if-elif-else</code>语句。</p>
</li>
<li><p>可选组 <code>(...)*</code> 变成一个可以执行 0 或多次的<code>while</code>循环。</p>
</li>
<li><p>每个<code>Token</code>指针<code>T</code>变成一个 <code>eat</code> 方法调用: <code>eat(T)</code>。<code>eat</code> 方法的工作是：当它匹配到当前的 <code>lookahead</code> 就消耗掉它，然后从<code>lexer</code>中得到一个新<code>token</code>并将它赋值给内部变量 <code>current_token</code>。</p>
<p><img src="https://github.com/kun-bin/image/blob/master/lsbasi_part4_rules.png" alt="语法转换代码示例"></p>
<p>以上面的语法为例：</p>
<ol>
<li><p><code>factor</code>只有一个终结符，所以直接<code>eat()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.eat(INTEGER)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>expr</code>规则体开始的 <code>factor</code> 引用 变成了对 <code>factor()</code> 方法的调用。可行组 <code>(...)*</code> 变成了一个 <code>while</code> 循环，多选一 <code>(MUL|DIV)</code> 变成了一个 <code>if-elif-else</code> 语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.factor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">		token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == MUL:</span><br><span class="line">	    	self.eat(MUL)</span><br><span class="line">	    	self.factor()</span><br><span class="line">		<span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">	    	self.eat(DIV)</span><br><span class="line">	    	self.factor()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>现在的代码整体是这样的：分为三个<code>class</code>，第一个<code>Token()</code>来定义符号类型，第二个<code>Lexer()</code>是词法分析器，用来把字符串分割成符合词法规则的词法单元并返回，比如跳过空格、把连续的数字拼凑成一个整数等，第三个<code>Interpreter()</code>是语法解释器，按顺序读入词法单元并按语法规则完成运算。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>写一个语法来描述包含任意数量的 <code>+</code>,<code>-</code>, <code>*</code>, 或<code>/</code>操作符的算术表达式。这个语法需要能够派生出像  <code>2 + 7 * 4</code>, <code>7 - 8 / 4</code>, <code>14 + 2 * 3 - 6 / 2</code> 等等这样的表达式。</p>
<p>这里要考虑运算优先级的问题，所以把乘除法作为一个单元，加减法作为另一个单元，加减法是高一级的，这样乘除法会被作为一个整体来优先运算，语法规则如下：（其实这里偷看了下一章的答案）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr: term((ADD|MINUS)term)*</span><br><span class="line">term: factor((MUL|DIV)factor)*</span><br><span class="line">factor: INTEGER</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用这个语法，写一个可以对包含任意数量的 <code>+</code>,<code>-</code>, <code>*</code>, 或<code>/</code>操作符的算术表达式求值的解释器。你们解释器需要能够处理像 <code>2 + 7 * 4</code>, <code>7 - 8 / 4</code>, <code>14 + 2 * 3 - 6 / 2</code> 等等这样的表达式。</p>
<p>首先在添加加法和减法的符号定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在开头添加定义</span></span><br><span class="line">INTEGER, MUL, DIV, EOF, ADD, MINUS = <span class="string">'INTEGER'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span>, <span class="string">'ADD'</span>, <span class="string">'MINUS'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Lexer()的get_next_token()添加词法判断</span></span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(ADD, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br></pre></td></tr></table></figure>
<p>接着把上一题写的语法规则转成代码表达，和课程内容类似，<code>factor()</code>部分不变，<code>term()</code>部分是课程中的<code>expr()</code>，<code>expr()</code>部分实际上是把乘除改成加减的<code>term()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.factor()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">		token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == MUL:</span><br><span class="line">	    	self.eat(MUL)</span><br><span class="line">	    	self.factor()</span><br><span class="line">		<span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">	    	self.eat(DIV)</span><br><span class="line">	    	self.factor()</span><br><span class="line">	    	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.term()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (ADD, MINUS):</span><br><span class="line">		token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == ADD:</span><br><span class="line">	    	self.eat(ADD)</span><br><span class="line">	    	self.term()</span><br><span class="line">		<span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">	    	self.eat(MINUS)</span><br><span class="line">	    	self.term()</span><br></pre></td></tr></table></figure>
<p>接下来就是把课程示例代码中的<code>expr()</code>改成<code>term()</code>，然后仿照着写新的<code>expr()</code>了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新的expr()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string">    expr   : term   ((ADD | MINUS) term)*</span></span><br><span class="line"><span class="string">    term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">    factor : INTEGER</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    result = self.term()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (ADD, MINUS):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == ADD:</span><br><span class="line">            self.eat(ADD)</span><br><span class="line">            result = result + self.term()</span><br><span class="line">        <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">            self.eat(MINUS)</span><br><span class="line">            result = result - self.term()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>感受是语法规则写出来以后代码就很好写了。</p>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是上下文无关语法（语法）？</p>
<p>上下文无关文法（英语：context-free grammar，缩写为CFG），在计算机科学中，若一个形式文法<code>G = (N, Σ, P, S)</code> 的产生式规则都取如下的形式：<code>V-&gt;w</code>，则谓之。其中 <code>V∈N, w∈(N∪Σ)*</code> 。上下文无关文法取名为“上下文无关”的原因就是因为字符 V 总可以被字串 w 自由替换，而无需考虑字符 V 出现的上下文。一个形式语言是上下文无关的，如果它是由上下文无关文法生成的。</p>
<p>上下文无关文法重要的原因在于它们拥有足够强的表达力来表示大多数程序设计语言的语法；实际上，几乎所有程序设计语言都是通过上下文无关文法来定义的。另一方面，上下文无关文法又足够简单，使得我们可以构造有效的分析算法来检验一个给定字串是否是由某个上下文无关文法产生的。例子可以参见LR 分析器和LL 分析器。</p>
<p>BNF（巴克斯-诺尔范式）经常用来表达上下文无关文法。</p>
<p>（百度百科复制的）</p>
</li>
<li><p>这个语法有几条规则/生成式？（指例子里的那个乘除法的图）</p>
<p>2条。</p>
</li>
<li><p>什么是终结符？（指出图片中的所有终结符）</p>
<p><code>INTEGER</code>这种的</p>
</li>
<li><p>什么是非终结符？（指出图片中的所有非终结符）</p>
<p><code>expr</code>这种的</p>
</li>
<li><p>什么是一条规则的 head？（指出图片中所有的 head/左边）</p>
<p>最左边的</p>
</li>
<li><p>什么是一条规则的 body？（指出图片中所有的 body/右边）</p>
<p>右边的部分</p>
</li>
<li><p>什么是一个语法的开始符号？</p>
<p>最一开始那个</p>
</li>
</ol>
<p>（2.12开始写的文档，2.28才写完……）</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-1</title>
    <url>/2020/02/26/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<ol>
<li><p>为了给变量x, y, z 赋初值5，下面正确的赋值语句是（）<br>A. xyz=5                    B. x=5 y=5 z=5<br>C. x=5, y=5, z=5        D. x=5;y=5;z=5<br>E. x=y=z=5                 F. x,y,z=5<br>G. x,y,z=5,5,5</p>
<p> [DEG]<br> 没什么说的，运行一下就知道哪个对哪个错了。</p>
</li>
<li><p>x是一个两位数的整数，现将该两位数的个位和十位数字交换，例如13变成31，正确的表达式是（）<br>A. (x%10)*10+x/10           B. (x%10)//10+x/10<br>C. (x/10)%10+x//10          D. (x%10)*10+x//10</p>
<p> [D]<br> 这里要区分“/”和“//”，前者是不取整数的除法，后者是取整，例如7/3=2.333，而7//3=2。</p>
</li>
</ol>
<a id="more"></a>
<p>课后练习：</p>
<ol>
<li>编写程序1：提示输入姓名和出生年份，输出姓名和年龄。运行 结果如：<br>​        请输入你的姓名：<strong><em>张三</em></strong><br>​        你好，张三<br>​        请输入你的出生年份：<strong><em>1999</em></strong><br>​        你好，张三，你今年19岁了。</li>
</ol>
<p>这个很简单了，就是普通的输入输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = input(<span class="string">"请输入你的姓名："</span>)</span><br><span class="line">print(<span class="string">"你好，"</span>, name)</span><br><span class="line">age = input(<span class="string">"请输入你的出生年份："</span>)</span><br><span class="line">print(<span class="string">"你好，"</span>, name, <span class="string">"你今年"</span>, <span class="number">2020</span>-int(age), <span class="string">"岁了"</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>编写程序2： 三角形的三条边长为3、7、9，计算三角形的三个角（提示：余弦定理）</li>
</ol>
<p>这个也还是很简单，虽然我忘了三角形的边角关系公式，不过没关系，百度有。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">7</span></span><br><span class="line">c = <span class="number">9</span></span><br><span class="line">A = math.acos((math.pow(c, <span class="number">2</span>) + math.pow(b, <span class="number">2</span>) - math.pow(a, <span class="number">2</span>)) / (<span class="number">2</span> * b * c))</span><br><span class="line">B = math.acos((math.pow(c, <span class="number">2</span>) + math.pow(a, <span class="number">2</span>) - math.pow(b, <span class="number">2</span>)) / (<span class="number">2</span> * a * c))</span><br><span class="line">C = math.acos((math.pow(a, <span class="number">2</span>) + math.pow(b, <span class="number">2</span>) - math.pow(c, <span class="number">2</span>)) / (<span class="number">2</span> * b * a))</span><br><span class="line">print(<span class="string">"弧度值："</span>, A, B, C)</span><br><span class="line">print(<span class="string">"角度值："</span>, math.degrees(A), math.degrees(B), math.degrees(C))</span><br></pre></td></tr></table></figure>
<ol>
<li><p>编写程序3：对猜数字游戏的程序进行如下修改：</p>
<ol>
<li>由用户键盘输入秘密数的上限和下限。</li>
<li>现有的程序每次只能玩一局，对此进行修改，玩完一局后自动进入下一局。</li>
<li>退出游戏时打印用户总共玩的局数（没玩完的局不算），如果局数不为0，则还需打印每一局的猜测次数。</li>
</ol>
</li>
</ol>
<p>这个看起来复杂，但就是条件说的不清楚而已，总的来说要求是用户输入数字的时候玩猜数字，反之结束游戏，然后输出一下统计结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">count &#x3D; 0</span><br><span class="line">number &#x3D; []</span><br><span class="line">a &#x3D; input(&quot;请输入一个整数下限：&quot;)</span><br><span class="line">while a.isdigit():</span><br><span class="line">    b &#x3D; input(&quot;请输入一个整数上限：&quot;)</span><br><span class="line">    secret &#x3D; random.randint(int(a), int(b))</span><br><span class="line">    print(&quot;我有一个&quot;, a, &quot;-&quot;, b, &quot;的秘密数，想要猜出它？请按数字键并回车；如果不想猜了，可按非数字键并回车或直接回车。&quot;)</span><br><span class="line">    inputStr &#x3D; input(&quot;你猜是？&quot;)</span><br><span class="line">    number.append(0)</span><br><span class="line">    while inputStr.isdigit():</span><br><span class="line">        guess &#x3D; int(inputStr)</span><br><span class="line">        number[count] +&#x3D; 1</span><br><span class="line">        if guess &lt; secret:</span><br><span class="line">            print(&quot;小了&quot;)</span><br><span class="line">        elif guess &gt; secret:</span><br><span class="line">            print(&quot;大了&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;Bingo! 你猜对啦！这个数就是&quot;, secret)</span><br><span class="line">            print(&quot;继续玩下一局！&quot;)</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            break</span><br><span class="line">        inputStr &#x3D; input(&quot;你猜是？&quot;)</span><br><span class="line">    a &#x3D; input(&quot;请输入一个整数下限：&quot;)</span><br><span class="line">print(&quot;再见，下次玩！&quot;)</span><br><span class="line">print(&quot;你一共玩了&quot;, count, &quot;局&quot;)</span><br><span class="line">for i in range(0, count):</span><br><span class="line">    print(&quot;第&quot;, i + 1, &quot;局猜测次数为&quot;, number[i])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[3]</title>
    <url>/2020/02/01/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part3/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/26/lets-build-a-simple-interpreter-part-03/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/lsbasi-part-3" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, MINUX, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">        Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">        Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;repr(self.value)&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 + 5", "12 - 5 + 3", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment"># Lexer code                                             #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the 'pos' pointer and set the 'current_char' variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            value += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment"># Parser / Interpreter code                              #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return an INTEGER token value."""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter."""</span></span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()</span><br><span class="line">        result = self.term()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result += self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result -= self.term()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            print()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课实现了多个数字的加减操作，思路大致和我想的差不多，不过循环条件是“当前字符是加号或减号”。</p>
<p>引入了句法图的使用和句法分析的概念。</p>
<blockquote>
<p>parser 只是识别出结构并保证它符合某些规范，interpreter 在 parser 成功识别后对表达式进行求值。</p>
</blockquote>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>画一张只包含乘除法的算术表达式句法图，例如“7 <em> 4 / 2 </em> 3”。不开玩笑，拿只钢笔 或铅笔试试。</p>
<p>和加减法的句法图一样。</p>
</li>
<li><p>修改计算器的源代码使它解释只包含乘除法的算术表达式，如“7 <em> 4 / 2 </em> 3”。</p>
<p>把代码里的加减换成乘除就行。</p>
</li>
<li><p>从头写一个可以处理如“7 - 3 + 2 - 1”这样算术表达式的解释器。使用任何你喜欢的语 言都可以，只靠自己，不要参考例子。做这件事时，想想都需要包含的组件：lexer 获取 输入并把它转化为 token 流，parser 从 lexer 提供的 token 流中识别结构， interpreter 在 parser 成功识别到一个合法的算术表达式之后求得其结果。把这些连起 来。花点时间把你学到的知识转化为一个可以运行的算术表达式解释器。</p>
<p>因为我别的语言都不太会，所以决定用C语言。本以为，这是个非常简单的事情，没想到写了两天，我好难过啊T_T</p>
<p>第一天发现根本没法不看python代码直接写，这说明我对整个算法流程都还不熟悉，只知道大概原理，没法自己实现，然后开始照着python代码写。这个过程中还发现我对C语言也不太熟悉，很多东西都记不清了，尤其是字符串数组和指针，实际上我到现在也没搞明白<code>char *str</code>和<code>char str[]</code>什么时候用哪个、怎么用。</p>
<p>第二天，也就是今天（20200202），我决定全用<code>char str[100]</code>这种，但还是有各种各样的问题，不过都渐渐解决了。然后花了一个多小时，才发现最大的问题在于C语言的字符串操作完全不能直接用<code>=</code>之类的方式搞，要用<code>strcpy</code>和<code>strcmp</code>，然后又是一个多小时，才发现我把<code>strcpy(new,old)</code>写成了<code>strcpy(old,new)</code>，然后第三个一小时，发现我上一步有两个用了<code>strcpy</code>的没改过来，还把一个<code>while</code>里的<code>==</code>写成了<code>=</code>。我怕是个傻子吧……</p>
<p>总之，现在写完了，能正常运行出结果。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#define SWAP(a,b) (a)^&#x3D;(b);(b)^&#x3D;(a);(a)^&#x3D;(b)</span><br><span class="line"></span><br><span class="line">char INTEGER[100]&#x3D;&quot;INTEGER&quot;;</span><br><span class="line">char PLUS[100]&#x3D;&quot;PLUS&quot;;</span><br><span class="line">char MINUS[100]&#x3D;&quot;MINUS&quot;;</span><br><span class="line">char END[100]&#x3D;&quot;EOF&quot;;</span><br><span class="line">int i&#x3D;1;</span><br><span class="line"></span><br><span class="line">struct Token		&#x2F;&#x2F;词法单元</span><br><span class="line">&#123;</span><br><span class="line">	char type[100];	&#x2F;&#x2F;类型，可以是integer、plus、minus和end</span><br><span class="line">	char value[100];	&#x2F;&#x2F;值，可以是数字，+，-，eof</span><br><span class="line">&#125;;</span><br><span class="line">struct Intepreter		&#x2F;&#x2F;解释器</span><br><span class="line">&#123;</span><br><span class="line">	int pos;			&#x2F;&#x2F;索引</span><br><span class="line">	char current_char;	&#x2F;&#x2F;当前字符</span><br><span class="line">	char text[100];		&#x2F;&#x2F;输入的字符串</span><br><span class="line">	Token token;		&#x2F;&#x2F;当前词法单元</span><br><span class="line">&#125;;</span><br><span class="line">Intepreter intepreter;</span><br><span class="line">int error()			&#x2F;&#x2F;输错符号的报错</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Invalid syntax&quot;);</span><br><span class="line">	exit(100);</span><br><span class="line">&#125;</span><br><span class="line">Intepreter init(char text[100])	&#x2F;&#x2F;初始化解释器</span><br><span class="line">&#123;</span><br><span class="line">	Token tmp;</span><br><span class="line">	tmp.type[100]&#x3D;&#123;&#125;;</span><br><span class="line">	tmp.value[100]&#x3D;&#123;&#125;;</span><br><span class="line">	Intepreter intepreter;</span><br><span class="line">	strcpy(intepreter.text,text);</span><br><span class="line">	intepreter.pos&#x3D;0;</span><br><span class="line">	intepreter.current_char&#x3D;text[intepreter.pos];</span><br><span class="line">	strcpy(intepreter.token.type,tmp.type);</span><br><span class="line">	strcpy(intepreter.token.value,tmp.value);</span><br><span class="line">	return intepreter;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;索引后移一位改变当前字符</span><br><span class="line">Intepreter advance()</span><br><span class="line">&#123;</span><br><span class="line">	intepreter.pos+&#x3D;1;</span><br><span class="line">	if (intepreter.pos&gt;&#x3D;strlen(intepreter.text))</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.current_char&#x3D;&#39;\0&#39;;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.current_char&#x3D;intepreter.text[intepreter.pos];</span><br><span class="line">	&#125;</span><br><span class="line">	return intepreter;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;跳过空格</span><br><span class="line">void skip_whitespace()</span><br><span class="line">&#123;</span><br><span class="line"> 	while(intepreter.current_char&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        intepreter&#x3D;advance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;&#x2F;返回整数词法单元</span><br><span class="line">int integer()</span><br><span class="line">&#123;</span><br><span class="line"> 	int result&#x3D;0;</span><br><span class="line"> 	while (intepreter.current_char&gt;&#x3D;&#39;0&#39; &amp;&amp; intepreter.current_char&lt;&#x3D;&#39;9&#39;)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		result&#x3D;result*10+(intepreter.current_char-&#39;0&#39;);</span><br><span class="line"> 		intepreter&#x3D;advance();</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用来取词法单元</span><br><span class="line">Token get_next_token()</span><br><span class="line">&#123;</span><br><span class="line">	Token token;</span><br><span class="line">	while(intepreter.current_char!&#x3D;&#39;\0&#39;)</span><br><span class="line">	&#123;</span><br><span class="line">		if(intepreter.current_char&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			skip_whitespace();</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&gt;&#x3D;&#39;0&#39; &amp;&amp; intepreter.current_char&lt;&#x3D;&#39;9&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			strcpy(token.type,INTEGER);</span><br><span class="line">			itoa(integer(),token.value,10);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&#x3D;&#x3D;&#39;+&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			intepreter&#x3D;advance();</span><br><span class="line">			strcpy(token.type,PLUS);</span><br><span class="line">			strcpy(token.value,&quot;+&quot;);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&#x3D;&#x3D;&#39;-&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			intepreter&#x3D;advance();</span><br><span class="line">			strcpy(token.type,MINUS);</span><br><span class="line">			strcpy(token.value,&quot;-&quot;);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			error();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	strcpy(token.type,END);</span><br><span class="line">	strcpy(token.value,&quot;EOF&quot;);</span><br><span class="line">	return token;</span><br><span class="line">&#125;</span><br><span class="line">void eat(char type[100])</span><br><span class="line">&#123;</span><br><span class="line">	if (strcmp(intepreter.token.type,type)&#x3D;&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.token &#x3D; get_next_token();</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		int a &#x3D; error();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int term()</span><br><span class="line">&#123;</span><br><span class="line">    Token token;</span><br><span class="line">    strcpy(token.type,intepreter.token.type);</span><br><span class="line">    strcpy(token.value,intepreter.token.value);</span><br><span class="line">    eat(INTEGER);</span><br><span class="line">    return atoi(token.value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;用来算表达式</span><br><span class="line">int expr()</span><br><span class="line">&#123;</span><br><span class="line">	int result&#x3D;0;</span><br><span class="line">	Token token;</span><br><span class="line">	intepreter.token&#x3D;get_next_token();</span><br><span class="line">    result&#x3D;term();</span><br><span class="line">    while ((strcmp(intepreter.token.type,PLUS)&#x3D;&#x3D;0)||(strcmp(intepreter.token.type,MINUS)&#x3D;&#x3D;0))</span><br><span class="line">    &#123;</span><br><span class="line">        strcpy(token.type,intepreter.token.type);</span><br><span class="line">        strcpy(token.value,intepreter.token.value);</span><br><span class="line">        if (strcmp(token.type,PLUS)&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            eat(PLUS);</span><br><span class="line">            result&#x3D;result+term();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (strcmp(token.type,MINUS)&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            eat(MINUS);</span><br><span class="line">            result-&#x3D;term();</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char text[100];</span><br><span class="line">	printf(&quot;calc&gt;&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;, &amp;text);</span><br><span class="line">	intepreter&#x3D;init(text);</span><br><span class="line">	int result&#x3D;expr();</span><br><span class="line">	printf(&quot;result is %d\n&quot;,result);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是句法图？</p>
<p><strong>句法图</strong> 就是程序语言句法规则的图形表示。基本上，句法图从视觉上向 你展示了在你的程序语言中哪些语句是允许的哪些是不允许的。</p>
</li>
<li><p>什么是句法分析？</p>
<p>从 token 流中识别组合的过程叫 <strong>parsing</strong>。</p>
</li>
<li><p>什么是句法分析器？</p>
<p>解释器或编译器中执行parsing的部分叫 <strong>parser</strong>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>各种平台遇到过的error处理方式</title>
    <url>/2020/01/31/%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84error%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>记录一下之前的一些问题。</p>
<a id="more"></a>
<ol>
<li><p>平台：visiual studio<br>error LNK2026: 模块对于 SAFESEH 映像是不安全的<br>解决方法：属性 - &gt; 链接器 - &gt; 附加选项输入 /SAFESEH:NO - &gt; 应用</p>
</li>
<li><p>平台：visiual studio<br>error C4996: ‘fopen’: This function or variable may be unsafe. Consider using fopen_sinstead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help   for details.<br>1&gt;f:\program files (x86)\microsoft visual studio 12.0\vc\include\stdio.h(211) : 参见“fopen”的声明<br>解决方法：预处理器加入_CRT_SECURE_NO_WARNINGS</p>
</li>
<li><p>平台：visiual studio<br>error C2664: “int MessageBoxW(HWND,LPCWSTR,LPCWSTR,UINT)”: 无法将参数 2 从“const char [17]”转换为“LPCWSTR”<br>解决方法：项目菜单-&gt;属性-&gt;配置属性-&gt;常规-&gt;项目默认值-&gt;字符集从unicode改为未设置</p>
</li>
<li><p>平台：visiual studio<br>error LNK2019: 无法解析的外部符号 _main，该符号在函数 ___tmainCRTStartup 中被引用<br>解决方法：右击项目，打开“属性”页，链接器-&gt;系统-&gt;子系统-&gt;/subsystem:windows。如果是刚开始默认的是/subsystem:windows则改为/subsytem:console</p>
</li>
<li><p>平台：visiual studio<br>error LNK2019: 无法解析的外部符号 <strong>imp</strong>timeGetTime@0，该符号在函数 “void __cdecl TimerInit(void)” (?TimerInit@@YAX<br>解决方法：将winmm.lib打入“附加依赖项”</p>
</li>
<li><p>平台：visiual studio<br>fatal error LNK1123: 转换到 COFF 期间失败: 文件无效或损坏<br>解决方法：右键-&gt;工程属性-&gt;配置属性-&gt; 清单工具-&gt;输入和输出-&gt;嵌入清单，选择[否]</p>
</li>
<li><p>突然发现github上的图片打不开，具体来说就是博客里插入了上传到github的图，但是加载不出，这时需要修改hosts文件，如下：</p>
<p>打开路径C:\Windows\System32\drivers\etc下的hosts文件，在最后加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GitHub Start </span><br><span class="line">192.30.253.112    github.com </span><br><span class="line">192.30.253.119    gist.github.com</span><br><span class="line">151.101.184.133    assets-cdn.github.com</span><br><span class="line">151.101.184.133    raw.githubusercontent.com</span><br><span class="line">151.101.184.133    gist.githubusercontent.com</span><br><span class="line">151.101.184.133    cloud.githubusercontent.com</span><br><span class="line">151.101.184.133    camo.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars0.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars2.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars3.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars4.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars5.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars6.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars7.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars8.githubusercontent.com </span><br><span class="line"> # GitHub End</span><br></pre></td></tr></table></figure>
</li>
<li><p>opencv读取图像释放资源时报错：</p>
<p><code>[ WARN:1] global C:\projects\opencv-python\opencv\modules\videoio\src\cap_msmf.cpp (674) SourceReaderCB::~SourceReaderCB terminating async callback</code></p>
<p>修改代码如下：<code>cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)</code></p>
</li>
<li><p>pycharm更新了一下，然后导入包的时候会有<code>unresolved reference issue</code>的提示，但是能正常运行，就只是看起来不好看。</p>
<p>解决方案：<del><a href="https://www.jianshu.com/p/9555310f1920" target="_blank" rel="noopener">有一个</a>说<code>File</code> → <code>Settings</code> → <code>Editor</code> → <code>File Types</code> → <code>Ignore files and folders</code>，干掉框框中的：<code>__init__.py;</code>，然后：<code>OK</code>等待重新文件扫描。但是我打开看了以后发现我的框里并没有<code>__init__.py</code>。于是就<code>File</code> → <code>Invalidate Caches / Restart</code>，选择<code>Invalidate and Restart</code>，等待重新扫描库文件。这之后就好了。</del>并没有解决问题，算了反正不影响运行，就这样吧。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[2]</title>
    <url>/2020/01/31/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part2/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/25/lets-build-a-simple-interpreter-part-02/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/build-a-simple-interpreter-part-2" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: 'INTEGER', 'PLUS', 'MINUS', or 'EOF'</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of class instance</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;self.value&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 + 5", "12 - 5", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the 'pos' pointer and set the 'current_char' variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Parser / Interpreter</span></span><br><span class="line"><span class="string">        expr -&gt; INTEGER PLUS INTEGER</span></span><br><span class="line"><span class="string">        expr -&gt; INTEGER MINUS INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># set current token to the first token from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()</span><br><span class="line">        <span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">        left = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># we expect the current token to be either a '+' or '-'</span></span><br><span class="line">        op = self.current_token</span><br><span class="line">        <span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">            self.eat(PLUS)</span><br><span class="line">        <span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">            self.eat(MINUS)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">        right = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line">        <span class="comment"># EOF token</span></span><br><span class="line">        <span class="comment"># at this point either the INTEGER PLUS INTEGER or</span></span><br><span class="line">        <span class="comment"># the INTEGER MINUS INTEGER sequence of tokens</span></span><br><span class="line">        <span class="comment"># has been successfully found and the method can just</span></span><br><span class="line">        <span class="comment"># return the result of adding or subtracting two integers,</span></span><br><span class="line">        <span class="comment"># thus effectively interpreting client input</span></span><br><span class="line">        <span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">            result = left.value + right.value</span><br><span class="line">        <span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">            result = left.value - right.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这个处理方式和我想的不太一样…</p>
<p>整体逻辑是：</p>
<ol>
<li><code>get_next_token</code>是词法分析器，输入一个字符串，逐一输出词法单元，比如输入<code>32 + 5</code>，输出的流应该是<code>Token(INTEGER, 32) -&gt; Token(PLUS, +) -&gt; Token(INTEGER, 5)</code>。<br>这个词法分析器用到的辅助函数为<code>advance()</code>，<code>skip_whitespace()</code>和<code>interger()</code>，其中<code>advance()</code>让索引后移一位，<code>skip_whitespace()</code>跳过空格，<code>interger()</code>把连续的数字变成一个完整的数字。注意这里如果是多位数中间有空格，多位数会被拆成两个数字，比如<code>32 3</code>会被判断为<code>32</code>和<code>3</code>，而不是<code>323</code>。<br>词法分析过程中会遇到以下几种情况：(1)空格，要跳过空格，循环继续运行，分析下一个字符；(2)结束符，直接返回<code>EOF</code>对应的<code>token</code>；(3)数字，循环终止，连后面的几位数字字符一起变成一个数字，返回对应的<code>token</code>；(4)是<code>+</code>或者<code>-</code>，索引移到下一位，循环终止，返回运算符对应的<code>token</code>。<br>分析几个辅助函数：<ol>
<li><code>advance()</code>，索引<code>pos</code>后移一位，当前字符<code>current.char</code>的值变为新索引对应的字符。</li>
<li><code>skip_whitespace()</code>，循环调用<code>advance()</code>直到当前字符不是空格。</li>
<li><code>integer()</code>，先声明一个初始为空字符串的<code>result</code>，然后循环把<code>current.char</code>加到<code>result</code>这个字符串里，接着<code>advance()</code>移动到下一位，直到当前字符不是数字。</li>
</ol>
</li>
<li><code>expr()</code>是用来计算表达式的，判断词法分析后的词法单元是否符合规则，然后根据规则来计算结果。辅助函数为<code>eat()</code>，用来判断当前词法单元是否符合规则。</li>
</ol>
<p>以输入<code>32 + 5</code>为例分析整个流程：</p>
<ol>
<li><p>首先运行的是<code>main()</code>，获取输入字符串，存到<code>text</code>中（<code>line116</code>)，并用<code>text</code>初始化<code>interpreter</code>这个解释器类(<code>line121</code>)，此时，<code>interpreter.text</code>就是我们输入的字符串，<code>interpreter.pos</code>是初始值<code>0</code>，<code>self.current_token</code>是初始值<code>None</code>，<code>self.current_char</code>是<code>interpreter.text</code>这个字符串数组下标为<code>pos=0</code>对应的字符，也就是<code>3</code>。</p>
</li>
<li><p>接下来<code>line122</code>调用了表达式计算器<code>expr()</code>，而<code>expr()</code>的第一行调用了词法分析器<code>get_next_token()</code>，因为字符3是数字，所以要去调用<code>integer()</code>函数，并返回一个类型为<code>INTEGER</code>、值为函数结果的<code>TOKEN</code>。<br>在执行完<code>integer()</code>并返回之前，<code>pos=0</code>，<code>current_token=None</code>，<code>current_char=3</code>。</p>
</li>
<li><p>进入<code>integer()</code>函数，最初<code>result</code>是空字符串，<code>current_char=3</code>符合循环条件，进入<code>while</code>循环，<code>result</code>变成<code>3</code>（是字符串格式）,调用<code>advance()</code>，接下来先让索引后移，即<code>pos=1</code>，此时还没移到最后一位，更新<code>current_char=text[pos]=text[1]=2</code>。此时还符合循环条件，<code>result</code>把新的<code>current_char</code>加上，变成<code>32</code>（字符串格式），再次<code>advance()</code>，调用完后，<code>pos=2</code>，依旧没移到最后一位，<code>current_char=text[2]=空格</code>。这时不满足循环条件了，循环结束，返回字符串<code>result</code>对应的数字也就是32。</p>
</li>
<li><p>然后回到<code>get_next_token()</code>，它已经有返回值了，返回给之前的<code>expr()</code>中的<code>self.current_token</code>，这是我们得到的第一个词法单元，是我们要计算的表达式的左值，将它存到<code>left</code>中，之后可以使用<code>left.value</code>来访问它的值，这之后就调用<code>eat()</code>看该值是不是一个<code>INTEGER</code>，如果是，就再次调用<code>get_next_token()</code>继续分析下一个单元，反之则报错。很显然此时<code>current_token</code>是<code>(INTEGER,32)</code>，符合要求，进入<code>get_next_token()</code>。</p>
</li>
<li><p><code>get_next_token()</code>判断此时<code>current_char</code>是空格，因此执行<code>skip_whitespace()</code>。</p>
</li>
<li><p>在<code>skip_whitespace()</code>中，<code>current_char</code>满足循环条件，进入循环体，调用<code>advance()</code>，<code>pos=3</code>，<code>current_char=text[3]=+</code>，循环结束，回到<code>get_next_token()</code>，执行<code>continue</code>，也就是继续进行词法判断。</p>
</li>
<li><p>由于<code>current_char</code>是<code>+</code>，在对应的<code>if</code>分支中，执行<code>advance()</code>，<code>pos=4</code>,<code>current_char=text[4]=空格</code>，然后把<code>+</code>对应的<code>token</code>返回到<code>expr()</code>中。</p>
</li>
<li><p><code>expr()</code>把新得到的<code>token</code>存入<code>op</code>，并通过<code>eat()</code>判断该<code>token</code>是否是一个加号或者减号。此时是加号，又开始了<code>get_next_token()</code>。</p>
</li>
<li><p>这次<code>get_next_token()</code>首先进入空格分支，跳过空格后，<code>pos=5</code>，<code>current_char=5</code>，进入数字分支，执行<code>integer()</code>。<code>integer()</code>中和第三步一样，最终返回数字5，再回到<code>get_next_token()</code>，返回5对应的<code>token</code>给<code>expr()</code>，存在<code>right</code>中。</p>
</li>
<li><p>此时，我们已经完成了词法分析，得到了<code>(INTEGER, 32) -&gt; (PLUS, &#39;+&#39;) -&gt; (INTEGER, 5)</code>的词法结构。由于<code>OP</code>对应的类型是<code>PLUS</code>，对<code>left.value</code>和<code>right.value</code>执行加法，存入<code>result</code>并返回。</p>
</li>
<li><p>再回到<code>line122</code>，<code>result</code>已经得到了结果，<code>line123</code>输出该结果，程序运行结束。</p>
</li>
</ol>
<p>也就是说，在计算表达式结果的函数中调用词法分析器，判断词法分析的结果是否符合规则，如果符合规则，就按规则继续运行。在计算器函数中，只会出现<code>token</code>类型的变量，而词法分析函数会负责把词法单元打包成<code>token</code>交给计算器。</p>
<blockquote>
<p>在解释一个表达式之前，你需要知道它是哪种组合，比如相加或相减。这是 <code>expr</code> 方法本质上做的事： 它从 <code>get_next_token</code> 方法得到的 token 流中找到结构，然后解释它识别出的组合，产 生算术表达式的结果。<br>从 token 流中查找结构，或者说从 token 流中识别组合，的过程叫做 <strong>parsing</strong>. 解释器 或编译器中执行这部分任务的叫 <strong>parser</strong>.<br>现在你知道解释器的 <strong>parsing</strong> 和 <strong>解释</strong> 都在 <code>expr</code> 方法中了── <code>expr</code> 方法首先尝 试从 token 流中识别（即parse） INTEGER -&gt; PLUS -&gt; INTEGER 或 the INTEGER -&gt; MINUS -&gt; INTEGER 组合，在成功识别到（即parsed）其中一个组合时，该方法就解释执行 它并返回给调用者两个整数相加或相减的结果。</p>
</blockquote>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>扩展计算器以处理两个整数相乘</p>
</li>
<li><p>扩展计算器以处理两个整数相除</p>
<p>前两个都很简单，仿照加法减法的代码复制改写就行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运算符声明</span></span><br><span class="line">INTEGER, PLUS, MINUS, MULTIPLY, DIVIDE, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MULTIPLY'</span>, <span class="string">'DIVIDE'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get_next_token()</span></span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(MULTIPLY, <span class="string">'*'</span>)</span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(DIVIDE, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># expr()</span></span><br><span class="line"><span class="comment"># 修改读取运算符</span></span><br><span class="line">op = self.current_token</span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">	self.eat(PLUS)</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">	self.eat(MINUS)</span><br><span class="line"><span class="keyword">elif</span> op.type == MULTIPLY:</span><br><span class="line">	self.eat(MULTIPLY)</span><br><span class="line"><span class="keyword">elif</span> op.type == DIVIDE:</span><br><span class="line">	self.eat(DIVIDE)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	self.error()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改计算结果那里</span></span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">	result = left.value + right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">	result = left.value - right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == MULTIPLY:</span><br><span class="line">	result = left.value * right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == DIVIDE:</span><br><span class="line">	result = left.value / right.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	self.error()</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改代码以使它可以解释包含任意个数字的加减操作，如“9 - 5 + 3 + 11”</p>
<p>这个也不难。此时的词法结构是<code>INTEGER -&gt; 循环[OP -&gt;INTEGER]</code>，在<code>expr()</code>里首先读取并<code>eat()</code>第一个词法单元，<code>result</code>先等于这个单元的值，接下来用<code>while</code>进行两个词法单元为一组的循环，直到读取到<code>EOF</code>，每个循环里，<code>result</code>与新的<code>INTEGER</code>进行加减运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line">result = left.value</span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">	op = self.current_token</span><br><span class="line">	<span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">		self.eat(PLUS)</span><br><span class="line">	<span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">		self.eat(MINUS)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		self.error()</span><br><span class="line">	right = self.current_token</span><br><span class="line">	self.eat(INTEGER)</span><br><span class="line">	<span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">		result += right.value</span><br><span class="line">	<span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">		result -= right.value</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		self.error()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是 lexeme？<br>lexeme 是组成 token 的一个字符序列。（这个词翻译过来是<strong>词位</strong>或<strong>词素</strong>）<br><code>token</code>和<code>lexeme</code>的关系类似于类和实例（或者对象）之间的关系。举例来说，变量<code>a</code>和<code>b</code>，它们属于同一种<code>token</code>：<code>identifier</code>，而<code>a</code>的<code>lexeme</code>是<code>a</code>，<code>b</code>的<code>lexeme</code>是<code>b</code>。每个关键字是一种<code>token</code>。<code>token</code>可以附带一个值属性，例如变量<code>a</code>，调用<code>gettoken()</code>时，会返回一个<code>identifier</code>类型的<code>token</code>，其值属性是<code>a</code>。</p>
</li>
<li><p>在 token 流中找到结构的过程叫什么？或者这么问，在 token 流中识别出特定组合的过程叫什么？<br>parsing（翻译是语法分析或句法分析）</p>
</li>
<li><p>解释器（编译器）做 parsing 工作的部分叫什么？<br>parser（也就是语法分析器）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[1]</title>
    <url>/2020/01/30/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/" target="_blank" rel="noopener">翻译</a></p>
<p>上一个翻译页面凉了，找了一个<a href="https://www.oschina.net/translate/build-a-simple-interpreter-part-1" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">        Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">        Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3+5"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        text = self.text    </span><br><span class="line">        <span class="comment"># is self.pos index past the end of the self.text ?</span></span><br><span class="line">        <span class="comment"># if so, then return EOF token because there no more</span></span><br><span class="line">        <span class="comment"># input left to convert into tokens</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(text) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)    </span><br><span class="line">        <span class="comment"># get a character at the position self.pos and decide</span></span><br><span class="line">        <span class="comment"># what token to create based on the single character</span></span><br><span class="line">        current_char = text[self.pos]    </span><br><span class="line">        <span class="comment"># if the character is a digit then convert it to</span></span><br><span class="line">        <span class="comment"># integer, create an INTEGER token, increment self.pos</span></span><br><span class="line">        <span class="comment"># index to point to the next character after the digit,</span></span><br><span class="line">        <span class="comment"># and return the INTEGER token</span></span><br><span class="line">        <span class="keyword">if</span> current_char.isdigit():</span><br><span class="line">            token = Token(INTEGER, int(current_char))</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token    </span><br><span class="line">        <span class="keyword">if</span> current_char == <span class="string">'+'</span>:</span><br><span class="line">            token = Token(PLUS, current_char)</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token    </span><br><span class="line">        self.error()    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""expr -&gt; INTEGER PLUS INTEGER"""</span></span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()    </span><br><span class="line">        <span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">        left = self.current_token</span><br><span class="line">        self.eat(INTEGER)    </span><br><span class="line">        <span class="comment"># we expect the current token to be a '+' token</span></span><br><span class="line">        op = self.current_token</span><br><span class="line">        self.eat(PLUS)    </span><br><span class="line">        <span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">        right = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line">        <span class="comment"># EOF token    </span></span><br><span class="line">        <span class="comment"># at this point INTEGER PLUS INTEGER sequence of tokens</span></span><br><span class="line">        <span class="comment"># has been successfully found and the method can just</span></span><br><span class="line">        <span class="comment"># return the result of adding two integers, thus</span></span><br><span class="line">        <span class="comment"># effectively interpreting client input</span></span><br><span class="line">        result = left.value + right.value</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol>
<li>词法分析(lexical analysis)：把输入字符串拆分成 token 的过程。解释器中做这个工作的部分被称为 <strong>词法分析器</strong>(lexical analyzer)，简称 <strong>lexer</strong> ，也被称作  <strong>scanner</strong> 或 <strong>tokenizer</strong> 。</li>
<li>在完成词法分析后，解释器需要验证token序列是否符合期望的序列，如果符合，则进行一些运算，不符合则抛出异常。</li>
</ol>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><ol>
<li>目的是执行一位数的加法运算，整体逻辑是，先取第一个字符，判断是否是数字，如果是，就把这个数字存在<code>left</code>中，然后取第二个字符，判读是否为加号，如果是，再继续取第三个字符，判断是否为数字并把数字存在<code>right</code>中，接下来就可以计算<code>left.value + right.value</code>了。整个过程中字符的移动依靠一个名为<code>pos</code>的变量，它作为索引，每当取完一个字符，<code>pos</code>的值就会<code>+1</code>，这样直到最后一个字符。</li>
<li><code>Token</code>类构造了一个结构为<code>(类型, 值)</code>的变量，当我们访问某个<code>Token</code>类型的变量<code>v</code>时，可以通过<code>v.type</code>来获取它的类型，通过<code>v.value</code>获取它的值。</li>
<li><code>Interpreter</code>类是我们的解释器类型，其中<code>get_next_token()</code>函数可以从字符串中取一个字符，判断该字符类型是数字还是<code>+</code>，并返回正确的<code>Token</code>结构，比如是数字，就返回<code>Token(INTEGER, int(current_char))</code>，然后索引(<code>pos</code>)往后挪一位，如果既不是数字也不是加号，比如是空格，就会报错，如果已经到最后一位了，会返回<code>EOF</code>。</li>
<li>接下来的<code>eat()</code>函数，参数是判断现在取出来的字符<code>type</code>是否符合设想的<code>type</code>，如果符合，就调用<code>get_next_token()</code>取下一个字符；反之，就输出错误信息。</li>
<li>然后<code>expr()</code>函数用来按顺序从头到尾逐个读取字符，在<code>eat()</code>的帮助下判断整体结构是否符合词法要求（比如这里的要求是<code>INTEGER -&gt; + INTEGER</code>）并执行运算。</li>
<li>最后的<code>main()</code>，将输入的字符串存到<code>text</code>中，并用<code>text</code>初始化类型为<code>Interpreter</code>的变量<code>interpreter</code>，接下来调用<code>interpreter.expr()</code>进行计算，结果存放到<code>result</code>中并输出。</li>
</ol>
<h4 id="python相关"><a href="#python相关" class="headerlink" title="python相关"></a>python相关</h4><ol>
<li><p>python命名规则：以下划线开头的标识符是有特殊意义的。以单下划线开头例如<code>_foo</code> 代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 <code>from xxx import</code> 而导入。<br> 以双下划线开头的 <code>__foo</code> 代表类的私有成员，以双下划线开头和结尾的 <code>__foo__</code> 代表 Python 里特殊方法专用的标识，如 <code>__init__()</code> 代表类的构造函数。</p>
</li>
<li><p>python中的<code>main()</code>函数：python程序按顺序执行，而不是像之前学过的语言那样先找<code>main()</code>然后从<code>main()</code>开始，执行过程中遇到<code>def</code>代码块会先跳过，每个代码块需要保持相同的缩进。</p>
<p> 例如：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># code1</span></span><br><span class="line">print(<span class="string">"test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    str = <span class="string">"function"</span></span><br><span class="line">    print(str)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"main"</span>)</span><br><span class="line">    foo()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">test</span><br><span class="line">main</span><br><span class="line">function</span><br><span class="line"></span><br><span class="line"><span class="comment"># code2</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span>  </span><br><span class="line">        print(<span class="string">"in func_print"</span>)   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>  </span><br><span class="line">        print(<span class="string">"In main"</span>)    </span><br><span class="line">    main()  </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">Hello python !!!</span><br><span class="line">In main</span><br><span class="line"></span><br><span class="line"><span class="comment"># code3</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"in func_print"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"In main"</span>)</span><br><span class="line"></span><br><span class="line">        func_print()</span><br><span class="line">main()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">Hello python !!!</span><br><span class="line">In main</span><br><span class="line"><span class="keyword">in</span> func_print</span><br><span class="line"></span><br><span class="line"><span class="comment">#code4</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"in func_print"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"In main"</span>)</span><br><span class="line"></span><br><span class="line">	func_print()</span><br><span class="line">main()</span><br><span class="line"><span class="comment"># output </span></span><br><span class="line">Hello python !!!</span><br><span class="line"><span class="keyword">in</span> func_print</span><br><span class="line">In main</span><br></pre></td></tr></table></figure>
</li>
<li><p>python中的<code>__name__</code>：<code>__name__</code>是python的一个内置类属性，它天生就存在于一个 python 程序中，代表对应程序名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test()</span><br><span class="line">	print(__name__)</span><br><span class="line">test</span><br></pre></td></tr></table></figure>
<p>直接运行temp2.py 时：<code>__name__=&quot;__main__&quot;</code>，在其它程序中导入temp2.py，则：<code>__name__=&quot;temp2.py&quot;</code>，所以<code>__name__</code>的主要作用就是用来区分，模块是直接被运行还是被导入。</p>
<p>实际使用时，我们会把测试模块时要执行的语句放到<code>if __name__ == &#39;__main__&#39;:</code>这个代码块里，这样测试的时候能看到测试结果，而调用的时候，测试语句不会被执行，也就不用删除测试语句。</p>
</li>
</ol>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>修改代码使得允许输入多位整数，例如<code>12+3</code></p>
<p>多位数不一定是几位数，也就是说我们在得到输入之前无法判断整个字符串第几位是什么类型，但是整体结构一定是<code>连在一起的数字 + 连在一起的数字</code>，因此考虑用<code>while</code>循环读取数字，在当前字符不是数字的情况下跳出循环去读取<code>+</code>，然后继续循环读数字，直到读取出<code>EOF</code>，字符串结束。具体来说是声明<code>left</code>和<code>right</code>两个数字并初始化为0，然后<code>left</code>存第一位数字，接下来乘10+第二位数字，再乘10+第三位数字，依次循环；<code>right</code>也是这样。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line">left = right = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.type == <span class="string">'INTEGER'</span>:    </span><br><span class="line">	left = left * <span class="number">10</span> + self.current_token.value    </span><br><span class="line">	self.eat(INTEGER)</span><br><span class="line"><span class="comment"># 中间几行代码省略</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.type != <span class="string">'EOF'</span>:</span><br><span class="line">	right = right * <span class="number">10</span> + self.current_token.value</span><br><span class="line">	self.eat(INTEGER)</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加一个跳过空白符的方法，使你的计算器可以处理包含空白符的输入如<code>12 + 3</code></p>
<p>我们要增加一个<code>Token</code>类型用来识别空格，然后在<code>expr()</code>中读取到空格时就调用<code>eat()</code>来跳过，我们假设空格不会出现在一个多位数的中间（比如<code>1 2 3</code>就会报错)。</p>
<p>具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在代码开始的地方加</span></span><br><span class="line">SPACE = <span class="string">'SPACE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在get_next_token()里加</span></span><br><span class="line"><span class="keyword">if</span> current_char == <span class="string">' '</span>:</span><br><span class="line">	token = Token(SPACE, current_char)</span><br><span class="line">	self.pos += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在expr()的数字和操作符的前后加</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.value == <span class="string">' '</span>:</span><br><span class="line">	self.eat(SPACE)</span><br></pre></td></tr></table></figure>
<p><strong>这里存在一些问题需要改进</strong>：</p>
<ol>
<li>应该可以想办法跳过多位数中间的空格，也就是直接忽略所有空格；</li>
<li>个人认为不应该在<code>expr()</code>这个函数中出现对字符类型的判断，应该是在<code>expr()</code>中逐位后移，这个过程中调用其他函数来处理忽略空格等情况，也就是说上一个的<code>while</code>循环也不太合适，但是我暂时没想到怎么改，就先这样吧，反正功能上没问题。之后学到正则相关的地方可能会有新的思路。</li>
</ol>
</li>
<li><p>修改代码使得它可以处理<code>-</code>而非<code>+</code>的情况</p>
<p>这个类似于空格，也是要添加一下，我的做法是直接把<code>+</code>和<code>-</code>统一成类型为<code>OP</code>值为对应字符的<code>TOKEN</code>，然后在<code>expr()</code>中最后运算的时候，判断该变量的值是什么，再执行对应的运算。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件开头的PLUS = 'PLUS'修改为</span></span><br><span class="line">OP = <span class="string">'OP'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改get_next_token()</span></span><br><span class="line"><span class="keyword">if</span> current_char == <span class="string">'+'</span> <span class="keyword">or</span> current_char == <span class="string">'-'</span>:</span><br><span class="line">	token = Token(OP, current_char)</span><br><span class="line">	self.pos += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line"><span class="keyword">if</span> op.value == <span class="string">'+'</span>:</span><br><span class="line">	result = left + right</span><br><span class="line"><span class="keyword">if</span> op.value == <span class="string">'-'</span>:</span><br><span class="line">	result = left - right</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   <strong>下一课的内容说明了我的想法全是错的…暴风哭泣</strong></p>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是解释器？</p>
<p>解释器把高级语言逐行转译执行。</p>
</li>
<li><p>什么是编译器？</p>
<p>编译器把高级语言翻译成低级语言，再一起执行。</p>
</li>
<li><p>解释器和编译器的区别是什么？</p>
<p>一个是一边翻译一边执行，一个是翻译完再执行。</p>
</li>
<li><p>什么是 token？</p>
<p>有类型的值的对象</p>
</li>
<li><p>将输入拆分成 token 的过程叫什么？</p>
<p>词法分析</p>
</li>
<li><p>解释器中做词法分析的部分叫什么？</p>
<p>词法分析器(lexical analyzer)</p>
</li>
<li><p>解释器或编译器的这个部分还有什么其他常见的名字？</p>
<p>scanner 或 tokenizer</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo + next + github配置blog</title>
    <url>/2020/01/30/hexo-next-github%E9%85%8D%E7%BD%AEblog/</url>
    <content><![CDATA[<h2 id="安装各种东西"><a href="#安装各种东西" class="headerlink" title="安装各种东西"></a>安装各种东西</h2><ol>
<li><p>node.js：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网链接</a> 点击下载安装即可。</p>
</li>
<li><p>Git： <a href="https://www.git-scm.com/download/win" target="_blank" rel="noopener">Git官网链接</a> 点击下载安装即可。</p>
</li>
<li><p>deployer-git： 命令行里输入<code>npm install hexo-deployer-git --save</code>。</p>
</li>
<li><p>Hexo：</p>
<ol>
<li>准备好一个用于存放博客文件的文件夹（比如Github），在该文件夹的根目录下运行刚才装完git以后会出现的git-bash.exe（这里其实直接用cmd进入命令行然后进入博客文件夹也可以）；</li>
<li>输入命令<code>npm install -g hexo-cli</code></li>
</ol>
</li>
<li><p>这里补充一点：安装的版本很重要，如果hexo和node中某个版本较高，后面配置的时候会冲突，使用<code>hexo -v</code>可以查看版本。我目前使用的版本如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo: 4.2.0</span><br><span class="line">hexo-cli: 4.2.0</span><br><span class="line">os: Windows_NT 10.0.19043 win32 x64</span><br><span class="line">node: 12.20.0</span><br><span class="line">v8: 7.8.279.23-node.45</span><br><span class="line">uv: 1.40.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.16.1</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.41.0</span><br><span class="line">napi: 7</span><br><span class="line">llhttp: 2.1.3</span><br><span class="line">http_parser: 2.9.3</span><br><span class="line">openssl: 1.1.1g</span><br><span class="line">cldr: 37.0</span><br><span class="line">icu: 67.1</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><ol>
<li>创建Hexo工程：接着刚才那个命令输入<code>hexo init blog</code>，这里会在这个文件夹下新建一个blog文件夹，如果把blog换成其他名字也是可以的。</li>
<li>新建Post：命令行里进入blog文件夹（<code>cd blog</code>），输入<code>hexo new “HelloWorld”</code>，这里会在 <strong>/blog/sources/_post/</strong> 目录下生成 <strong>HelloWorld.md</strong> 文件，可以进去打开编辑内容，在之后想写新博客也是通过这个命令生成文件，或者直接把写好的博客文件放到该目录下。</li>
<li>生成静态文件：命令行里输入<code>hexo generate</code>，也可以简单地写成<code>hexo g</code>。这样就使用 <strong>Hexo</strong> 引擎将 <strong>Markdown</strong> 格式的文件解析成可以使用浏览器查看的 <strong>HTML</strong> 文件，<strong>HTML</strong> 文件存储在 <strong>blog/public</strong> 目录下。</li>
<li>运行Hexo服务器：命令行里输入<code>hexo server</code>，也可以简写成<code>hexo s</code>。这时命令行会有一些提示，其中有个地址，一般是<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，在浏览器里打开这个地址，就能看到博客网站是什么样的了。不过这个时候还只是一个本地博客。</li>
</ol>
<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p><strong>Hexo</strong> 提供了默认主题 <strong>landscape</strong>，主题的位置在 <strong>blog -&gt;themes</strong> 文件夹下。主题根据自己喜好可以在网上找到，通过 <strong>Git</strong> 进行相应的下载。接下来以Next主题为例。</p>
<ol>
<li>还是在blog文件夹下，命令行里输入<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code>，这里是用<code>git clone</code>把<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next主题</a>下载并存放到themes -&gt; next 文件夹里。需要注意的是，<code>git clone</code>这个命令下载起来特别慢，但浏览器直接去github下载的话速度还行，所以也可以直接下载解压改文件夹的名字并放到对应的地方。</li>
<li>修改 <strong>/blog/config.yml</strong> 文件，将其中的 <strong>theme</strong> 对应的内容改成 <strong>next</strong>（比如最初是<code>theme: landscape</code>，现在要换成<code>next</code>主题，就改成<code>theme: next</code>）。如果文件夹的名字不是next，或者用了其他主题等，这里的theme字段改成对应的文件夹名字就行。</li>
<li>接下来可以输入<code>hexo g</code> 和<code>hexo s</code>来查看新的本地博客。</li>
</ol>
<h2 id="建立Github博客"><a href="#建立Github博客" class="headerlink" title="建立Github博客"></a>建立Github博客</h2><ol>
<li><p>在<a href="https://github.com/" target="_blank" rel="noopener">Github官网</a>注册账号并登陆，点首页右上角的加号新建一个仓库(Repository)，仓库的名字为用户名.github.io（比如我的是kun-bin.github.io），这里一定要是这个格式，不然之后没法直接访问博客网站。然后其他的都是默认内容，点create repository就可以了。如果仓库名字输入错了，之后可以在github上这个仓库页面的setting选项中修改。</p>
</li>
<li><p>打开 <strong>/blog/config.yml</strong>文件修改deploy 属性(注意“：”之后有空格 ) 否则配置失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;kun-bin&#x2F;kun-bin.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>注意这里repository要替换成自己的仓库地址。</p>
</li>
<li><p>初始化本地仓库：在blog文件夹下的命令行输入<code>git init</code></p>
</li>
<li><p>连接远程仓库：命令行接着输入<code>git remote add origin https://github.com/kun-bin/kun-bin.github.io.git</code>，这里记得把地址改成自己的仓库地址，第一次的时候会要求输入github的账号密码。</p>
</li>
<li><p>发布博客页面：命令行里输入<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>，这等于一次性执行了清空、刷新、部署三个命令，此时在浏览器里已经可以通过<code>用户名.github.io</code>访问博客了，在github的这个仓库里也能看到<strong>/blog/public</strong>文件夹里的内容。</p>
</li>
<li><p>可选：<code>hexo d</code>只是把public文件夹中的内容（也就是静态网页）传到了github的仓库里，应该还可以建立分支把博客配置文件整个传到github上，不过我没做这一步。</p>
</li>
</ol>
<h2 id="关于next主题的配置"><a href="#关于next主题的配置" class="headerlink" title="关于next主题的配置"></a>关于next主题的配置</h2><p>目前在blog文件夹里有一个config.yml文件，我们称之为站点配置文件；而在themes/next文件夹里也有一个config.yml文件，称之为主题配置文件。</p>
<ol>
<li><p>基本信息：打开站点配置文件，找到site模块，可以修改博客标题、作者、描述、语言等等信息，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">language: 语言（简体中文是zh-Hans）</span><br><span class="line">timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）</span><br></pre></td></tr></table></figure>
</li>
<li><p>菜单配置：初始网页只有两个菜单：home和archive，可以打开主题配置文件，找到menu模块，把需要的菜单前面的#删了，并注意把||<strong>前面</strong>的空格删了，不然可能会点了菜单以后报错（类似Cannot GET /tags/%20/这样的错）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home                          <span class="comment">//首页</span></span><br><span class="line">  archives: /archives/|| archive          <span class="comment">//归档</span></span><br><span class="line">  categories: /categories/|| th           <span class="comment">//分类</span></span><br><span class="line">  tags: /tags/|| tags                     <span class="comment">//标签</span></span><br><span class="line">  about: /about/|| user                   <span class="comment">//关于</span></span><br><span class="line">  <span class="meta">#schedule: /schedule/|| calendar        <span class="comment">//日程表</span></span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml|| sitemap        <span class="comment">//站点地图</span></span></span><br><span class="line">  <span class="meta">#commonweal: /404/|| heartbeat          <span class="comment">//公益404</span></span></span><br></pre></td></tr></table></figure>
<p>这里||后面的单词是指菜单对应的图标，可以自己修改。此外，日程表那个模块，因为实际上调用的是谷歌日历，国内显然没法用，所以不建议使用。</p>
</li>
<li><p>建立菜单对应的页面：还是在blog文件夹下打开命令行，输入<code>hexo new page &quot;categories&quot;</code>，然后在~/blog/source 文件夹中即可看到categories文件夹，打开里面的index.md文件，设置如下（注意：后面要加空格）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2020-01-30 08:54:26</span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<p>tags页面也是一样的方式来建立。</p>
</li>
<li><p>主题风格：一共有四个风格可以选择，打开主题配置文件 找到<code>Scheme Settings</code>，把想用的风格前面的#去掉，比如我这里用了Mist。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line">scheme: Mist</span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="comment"># scheme: Gemini</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>侧栏设置：侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等，打开主题配置文件 找到<code>sidebar</code>，按自己的喜好选择，把想要的那一项的#去掉或者false改成true即可。</p>
</li>
<li><p>头像设置：主题配置文件找到<code>avatar</code>，修改avatar后面的路径为自己头像的路径，头像文件要放到<code>themes/next/source/images</code>中，比如头像文件名为<code>header.jpg</code>，就把那一行写成<code>avatar: /images/header.jpg</code>。如果前面有#就去掉#。</p>
</li>
<li><p>添加搜索：</p>
<ol>
<li><p>还是blog文件夹的命令行里，输入<code>npm install hexo-generator-searchdb --save</code>。</p>
</li>
<li><p>打开站点配置文件找到<code>Extensions</code>在下面添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开主题配置文件找到<code>Local search</code>，将<code>enable</code>设置为<code>true</code>。</p>
</li>
</ol>
</li>
<li><p>还有很多能配置的，比如侧边栏头像下面有github链接，点击页面出现爱心符号，博客背景动态变化等，可自行搜索。</p>
</li>
</ol>
<h2 id="关于ayer主题的配置"><a href="#关于ayer主题的配置" class="headerlink" title="关于ayer主题的配置"></a>关于ayer主题的配置</h2><p>今天（2021.02.26）为了让网页中的公式能稍微好一些，我换了一个新主题<a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">ayer</a>。</p>
<ol>
<li><p>安装：在博客文件夹的目录下进命令行输入<code>git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</code>，如果因为网络原因等问题导致GitHub没法用，可以改用码云：<code>git clone https://gitee.com/mirrors/ayer.git themes/ayer</code>；</p>
</li>
<li><p>博客配置文件中的主题改成<code>ayer</code>；</p>
</li>
<li><p>进主题配置文件进行自己需要的修改，比如调整logo、友情链接、启用公式等等；</p>
</li>
<li><p>需要注意的是，这个主题的分类（categories）、标签（tags）等文件和next主题稍微不一样，需要改一下，以分类为例，进入<code>...\source\categories</code>文件夹，可以看到一个<code>index.md</code>文件，打开以后无论里面有什么内容，都彻底改成以下的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-01-30 08:54:26</span><br><span class="line">type: "categories"</span><br><span class="line">layout: "categories"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>相应地，其他用到的文件夹里的<code>index.md</code>也这样改。</p>
</li>
<li><p>安装好以后进行<code>hexo clean</code>等等操作，就可以看到新主题的博客了，不过可能和我的屏幕尺寸有关，在文章页面中，固定的目录栏有些靠右，以至于目录显示不完整，而浮动的目录栏有些靠左了，会挡住正文，当目录很长时，文章几乎没法看了。这时需要打开主题中对目录栏的配置，<code>\themes\ayer\source-src\css\_partial</code>文件夹中的<code>tocbot.styl</code>文件，第一部分<code>.tocbot</code>的<code>right</code>属性从<code>-28rem</code>改成<code>-25rem</code>，这样固定目录栏就相对偏左一些，能显示完整了；第六部分<code>.is-position-fixed</code>的<code>right</code>属性从<code>6rem</code>改成<code>0</code>，这样浮动目录栏就会贴着右边，从而不挡左边了；</p>
</li>
<li><p>按上面这个操作改完以后发现网页的显示并没有变化，接着打开<code>\themes\ayer\source\dist</code>文件夹中的<code>main.css</code>文件，然后直接搜索<code>-28rem</code>或者<code>tocbot</code>等关键词，找到以后把<code>-28</code>和<code>6</code>改成合适的数值（<code>-25</code>和<code>0</code>），重新部署网站就会发现目录栏变合适了。</p>
</li>
</ol>
<h2 id="GitHub风格日历、标签云、分类雷达图的配置"><a href="#GitHub风格日历、标签云、分类雷达图的配置" class="headerlink" title="GitHub风格日历、标签云、分类雷达图的配置"></a>GitHub风格日历、标签云、分类雷达图的配置</h2><p>由于next主题的css文件是swig格式，而网上查到的GitHub日历等都是ejs格式的，因此在用next主题时没能成功配置好日历等；改用Ayer主题后，该主题就是ejs格式的，因此现在添加了日历等内容。这一部分所有涉及到的下载链接都是在别人网站里复制的，如果链接失效可以直接在网上搜文件名来下载，也可以在我的GitHub项目中的主题文件里找已经修改和配置好的相关内容。</p>
<h3 id="需要下载配置的文件"><a href="#需要下载配置的文件" class="headerlink" title="需要下载配置的文件"></a>需要下载配置的文件</h3><ol>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/js/echarts.min.js?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">echarts.min.js</a>，放到主题文件夹中的<code>\source\js</code>文件夹中，</p>
</li>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/css/matery.css?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">matery.css</a>，放到主题文件夹中的<code>\source\css</code>文件夹中。</p>
</li>
<li><p>打开<code>\layout\_partial\head.ejs</code>文件，在<code>head</code>标记中添加一行：</p>
<p><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/matery.css&quot;&gt;</code></p>
<p>这一行直接加到<code>&lt;head&gt;</code>的下一行就好，在我的文件里是加到了第10行，如下图：</p>
<p><img src="https://i.loli.net/2021/02/27/hAeoFcx8wIYlL2S.png" alt="image-20210227182758974"></p>
</li>
</ol>
<h3 id="GitHub风格日历"><a href="#GitHub风格日历" class="headerlink" title="GitHub风格日历"></a>GitHub风格日历</h3><ol>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/ejs-hexo/post-calendar.ejs?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">post-calendar.ejs</a>，放到<code>\layout\_widget</code>文件夹中，如果没有这个文件夹就自己新建一个。</p>
</li>
<li><p>打开<code>post-calendar.ejs</code>文件，看第7行的内容是否为<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/echarts.min.js&quot;&gt;&lt;/script&gt;</code>，如果不是则改成这样。</p>
</li>
<li><p>在打算添加文章日历的地方，输入以下这行代码</p>
<p><code>&lt;%- partial(&#39;_widget/post-calendar&#39;) %&gt;</code></p>
<p>例如我要加到归档页面（<code>archive</code>），就打开<code>\layout\archive.ejs</code>文件，进行添加。不过Ayer主题的这个文件里就下面这行内容：</p>
<p><code>&lt;%- partial(&#39;_partial/archive&#39;, {pagination: config.archive, index: true}) %&gt;</code></p>
<p>如果直接在这一行前面或者后面添加日历代码，显示效果会不太好，而且会被左边的侧栏挡住，因此找到<code>\layout\_partial\archive.ejs</code>文件，在添加日历代码的时候可以多尝试几个位置，看哪个合适。我打算把日历放到“归档”这两个字的下面，文章列表的上面，于是整个文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;% if (theme.ads &amp;&amp; theme.ads.length !&#x3D; 0)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;ads&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% if (theme.broadcast.enable &amp;&amp; pagination &#x3D;&#x3D; 2)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;_partial&#x2F;broadcast&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;article class&#x3D;&quot;articles&quot;&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    var title &#x3D; &#39;&#39;;</span><br><span class="line">    if (page.category) title &#x3D; page.category;</span><br><span class="line">    if (page.tag) title &#x3D; &quot;#&quot; + &quot;&amp;nbsp&quot; + page.tag;</span><br><span class="line">    if (page.archive) &#123;</span><br><span class="line">      if (page.year) title &#x3D; page.year + (page.month ? &#39;&#x2F;&#39; + page.month : &#39;&#39;);</span><br><span class="line">      else title &#x3D; __(&#39;archive_a&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;% if (pagination !&#x3D;&#x3D; 2)&#123; %&gt;</span><br><span class="line">    &lt;h1 class&#x3D;&quot;page-type-title&quot;&gt;&lt;%- title %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">    &lt;% if (pagination &#x3D;&#x3D; 2)&#123; %&gt;</span><br><span class="line">    &lt;% page.posts.each(function(post)&#123; %&gt;</span><br><span class="line">    &lt;%- partial(&#39;article&#39;, &#123;post: post, index: true&#125;) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">  &lt;&#x2F;article&gt;</span><br><span class="line">  &lt;% &#125; else &#123; %&gt;</span><br><span class="line">  &lt;% var last; %&gt;</span><br><span class="line">  &lt;% page.posts.each(function(post, i)&#123; %&gt;</span><br><span class="line">  &lt;% var year &#x3D; post.date.year(); %&gt;</span><br><span class="line">  &lt;% if (last !&#x3D; year)&#123; %&gt;</span><br><span class="line">  &lt;% if (last !&#x3D; null)&#123; %&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% last &#x3D; year; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;_widget&#x2F;post-calendar&#39;) %&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;archives-wrap&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;archive-year-wrap&quot;&gt;</span><br><span class="line">      &lt;a href&#x3D;&quot;&lt;%- url_for(config.archive_dir + &#39;&#x2F;&#39; + year) %&gt;&quot; class&#x3D;&quot;archive-year&quot;&gt;&lt;%&#x3D; year %&gt;&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;archives&quot;&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">      &lt;%- partial(&#39;archive-post&#39;, &#123;post: post, even: i % 2 &#x3D;&#x3D; 0&#125;) %&gt;</span><br><span class="line">      &lt;% &#125;) %&gt;</span><br><span class="line">      &lt;% if (page.posts.length)&#123; %&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;% if (page.total &gt; 1)&#123; %&gt;</span><br><span class="line">  &lt;nav class&#x3D;&quot;page-nav&quot;&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        var prev_text &#x3D; theme.nav_text.page_prev;</span><br><span class="line">        var next_text &#x3D; theme.nav_text.page_next</span><br><span class="line">      %&gt;</span><br><span class="line">    &lt;%- paginator(&#123;</span><br><span class="line">        prev_text: prev_text,</span><br><span class="line">        next_text: next_text</span><br><span class="line">      &#125;) %&gt;</span><br><span class="line">  &lt;&#x2F;nav&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后呈现的效果如下：</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/02/27/sXmQr18FJ6HtNko.png" alt="image-20210227184135159"></p>
<h3 id="标签云"><a href="#标签云" class="headerlink" title="标签云"></a>标签云</h3><ol>
<li><p>下载<a href="https://cdn.jsdelivr.net/gh/InfiniteYinux/cloud@2.44/Hexo/themeConfig/tag-cloud.ejs" target="_blank" rel="noopener">tag-cloud.ejs</a>，放到<code>\layout\_widget</code>文件夹中，如果没有这个文件夹就自己新建一个。</p>
</li>
<li><p>打开<code>tag-cloud.ejs</code>，和前面那个日历一样，检查是否有<code>&lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%- theme.jsDelivr.url %&gt;&lt;%- theme.libs.js.echarts %&gt;&quot;&gt;&lt;/script&gt;</code>，如果有则替换为<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/echarts.min.js&quot;&gt;&lt;/script&gt;</code>。如果没有就忽略。</p>
</li>
<li><p>在需要添加标签云的地方，输入代码：<code>&lt;%- partial(&#39;_widget/tag-cloud&#39;) %&gt;</code></p>
</li>
<li><p>例如我要将这个添加到原本的标签页面，则找到<code>\layout\tags.ejs</code>文件，添加标签云代码。需要注意的是，Ayer主题本身会在这个页面自动生成标签，因此需要把<code>tags.ejs</code>文件中原本的标签内容那行去掉，整个文件改成了以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;% if (site.tags.length)&#123; %&gt;</span><br><span class="line">    &lt;h1 class&#x3D;&quot;page-type-title&quot;&gt;&lt;%&#x3D; __(&#39;tags&#39;) %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;%- partial(&#39;_widget&#x2F;tag-cloud&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此外，标签云本身的标题和Ayer主题中的标题会重复显示，而我更喜欢Ayer本身那个标题，所以编辑了<code>tag-cloud.ejs</code>文件，把第25行的<code>&lt;i class=&quot;fas fa-tags&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&lt;%= __(&#39;postTagTitle&#39;) %&gt;</code>中的<code>postTagTitle</code>改成了空格，之所以没直接去掉这一行，是因为觉得空一行好看一些。</p>
</li>
<li><p>整体效果如图，和Ayer主题本身的标签相比，要好看一些。标签的颜色也可以在<code>tag-cloud.ejs</code>文件中自行修改。<img src="https://i.loli.net/2021/02/27/il6UtNjZsCkqozK.png" alt="image-20210227185130174"></p>
</li>
</ol>
<h3 id="分类雷达图"><a href="#分类雷达图" class="headerlink" title="分类雷达图"></a>分类雷达图</h3><ol>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/ejs-hexo/category-radar.ejs?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">category-radar.ejs</a>，放到<code>\layout\_widget</code>文件夹中，如果没有这个文件夹就自己新建一个。</p>
</li>
<li><p>依旧是检查替换<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/echarts.min.js&quot;&gt;&lt;/script&gt;</code>，如果没有就忽略。</p>
</li>
<li><p>在需要添加分类雷达图的地方，输入代码：<code>&lt;%- partial(&#39;_widget/category-radar&#39;) %&gt;</code></p>
</li>
<li><p>例如我要添加到原本的分类（<code>category</code>）页面，就找到<code>\layout\categories.ejs</code>，这里我不打算去掉原本的分类内容，因此不删除原本的代码，直接添加雷达图代码，修改后的文件整体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;% if (site.categories.length)&#123; %&gt;</span><br><span class="line">    &lt;h1 class&#x3D;&quot;page-type-title&quot;&gt;&lt;%&#x3D; __(&#39;categories&#39;) %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;categories-box&quot;&gt;</span><br><span class="line">      &lt;%- list_categories() %&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;_widget&#x2F;category-radar&#39;) %&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果觉得这个雷达图和主题格格不入，想给它加个边框，则可以在刚才的<code>categories.ejs</code>文件最开头的地方粘贴以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        #contentss &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        width: 800px;</span><br><span class="line">        height: 1200px;</span><br><span class="line">        max-height: 1200px;</span><br><span class="line">        margin-bottom: 15px;</span><br><span class="line">        margin-top: 15px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        border: 0;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        color: rgba(0, 0, 0, .87);</span><br><span class="line">        background: #fff 50%;</span><br><span class="line">        background-size: cover;</span><br><span class="line">        box-shadow: 0 15px 35px rgba(50, 50, 93, .1), 0 5px 15px rgba(0, 0, 0, .07);</span><br><span class="line">        margin:0 auto;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>然后下面的雷达图代码修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;contentss&quot;&gt;</span><br><span class="line">&lt;%- partial(&#39;_widget&#x2F;category-radar&#39;) %&gt;&lt;&#x2F;div&gt;&#96;或者&#96;&lt;%- partial(&#39;_widget&#x2F;post-calendar&#39;) %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>边框的大小样式颜色等等可以自行修改。不过Ayer主题不加边框就挺合适了，因此我没加。</p>
</li>
<li><p>整体效果如下（这个截图是一开始没注意，把雷达图加到了标签页面，但是不影响雷达图的展示；此外，很显然分类名字过长就会显示不完整，这应该和雷达图的大小有关，懒得改了）：</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/02/27/4TRVLa5sFIzktBX.png" alt="image-20210227190056808"></p>
<h2 id="如何发布新的博客"><a href="#如何发布新的博客" class="headerlink" title="如何发布新的博客"></a>如何发布新的博客</h2><ol>
<li><p>在blog文件夹的命令行里输入<code>hexo new &quot;标题&quot;</code>，然后进入<strong>/blog/sources/_post/</strong>找到对应的markdown文件就可以开始写了，也可以直接在这个文件夹下新建一个markdown文件，然后添加对应的文件头。写博客的时候根据需求在文件头里填写tags和categories的信息，然后hexo会自动建立好tags和categories的内容并给文章分类。</p>
<p>文件头信息如下编写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>title:<br>date:<br>tags:<br>categories:</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 写好以后保存，然后还是blog文件夹的命令行，输入&#96;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&#96;，就发布成功了。</span><br><span class="line"></span><br><span class="line">3. 如果一个文章想设置多个标签，那么在编写文件头信息的时候，要按下面的方式写：</span><br></pre></td></tr></table></figure>
<p>   tags:</p>
<pre><code>   - tag1
   - tag2
   ...
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里&#96;tags:&#96; 后面一定要换行，下面的&#96;-&#96;后面注意有空格。</span><br><span class="line"></span><br><span class="line">## 一些后续问题</span><br><span class="line"></span><br><span class="line">今天（2020.03.16）突然发现当博客内容多起来以后，首页会有翻页，而翻页图标显示是乱的，查了一下发现要改&#96;&#x2F;Blog&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;pagination.swig&#96;这个文件，内容整体替换成下面的：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&#123;%- if page.prev or page.next %&#125;</span><br><span class="line"> &lt;nav class&#x3D;&quot;pagination&quot;&gt;</span><br><span class="line">&#123;&#123;</span><br><span class="line">  paginator(&#123;</span><br><span class="line">    prev_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-left&quot; aria-label&#x3D;&quot;&#39;+__(&#39;accessibility.prev_page&#39;)+&#39;&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">    next_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-right&quot; aria-label&#x3D;&quot;&#39;+__(&#39;accessibility.next_page&#39;)+&#39;&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">    mid_size: 1,</span><br><span class="line">    escape: false</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;&#125;</span><br><span class="line"> &lt;&#x2F;nav&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SSH登录配置"><a href="#SSH登录配置" class="headerlink" title="SSH登录配置"></a>SSH登录配置</h2><p>每次<code>hexo d</code>的时候都要输入用户名和密码会很麻烦，所以今天做了一下这个。</p>
<ol>
<li><p>首先进入博客目录比如<code>C:\Users\LiKun\Documents\GitHub\blog</code>，在这个目录下右键然后打开git bash，如果右键没这个选项那就去开始菜单之类的地方打开git bash然后一点点切目录；</p>
</li>
<li><p>输入<code>ls -al ~/.ssh</code>检查目前是否有已经生成过的密钥文件，这个命令会输出<code>.ssh</code>里的文件，如果其中有<code>id_rsa.pub</code>或者<code>id_dsa.pub</code>，那就直接看第五步，如果这俩都没有就继续第三步；</p>
</li>
<li><p>输入<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code>，这里注意把自己的邮箱替换进去，看到提示<code>Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):</code>时，直接按回车；</p>
</li>
<li><p>然后会要求输入密码，这个密码要记住，在第一次使用该ssh密钥时系统会要求输入它，也就是说后面会用，<strong>不过这里有个坑</strong>；</p>
</li>
<li><p>输入<code>clip &lt; ~/.ssh/id_rsa.pub</code>，即可把密钥内容复制到剪贴板，或者自己进<code>.ssh</code>找到密钥文件复制也行；</p>
</li>
<li><p>浏览器打开Github页面，右上角头像那里的下拉菜单有个Settings，点开以后左边找到<code>SSH and GPG keys</code>，点开以后右边的界面会列出目前所有的密钥，如果之前没做过那这里是空的；</p>
</li>
<li><p>SSH Keys那里点<code>New SSH Key</code>，名字随便设置，密钥部分粘贴第五步复制的那个，然后保存；</p>
</li>
<li><p>接下来回博客目录，找到<code>_config.yml</code>，也就是站点配置文件，把最下面<code>deploy</code>属性中的<code>repository:</code>内容修改成<code>git@github.com:你的name/你的username.github.io.git</code>的样子，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:likun1208/likun1208.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>这里有的地方也把<code>repository:</code>写成<code>repo:</code>，应该都行。</p>
</li>
<li><p>然后命令行里<code>hexo d</code>，会要求输入之前第四步里的那个密码；</p>
</li>
<li><p>我本来以为，第四步那个密码是输入一次之后就不用再输入的，然而尝试几次以后发现是每次都要输入，查了很多网页，有说配置ssh的config文件，有说修改host，总之都不太对，最终才发现，这一切都是因为第四步设置了密码，如果第四步不设置密码，一路按回车，就没有任何问题了！ssh似乎没提供修改密码的方式，所以就需要重新输入<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code>，生成新的密钥文件并复制，然后去github的settings那里删旧密钥加新密钥，其他配置不用改动。</p>
</li>
</ol>
<h2 id="分支同步"><a href="#分支同步" class="headerlink" title="分支同步"></a>分支同步</h2><p>今天研究了一下把博客所有文件上传到github仓库的一个分支，这样可以在多个电脑上同步写博客而不需要用U盘来回复制。首先，如果前面没有自己定义分支的名字，那么我们的网站内容是存放在<code>master</code>分支的，在这一步，我们会新建一个<code>hexo</code>分支，来存放博客文件（指主题文件和博客markdown文件等）。具体来说，当我们需要在多个电脑之间迁移博客时，会受影响的文件如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文件（夹）</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">scaffolds/</td>
<td style="text-align:center">博客文章的模版</td>
</tr>
<tr>
<td style="text-align:center">source/</td>
<td style="text-align:center">所有博客文章，以及about、tags、categories等page</td>
</tr>
<tr>
<td style="text-align:center">themes/</td>
<td style="text-align:center">网站的主题</td>
</tr>
<tr>
<td style="text-align:center">.gitignore</td>
<td style="text-align:center">在push时需要忽略的文件和文件夹</td>
</tr>
<tr>
<td style="text-align:center">_config.yml</td>
<td style="text-align:center">站点配置文件</td>
</tr>
<tr>
<td style="text-align:center">package.json</td>
<td style="text-align:center">依赖包的名称和版本号</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>在github网站上找到自己的博客项目，新建<code>hexo</code>分支，并设置为主分支；</p>
</li>
<li><p>在本地博客文件夹里打开git bash，输入<code>git clone git@github.com:用户名/用户名.github.io.git</code>，把<code>hexo</code>分支复制到本地，这里的用户名请自行替换；</p>
</li>
<li><p>在博客文件夹里找到<code>.gitignore</code>文件，如果没有这个文件就自己新建一下，注意这个文件开头就是<code>.</code>，整个名字就是<code>.gitignore</code>，然后打开它里面写入以下内容，表示同步的时候忽略这些文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的<code>.git</code>文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了；</p>
</li>
<li><p>然后在git bash里输入以下命令，即可完成<code>hexo</code>分支的上传：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m &quot;add branch&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>这里的add branch可以改成其他内容，表示这次上传的说明注释；</p>
</li>
<li><p>到此就完成了上传，这样换电脑以后，按照前面的内容把git和hexo以及其他相关东西都安装配置好以后，通过git把这个项目文件下载到本地，就又可以编辑博客了；</p>
</li>
<li><p>如果多个电脑同时在写博客，时不时需要同步博客内容，就不需要<code>git clone</code>下载整个文件，只需要<code>git pull</code>把远程文件同步到本地即可；</p>
</li>
<li><p>总结一下就是，每次写博客之前，首先<code>git pull</code>把github上的博客内容下载到本地；写完新的内容，首先进行<code>hexo clean, hexo g, hexo d</code>把内容渲染成网页并发布，接着<code>git add ., git commit -m &quot;description&quot;, git push</code>把新增和修改的内容也上传到github，这样就可以实现白天在实验室写，晚上回宿舍写的操作了；</p>
</li>
<li><p>以上操作也可以通过github的桌面版程序来完成，还挺方便。</p>
</li>
</ol>
<h2 id="新版live2d"><a href="#新版live2d" class="headerlink" title="新版live2d"></a>新版live2d</h2><p>前面的内容提到了hexo本身可以安装插件并设置live2d的开关，打开以后加载对应模型就能显示了，但是在实际使用的过程中，我发现它支持的是旧版本的live2d，无法显示新版本的，因此研究一番试图加载新版本的。</p>
<p>首先简单说明一下，目前市面上的live2d模型有3个版本，最古老的是2.0版本，它只能用旧版的live2d cubism生成（官网没有对应的版本了），其次是3.0版本，它能用目前所有版本的<a href="https://www.live2d.com/zh-CHS/" target="_blank" rel="noopener">Live2D Cubism</a>软件生成，最新的是4.0版本，能用最新的live2d cubisim制作。虽然可以用同一个软件制作，但是3.0和4.0是不同的，差别在于sdk版本。它们在live2d的模型配置文件（.model.json）中的version都是3，然而用live2d cubism viewer打开查看moc3文件的信息就能发现sdk版本的差异了，这也导致网页渲染的时候要用不同的东西。</p>
<h3 id="3-0版本的处理"><a href="#3-0版本的处理" class="headerlink" title="3.0版本的处理"></a>3.0版本的处理</h3><p>在查找资料的过程中，我首先找到的是众多3.0版本的资料，对比一番可以发现虽然大家原理和代码语法都差不多，但<a href="https://weidows.github.io/post/Web/JavaScript/live2d-moc3/README/" target="_blank" rel="noopener">这个</a>是集大成作，它的行数最少，使用起来很简单，只需要找到主题文件夹中<code>layout</code>目录下的<code>layout.ejs</code>文件（<code>index.ejs</code>应该也可以），然后在最后的<code>&lt;/body&gt;</code>前面添加以下几行代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Live2DCubismCore --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://fastly.jsdelivr.net/gh/Weidows-projects/live2d-moc3/dist/live2dcubismcore.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Include Pixi. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://fastly.jsdelivr.net/gh/Weidows-projects/live2d-moc3/dist/pixi.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://fastly.jsdelivr.net/gh/Weidows-projects/live2d-moc3/dist/live2d.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">addEventListener(<span class="string">"DOMContentLoaded"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">let</span> models=[&#123;<span class="attr">left</span>:<span class="string">"0px"</span>,<span class="attr">bottom</span>:<span class="string">"0px"</span>,<span class="attr">basePath</span>:<span class="string">"https://fastly.jsdelivr.net/gh/likun1208/Live2d_modules@gh-pages/assets"</span>,<span class="attr">role</span>:<span class="string">"test05261"</span>,<span class="attr">background</span>:<span class="string">""</span>,<span class="attr">opacity</span>:<span class="number">1</span>,<span class="attr">mobile</span>:<span class="literal">false</span>,&#125;,];<span class="keyword">new</span> Live2dLoader(models)&#125;);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码中前3行是加载live2d相关的js文件，第四行是加载模型文件，这一步需要把自己要用的模型上传到GitHub，或者用别人Github中已有的文件。具体来说，需要在Github上建立一个仓库用来存模型文件，然后把模型文件放到仓库中，模型文件夹的名字与模型的<code>model3.json</code>文件的名字一定要保持一致，比如我这里的模型文件夹是<code>gongzi</code>，那么里面的文件一定是<code>gongzi.model3.json</code>，其他文件名不重要。</p>
<p>最后在<code>js</code>代码中，<code>basePath</code>设置为如上述代码所示的<code>&quot;https://fastly.jsdelivr.net/gh/likun1208/Live2d_modules@gh-pages/assets&quot;</code>，因为我的模型是在仓库的<code>assets</code>文件夹中，如果直接放仓库里就不要加<code>assets</code>了，前面的<code>gh-pages</code>是分支名，没分支可以不加，再往前的<code>Live2d_modules</code>是仓库名，<code>likun1208</code>是用户名，<code>https://fastly.jsdelivr.net/gh/</code>是cdn加速，不详细介绍了。总之把<code>basePath</code>按这个方式设置好以后，再把<code>role</code>设置成模型文件夹的名字，也就是我这里的<code>gongzi</code>，必要的步骤就完成了，其他可设置的一系列参数在前面提到的参考文档中可以看到。</p>
<p>在把这些准备好以后，要记得把hexo本身的那个live2d关掉，不然两个都会出现。最后部署博客页面就能看到模型了。</p>
<h3 id="4-0版本的处理"><a href="#4-0版本的处理" class="headerlink" title="4.0版本的处理"></a>4.0版本的处理</h3><p>但是很可惜我想用的模型是4.0版本的，前面那段js会报错，在发现自己重做3.0版本模型特别艰难之后，我走上了寻找4.0解决方案的道路，并查到了<a href="https://github.com/Konata09/Live2dOnWeb" target="_blank" rel="noopener">这个项目</a>，它能自动识别模型版本并用对应的方式渲染，哪个版本都兼容，还可以放多个模型来回切换，这非常好。</p>
<p>需要注意的是，如果模型中有expression等字段，它是无法解析的，虽然不影响模型显示，但是对应的表情动作都不会生效。所支持的字段可以查看项目中给的模型例子然后照着写。</p>
<p>具体在hexo博客中的使用，首先需要把项目文件整个都下载好，把其中的<code>dist</code>和<code>model</code>这两个文件夹复制到主题文件夹中的<code>source</code>文件夹下，把其中的<code>waifu-tips.js</code>和<code>waifu-tips.json</code>这两个文件复制到前述<code>source</code>文件夹中的<code>js</code>文件夹下，现在的文件目录如下（没提到的文件未列出）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- blog</span><br><span class="line">    -themes</span><br><span class="line">        -ayer(主题文件夹)</span><br><span class="line">            -source</span><br><span class="line">                - dist</span><br><span class="line">                - model</span><br><span class="line">                - js</span><br><span class="line">                    waifu-tips.js</span><br><span class="line">                    waifu-tips.json</span><br></pre></td></tr></table></figure>
<p>文件都放好以后，打开<code>waifu-tips.js</code>，在前面有一行<code>&#39;modelUrl&#39;: &#39;model&#39;, // 存放模型的文件夹路径，末尾不需要斜杠</code>，把这一行修改为<code>&#39;modelUrl&#39;: &#39;/model&#39;, // 存放模型的文件夹路径，末尾不需要斜杠</code>（在model前面加<code>/</code>，不然网站解析的时候就不是绝对路径了）；打开前面提到过的主题文件夹中<code>layout</code>目录下的<code>layout.ejs</code>文件，在最后的<code>&lt;/body&gt;</code>前面加下列内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"waifu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"waifu-message"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"waifu-tool"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-next"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-home"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-message"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-camera"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-volumeup"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-volumedown"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-about"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-cross"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"live2d2"</span> <span class="attr">style</span>=<span class="string">"top:150px"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"live2d4"</span> <span class="attr">style</span>=<span class="string">"top:150px"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    src 中改为你存放的路径    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/dist/live2d_bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"/js/waifu-tips.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于<code>waifu-tips.js</code>中模型列表等各类内容的配置直接参考项目说明即可。</p>
<p>需要注意的是，这里<code>&lt;canvas id=&quot;live2d2&quot; style=&quot;top:150px&quot;&gt;&lt;/canvas&gt;</code>和它下一行的内容中，<code>style=top:150px</code>是我自己加的，正常模型不需要加这个。我加它的原因是要用的达达利亚模型画布比模型本身大一圈，自己没法修改，只能调整模型位置让它贴到页面边缘。不确定如果换个尺寸的显示屏，这里会不会又出问题，总之姑且先这样了。</p>
<p>接下来重新部署网站，就能看到模型了。</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://segmentfault.com/a/1190000018761324" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018761324</a></p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a></p>
<p><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p>
<p><a href="https://blog.csdn.net/lihangll/article/details/103335246" target="_blank" rel="noopener">https://blog.csdn.net/lihangll/article/details/103335246</a></p>
<p><a href="https://www.cnblogs.com/xinxiandong/p/3867505.html" target="_blank" rel="noopener">https://www.cnblogs.com/xinxiandong/p/3867505.html</a></p>
<p><a href="https://blog.csdn.net/hhgggggg/article/details/77853665" target="_blank" rel="noopener">https://blog.csdn.net/hhgggggg/article/details/77853665</a></p>
<p><a href="https://blog.csdn.net/xiaomengzi_16/article/details/98847298" target="_blank" rel="noopener">https://blog.csdn.net/xiaomengzi_16/article/details/98847298</a></p>
<p><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a></p>
<p><a href="https://blog.csdn.net/White_Idiot/article/details/80685990" target="_blank" rel="noopener">https://blog.csdn.net/White_Idiot/article/details/80685990</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1597223" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1597223</a></p>
<p><a href="https://cndrew.cn/2020/03/03/calender/" target="_blank" rel="noopener">https://cndrew.cn/2020/03/03/calender/</a></p>
<p><a href="https://weidows.github.io/post/Web/JavaScript/live2d-moc3/README/" target="_blank" rel="noopener">👉live2d-moc3-web-集成渲染库 | ⭐️齐下无贰⭐️</a></p>
<p><a href="https://github.com/LitStronger/live2d-moc3" target="_blank" rel="noopener">GitHub - LitStronger/live2d-moc3: live2d, 适用于加载新版moc3游戏角色模型(碧蓝航线)。附带使用例子</a></p>
<p><a href="https://github.com/Konata09/Live2dOnWeb" target="_blank" rel="noopener">GitHub - Konata09/Live2dOnWeb: Add Live2D widget in your website. Support Cubism 2, 3, 4</a></p>
]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
